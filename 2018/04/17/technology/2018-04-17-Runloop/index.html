<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="iOS" />










<meta name="description" content="通过其它平台的实现来 RunLoop 机制，通过源码来学习它的具体实现。主要在于学习到 TSD 线程私有数据的知识，翻阅 iOS 有关 RunLoop 的现有资料都没有讲到。">
<meta name="keywords" content="iOS">
<meta property="og:type" content="article">
<meta property="og:title" content="RunLoop 源码阅读">
<meta property="og:url" content="https://zenonhuang.me/2018/04/17/technology/2018-04-17-Runloop/index.html">
<meta property="og:site_name" content="ZenonHuang">
<meta property="og:description" content="通过其它平台的实现来 RunLoop 机制，通过源码来学习它的具体实现。主要在于学习到 TSD 线程私有数据的知识，翻阅 iOS 有关 RunLoop 的现有资料都没有讲到。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-09-18T13:45:17.822Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RunLoop 源码阅读">
<meta name="twitter:description" content="通过其它平台的实现来 RunLoop 机制，通过源码来学习它的具体实现。主要在于学习到 TSD 线程私有数据的知识，翻阅 iOS 有关 RunLoop 的现有资料都没有讲到。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zenonhuang.me/2018/04/17/technology/2018-04-17-Runloop/"/>





  <title>RunLoop 源码阅读 | ZenonHuang</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZenonHuang</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">人若无名，便可安心练剑</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zenonhuang.me/2018/04/17/technology/2018-04-17-Runloop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZenonHuang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/author.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZenonHuang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">RunLoop 源码阅读</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-17T17:25:00+08:00">
                2018-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/17/technology/2018-04-17-Runloop/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/04/17/technology/2018-04-17-Runloop/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/04/17/technology/2018-04-17-Runloop/" class="leancloud_visitors" data-flag-title="RunLoop 源码阅读">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          
              <div class="post-description">
                  通过其它平台的实现来 RunLoop 机制，通过源码来学习它的具体实现。主要在于学习到 TSD 线程私有数据的知识，翻阅 iOS 有关 RunLoop 的现有资料都没有讲到。
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这一篇文章主要在于 Run Loop 源码的阅读，内容有点长，需要一些基础。</p>
<h1 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h1><p>Run Loop 是一个 iOS 开发里的基础概念，它并非独有的机制，很多系统和框架都有类似的实现，Run Loop 是 Event Loop （事件循环）机制的在 iOS 平台的一种实现。<br>查阅 <a href="https://en.wikipedia.org/wiki/Event_loop" target="_blank" rel="noopener">wikipedia</a> 有关 Event Loop 的描述:</p>
<blockquote>
<p>在计算机科学里， Event Loop / Run Loop 是一个用于等待和发送消息/事件的程序结构，在程序中等待和派发一系列事件或者消息。它通过向“事件提供者”发出请求来工作，通常会阻塞请求，直到事件到达，然后调用相应的事件处理程序。</p>
</blockquote>
<h1 id="Event-Driven"><a href="#Event-Driven" class="headerlink" title="Event Driven"></a>Event Driven</h1><p>说到 Event Loop ，其实还应该了解到 Event-Driven (事件驱动)。</p>
<p>Event-Driven 的出现，在于解决图形界面和用户交互的问题：</p>
<blockquote>
<p>通常 GUI 程序的交互事件执行是由用户来控制的，无法预测它发生的节点，对应这样的情况，需要采用 Event-Driven 的编程方法。</p>
</blockquote>
<p>Event-Driven 的实现原理，基本就是使用 Event Loop 完成。Event-Driven 程序的执行，可以概括成: </p>
<blockquote>
<p>启动 ——&gt; 事件循环（即等待事件发生并处理之）。</p>
</blockquote>
<p>在 GUI 的设计场景下，一般写代码会是下面的思维：</p>
<blockquote>
<p>用户输入 -&gt; 事件响应 -&gt; 代码运行 -&gt; 刷新页面状态</p>
</blockquote>
<h2 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h2><p>我们一直在说 Event Loop 和 Event-Driven 。那什么是 Event (事件) 呢？</p>
<p>在 Event-Driven 中，可以把一切行为都抽象为 Event 。例如: IO 操作完成,用户点击按钮,一个图片加载完成,文本框的文字改变等等情况，都可以看作是一个 Event 。</p>
<h2 id="Event-Handler"><a href="#Event-Handler" class="headerlink" title="Event Handler"></a>Event Handler</h2><p>当 Event 被放到 Event Loop 里进行处理的时候，会调用预先注册过的代码对 Event 做处理。这就叫 Event Handler 。</p>
<p>Event Handler 其实就是对 Event 的响应，可以叫做事件回调，事件处理，事件响应，都是一样的概念。</p>
<p>这里需要注意的是，一个 Event 并不一定有 Event Handler .</p>
<h2 id="Event-Loop-解决了什么问题"><a href="#Event-Loop-解决了什么问题" class="headerlink" title="Event Loop 解决了什么问题"></a>Event Loop 解决了什么问题</h2><p>一般来说，操作分为同步和异步。</p>
<p>同步操作，是一个接一个的处理。等前一个处理完，再执行下一个。那么在一些耗时任务上，比如有很多 I/O 操作 或者 网络请求 的任务，线程就会有长时间在等待任务结果。</p>
<p>异步操作，是不用等待执行结果的，可以直接在这期间执行另外的任务。等到任务结果出来之后，再进行处理。</p>
<p>实际上 Event Loop 就是实现异步的一种方法。</p>
<p>对于有回调的 Event,线程不用一直等待任务的结果出来再去执行下一个。而是等 Event 被加入到 Event Loop 时，再去执行。如果一个 Event 也没有，那线程就会休眠，避免浪费资源。</p>
<p>如果没有 Event Loop 来实现异步操作，那我们的程序会很容易出现卡顿。</p>
<blockquote>
<p>扩展 ：<br>JavaScript 在单线程条件下运行，可以完成异步操作，也是基于 Event Loop 机制。<br>建议可以参考 <a href="https://zhuanlan.zhihu.com/p/26567159" target="_blank" rel="noopener">JavaScript异步编程</a> 的内容来理解，更以帮助我们触类旁通，学习到通用的知识。</p>
</blockquote>
<h1 id="Run-Loop-实现"><a href="#Run-Loop-实现" class="headerlink" title="Run Loop 实现"></a>Run Loop 实现</h1><p>网上目前有关 Run Loop 的文章， 10 篇里面可能有 8 篇都是重复了 <a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a> 中的代码。</p>
<p>然而这都是经过作者大量简化过的版本，隐藏了大量的细节。</p>
<p>其实从细节里面,我们一样可以学习到很多东西,不妨尝试去阅读一下。</p>
<p>我们知道 CFRunLoopRef 的代码是开源的，可以查看源代码来看它的实现，我选择的版本是 <a href="https://opensource.apple.com/source/CF/CF-1153.18" target="_blank" rel="noopener">CF-1153.18</a> 中的 CFRunLoop.c 。</p>
<h2 id="获取-Run-Loop"><a href="#获取-Run-Loop" class="headerlink" title="获取 Run Loop"></a>获取 Run Loop</h2><p>由于苹果不允许我们直接创建 RunLoop，只提供 2 个获取操作的函数：</p>
<ul>
<li>CFRunLoopGetMain  :</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetMain</span>(<span class="keyword">void</span>) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">CFRunLoopRef</span> __main = <span class="literal">NULL</span>; <span class="comment">// no retain needed</span></span><br><span class="line">    <span class="keyword">if</span> (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); <span class="comment">// no CAS needed</span></span><br><span class="line">    <span class="keyword">return</span> __main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>CFRunLoopGetCurrent :</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetCurrent</span>(<span class="keyword">void</span>) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> rl = (<span class="built_in">CFRunLoopRef</span>)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">    <span class="keyword">if</span> (rl) <span class="keyword">return</span> rl;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet0(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CHECK-FOR-FORK"><a href="#CHECK-FOR-FORK" class="headerlink" title="CHECK_FOR_FORK()"></a>CHECK_FOR_FORK()</h3><p>在两个函数里，都有使用了 CHECK_FOR_FORK() 。</p>
<p>它应该是属于多进程情况下的一个断言。</p>
<p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/AboutThreads/AboutThreads.html#//apple_ref/doc/uid/10000057i-CH6-SW2" target="_blank" rel="noopener">Threading Programming Guide</a> 中，有这么一段话:</p>
<blockquote>
<p>Warning: When launching separate processes using the fork function, you must always follow a call to fork with a call to exec or a similar function. Applications that depend on the Core Foundation, Cocoa, or Core Data frameworks (either explicitly or implicitly) must make a subsequent call to an exec function or those frameworks may behave improperly.</p>
</blockquote>
<p>也就是说，当通过 fork 启动一个新进程的时候，你必须要接着调用一个 exec 或类似的函数。而依赖于 Core Founadtion / Cocoa / Core Data 框架的应用,必须调用 exec 函数,否则这些框架也许不能正确的工作。</p>
<p>所以为了保证安全，使用 CHECK_FOR_FORK 进行检查。</p>
<h4 id="FORK"><a href="#FORK" class="headerlink" title="FORK"></a>FORK</h4><p>这里简单提一下 fork 。</p>
<p>在 UNIX 中，用 fork 来创建子进程，调用 fork( ) 的进程被称为父进程，新进程是子进程，并且几乎是父进程的完全复制(变量、文件句柄、共享内存消息等相同，但 process id 不同）。</p>
<p>因为子进程和父进程基本是一样的，要想让子进程去执行其他不同的程序，子进程就需要调用 exec ，把自身替换为新的进程，其中process id不变，但原来进程的代码段、堆栈段、数据段被新的内容取代，来执行新的程序。</p>
<p>这样 fork 和 exec 就成为一种组合。</p>
<p>而在 iOS 这样的类 UNIX 系统里，基本上也都要通过 fork 的形式来创建新的进程。</p>
<p>假如没有执行完 exec ，那么执行的代码段等内容，还是父进程里的，出现问题可以说百分之百。这就是  CHECK_FOR_FORK 检查的目的。</p>
<h3 id="Thread-specific-data"><a href="#Thread-specific-data" class="headerlink" title="Thread-specific data"></a>Thread-specific data</h3><p>为了帮助理解，还需要先说 Thread-specific data (TSD)，它可以叫作 线程私有数据 , 这个概念来自于 unix 之中。</p>
<p>它是存储和查询与某个线程相关数据的一种机制:</p>
<blockquote>
<p>进程内的所有线程,共享进程的数据空间，因此全局变量为所有线程所共有。<br>而有时线程也需要保存自己的私有数据，这时可以创建线程私有数据（Thread-specific Data）TSD来解决。<br>在线程内部，私有数据可以被各个函数访问，但对其他线程是屏蔽的。例如我们常见的变量errno，它返回标准的出错信息。它显然不能是一个局部变量，几乎每个函数都应该可以调用它；但它又不能是一个全局变量。</p>
</blockquote>
<p>在 <a href="https://zh.wikipedia.org/wiki/POSIX%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">Pthreads</a> 里，把它叫做 Thread-local storage (线程私有存储) , 有以下几个相关的操作函数:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- pthread_key_create(): 分配用于标识进程中线程特定数据的pthread_key_t类型的键</span><br><span class="line">- pthread_key_delete(): 销毁现有线程特定数据键</span><br><span class="line">- pthread_setspecific(): 为指定线程的特定数据键设置绑定的值</span><br><span class="line">- pthread_getspecific(): 获取调用线程的键绑定值，并将该绑定存储在 value 指向的位置中</span><br></pre></td></tr></table></figure>
<p>在苹果的平台上，基本就是利用上面操作实现 TSD 。</p>
<p>RunLoop 实际上就属于 TSD 的里存储的一种数据。所以我们讲， RunLoop 和线程是一一对应的。而 RunLoop 会在线程销毁时，跟着一起清理，也是由于线程私有数据的机制。</p>
<p>TSD 对应存储的 key 有相关的析构函数，线程退出时，析构函数函数就会按照操作系统,实现定义的顺序被调用。所以在 CFSetTSD 会有一个析构函数的参数位置。</p>
<h3 id="CFGetTSD-CFSetTSD"><a href="#CFGetTSD-CFSetTSD" class="headerlink" title="CFGetTSD / CFSetTSD"></a>CFGetTSD / CFSetTSD</h3><p>关于 CFGetTSD / CFSetTSD , 在 <a href="https://opensource.apple.com/source/CF/CF-635/ForFoundationOnly.h" target="_blank" rel="noopener">ForFoundationOnly.h</a> 找到定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---- Thread-specific data --------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get some thread specific data from a pre-assigned slot.</span></span><br><span class="line"><span class="built_in">CF_EXPORT</span> <span class="keyword">void</span> *_CFGetTSD(uint32_t slot);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set some thread specific data in a pre-assigned slot. Don't pick a random value. Make sure you're using a slot that is unique. Pass in a destructor to free this data, or NULL if none is needed. Unlike pthread TSD, the destructor is per-thread.</span></span><br><span class="line"><span class="built_in">CF_EXPORT</span> <span class="keyword">void</span> *_CFSetTSD(uint32_t slot, <span class="keyword">void</span> *newVal, <span class="keyword">void</span> (*destructor)(<span class="keyword">void</span> *));</span><br></pre></td></tr></table></figure>
<p><code>TSD</code> 也就是 <code>thread specific data</code> 的缩写了。</p>
<p>按照注释，说明 <code>CFGetTSD</code> 的作用是 – 从预先赋值的位置，得到 <code>TSD</code>。 </p>
<p>上面也说明了 <code>CFSetTSD</code> 的作用 – 在预先位置设置 <code>TSD</code> 。 这个数据不可以是随机的值，并保证你使用的位置有唯一性。如果需要释放这个数据，就传入析构函数;如果不需要释放，则传入NULL。和 pthread TSD 不同的是，这一个析构函数是每一个线程都有的。</p>
<p>在上面的<code>CFRunLoopGetCurrent</code>里,是这么使用  _CFGetTSD 的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</span><br></pre></td></tr></table></figure></p>
<p>这里的 slot 值，一般对应的，都应该是类似 __CFTSDKeyRunLoop 的枚举类型的关键字。</p>
<h3 id="CFTSDTable"><a href="#CFTSDTable" class="headerlink" title="CFTSDTable"></a>CFTSDTable</h3><p>在 <a href="https://opensource.apple.com/source/CF/CF-1153.18/CFPlatform.c.auto.html" target="_blank" rel="noopener">CFPlatform.c</a> 找到 CFGetTSD / CFSetTSD 具体的实现，发现两者其实都依靠了 CFTSDTable 类型的一个  table 实现。</p>
<p>CFTSDTable 是一个保存 TSD 数据的结构体:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Data structure to hold TSD data, cleanup functions for each</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __CFTSDTable &#123;</span><br><span class="line">    uint32_t destructorCount;</span><br><span class="line">    uintptr_t data[<span class="built_in">CF_TSD_MAX_SLOTS</span>];</span><br><span class="line">    tsdDestructor destructors[<span class="built_in">CF_TSD_MAX_SLOTS</span>];</span><br><span class="line">&#125; __CFTSDTable;</span><br></pre></td></tr></table></figure>
<p>它拥有两个数组: data 存储私有数据， destructors 存储释放函数 . 还有一个 destructorCount ，它顾名思义就是 destructors 数组的数量。</p>
<p>CFGetTSD 主要是取了 table ，获取 table 的 data 数组，按 slot 索引取值。</p>
<p>CFSetTSD 的作用，就是根据 CFTSDTable 的结构，分别是往 table 里设置 data 数组 slot 位置的值，以及 destructors 数组 slot 位置的值:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *oldVal = (<span class="keyword">void</span> *)table-&gt;data[slot];</span><br><span class="line"></span><br><span class="line">table-&gt;data[slot] = (uintptr_t)newVal;</span><br><span class="line">table-&gt;destructors[slot] = destructor;</span><br></pre></td></tr></table></figure>
<h3 id="CFRunLoopGet0"><a href="#CFRunLoopGet0" class="headerlink" title="CFRunLoopGet0"></a>CFRunLoopGet0</h3><p>无论是 CFRunLoopGetMain 还是 CFRunLoopGetCurrent ，两者调用了 CFRunLoopGet0 :</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">CFMutableDictionaryRef</span> __CFRunLoops = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CFLock_t</span> loopsLock = <span class="built_in">CFLockInit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// should only be called by Foundation</span></span><br><span class="line"><span class="comment">// t==0 is a synonym for "main thread" that always works</span></span><br><span class="line"><span class="built_in">CF_EXPORT</span> <span class="built_in">CFRunLoopRef</span> _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pthread_equal(t, kNilPthreadT)) &#123;<span class="comment">// kNilPthreadT 是一个静态变量为 0</span></span><br><span class="line">	   t = pthread_main_thread_np();</span><br><span class="line">    &#125;</span><br><span class="line">    __CFLock(&amp;loopsLock);</span><br><span class="line">    <span class="keyword">if</span> (!__CFRunLoops) &#123;</span><br><span class="line">        __CFUnlock(&amp;loopsLock);</span><br><span class="line">	<span class="built_in">CFMutableDictionaryRef</span> dict = <span class="built_in">CFDictionaryCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">	<span class="built_in">CFRunLoopRef</span> mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line">	<span class="built_in">CFDictionarySetValue</span>(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br><span class="line">	<span class="keyword">if</span> (!OSAtomicCompareAndSwapPtrBarrier(<span class="literal">NULL</span>, dict, (<span class="keyword">void</span> * <span class="keyword">volatile</span> *)&amp;__CFRunLoops)) &#123;</span><br><span class="line">	    <span class="built_in">CFRelease</span>(dict);</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="built_in">CFRelease</span>(mainLoop);</span><br><span class="line">        __CFLock(&amp;loopsLock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> loop = (<span class="built_in">CFRunLoopRef</span>)<span class="built_in">CFDictionaryGetValue</span>(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">    __CFUnlock(&amp;loopsLock);</span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">	<span class="built_in">CFRunLoopRef</span> newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        __CFLock(&amp;loopsLock);</span><br><span class="line">	loop = (<span class="built_in">CFRunLoopRef</span>)<span class="built_in">CFDictionaryGetValue</span>(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">	<span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">	    <span class="built_in">CFDictionarySetValue</span>(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">	    loop = newLoop;</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">// don't release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span></span><br><span class="line">        __CFUnlock(&amp;loopsLock);</span><br><span class="line">	<span class="built_in">CFRelease</span>(newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pthread_equal(t, pthread_self())) &#123;</span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (<span class="keyword">void</span> *)loop, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (<span class="keyword">void</span> *)(PTHREAD_DESTRUCTOR_ITERATIONS<span class="number">-1</span>), (<span class="keyword">void</span> (*)(<span class="keyword">void</span> *))__CFFinalizeRunLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里对主要的流程做一下解释:</p>
<ol>
<li>第一次进入，无论 t 为主线程或者子线程。因为 __CFRunLoops 为 null ，所以会创建一个 mainLoop.</li>
<li>根据传递进来的  t ,创建对应的 loop 。t 作为 key,loop 作为 value ,存储到 __CFRunLoops 里。如果已经有了对应 loop 存在，则不创建。</li>
<li>判断 t 是否为当前线程。如果是当前线程，就会利用 CFSetTSD 在  CFTSDKeyRunLoop/CFTSDKeyRunLoopCntr 的位置做设置。</li>
</ol>
<blockquote>
<p>注意:</p>
<p>在了解完  CFSetTSD 的作用， CFTSDKeyRunLoop 设置的意思就很清楚: 在  CFTSDKeyRunLoop 位置，存储 loop , 但不对 loop 设置析构函数。</p>
<p>直接对于 loop 的设置，其实这里已经完成了。</p>
</blockquote>
<p>网络文章大部分，直接就说在 CFTSDKeyRunLoopCntr 设置了清理 loop 的回调。</p>
<p>对于为什么可以释放 loop ，却避而不谈。</p>
<p>大家想过没有 ：</p>
<blockquote>
<p>在  CFTSDKeyRunLoopCntr 位置，给出的参数是 <code>PTHREAD_DESTRUCTOR_ITERATIONS - 1</code><br>PTHREAD_DESTRUCTOR_ITERATIONS 表示的，是线程退出时，操作系统实现试图销毁线程私有数据的最大次数。</p>
<p>试图销毁次数，和 CFFinalizeRunLoop 这个析构函数，是怎么关联起来的？又是怎么被调用的？</p>
</blockquote>
<p>在前面，说过了 CFTSDTable ，实际上在 CFTSDGetTable() 里面，就做了相关 TSD 的设置：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get or initialize a thread local storage. It is created on demand.</span></span><br><span class="line"><span class="keyword">static</span> __CFTSDTable *__CFTSDGetTable() &#123;</span><br><span class="line">   ...</span><br><span class="line">        pthread_key_init_np(<span class="built_in">CF_TSD_KEY</span>, __CFTSDFinalize);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 CF_TSD_KEY ，指定了对应的析构函数 CFTSDFinalize 。</p>
<p>而 CFTSDFinalize 的代码如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFTSDFinalize(<span class="keyword">void</span> *arg) &#123;</span><br><span class="line">   <span class="comment">// Set our TSD so we're called again by pthreads. It will call the destructor PTHREAD_DESTRUCTOR_ITERATIONS times as long as a value is set in the thread specific data. We handle each case below.</span></span><br><span class="line">    __CFTSDSetSpecific(arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!arg || arg == <span class="built_in">CF_TSD_BAD_PTR</span>) &#123;</span><br><span class="line">        <span class="comment">// We've already been destroyed. The call above set the bad pointer again. Now we just return.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// On first calls invoke destructor. Later we destroy the data.</span></span><br><span class="line">    <span class="comment">// Note that invocation of the destructor may cause a value to be set again in the per-thread data slots. The destructor count and destructors are preserved.  </span></span><br><span class="line">    <span class="comment">// This logic is basically the same as what pthreads does. We just skip the 'created' flag.</span></span><br><span class="line">    <span class="keyword">for</span> (int32_t i = <span class="number">0</span>; i &lt; <span class="built_in">CF_TSD_MAX_SLOTS</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table-&gt;data[i] &amp;&amp; table-&gt;destructors[i]) &#123;</span><br><span class="line">            uintptr_t old = table-&gt;data[i];</span><br><span class="line">            table-&gt;data[i] = (uintptr_t)<span class="literal">NULL</span>;</span><br><span class="line">            table-&gt;destructors[i]((<span class="keyword">void</span> *)(old));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (table-&gt;destructorCount == PTHREAD_DESTRUCTOR_ITERATIONS - <span class="number">1</span>) &#123;    <span class="comment">// On PTHREAD_DESTRUCTOR_ITERATIONS-1 call, destroy our data</span></span><br><span class="line">        free(table);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Now if the destructor is called again we will take the shortcut at the beginning of this function.</span></span><br><span class="line">        __CFTSDSetSpecific(<span class="built_in">CF_TSD_BAD_PTR</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，table 会循环遍历 data 和 destructors 的数据，并且把 old 变量作为 destructors 里函数的参数。</p>
<p>这就是线程退出时，会调用到 Run Loop 销毁函数的原因。</p>
<p>同时也由于 table 是从 0 开始遍历，所以会根据枚举值的大小，来决定销毁调用的顺序的。</p>
<p>我们可以在 <a href="https://opensource.apple.com/source/CF/CF-1153.18/CFInternal.h.auto.html" target="_blank" rel="noopener">CFInternal.h</a> 中找到相关枚举定义:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Foundation uses 20-40</span></span><br><span class="line"><span class="comment">// Foundation knows about the value of __CFTSDKeyAutoreleaseData1</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">		__CFTSDKeyAllocator = <span class="number">1</span>,</span><br><span class="line">		__CFTSDKeyIsInCFLog = <span class="number">2</span>,</span><br><span class="line">		__CFTSDKeyIsInNSCache = <span class="number">3</span>,</span><br><span class="line">		__CFTSDKeyIsInGCDMainQ = <span class="number">4</span>,</span><br><span class="line">		__CFTSDKeyICUConverter = <span class="number">7</span>,</span><br><span class="line">		__CFTSDKeyCollatorLocale = <span class="number">8</span>,</span><br><span class="line">		__CFTSDKeyCollatorUCollator = <span class="number">9</span>,</span><br><span class="line">		__CFTSDKeyRunLoop = <span class="number">10</span>,</span><br><span class="line">		__CFTSDKeyRunLoopCntr = <span class="number">11</span>,</span><br><span class="line">   		__CFTSDKeyMachMessageBoost = <span class="number">12</span>, <span class="comment">// valid only in the context of a CFMachPort callout</span></span><br><span class="line">   		__CFTSDKeyMachMessageHasVoucher = <span class="number">13</span>,</span><br><span class="line">		<span class="comment">// autorelease pool stuff must be higher than run loop constants</span></span><br><span class="line">		__CFTSDKeyAutoreleaseData2 = <span class="number">61</span>,</span><br><span class="line">		__CFTSDKeyAutoreleaseData1 = <span class="number">62</span>,</span><br><span class="line">		__CFTSDKeyExceptionData = <span class="number">63</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注释里有一句 <code>autorelease pool stuff must be higher than run loop constants</code> 的说明，这一点就其实关系到 Run Loop 和  autorelease pool 释放的顺序了。</p>
<h4 id="OSAtomicCompareAndSwapPtrBarrier"><a href="#OSAtomicCompareAndSwapPtrBarrier" class="headerlink" title="OSAtomicCompareAndSwapPtrBarrier"></a>OSAtomicCompareAndSwapPtrBarrier</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*! @abstract Compare and swap for &lt;code&gt;int&lt;/code&gt; values.</span></span><br><span class="line"><span class="comment">    @discussion</span></span><br><span class="line"><span class="comment">	This function compares the value in &lt;code&gt;__oldValue&lt;/code&gt; to the value</span></span><br><span class="line"><span class="comment">	in the memory location referenced by &lt;code&gt;__theValue&lt;/code&gt;.  If the values</span></span><br><span class="line"><span class="comment">	match, this function stores the value from &lt;code&gt;__newValue&lt;/code&gt; into</span></span><br><span class="line"><span class="comment">	that memory location atomically.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	This function is equivalent to &#123;@link OSAtomicCompareAndSwap32&#125;.</span></span><br><span class="line"><span class="comment">    @result Returns TRUE on a match, FALSE otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">OSATOMIC_DEPRECATED_REPLACE_WITH(atomic_compare_exchange_strong)</span><br><span class="line">__OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0)</span><br><span class="line"><span class="keyword">bool</span>	OSAtomicCompareAndSwapInt( <span class="keyword">int</span> __oldValue, <span class="keyword">int</span> __newValue, <span class="keyword">volatile</span> <span class="keyword">int</span> *__theValue );</span><br></pre></td></tr></table></figure>
<p>这一个函数，它首先对 oldValue , theValue 进行比较.</p>
<p>如果两个值相等，就执行 theValue = newValue，并返回 YES.</p>
<p>如果两个值不等，返回 NO .</p>
<blockquote>
<p>值得注意的是，这个函数引入了 barrier，它的操作是原子的。<br>这是一个典型的 CAS 操作，无独有偶，在 RAC 中的一个特点也是使用 Atomic Operations ，完成线程同步。</p>
</blockquote>
<p>它在<code>CFRunLoopGet0</code>的作用是 ： 比较 CFRunLoops 是否为 null 。 如果为 null （第一次创建）了,就把 dict 赋值给 CFRunLoops 。如果不为 null,就释放掉 dict 。</p>
<h5 id="memory-barrier"><a href="#memory-barrier" class="headerlink" title="memory barrier"></a>memory barrier</h5><p>这里再稍微提一下 barrier , 上面说它保证了原子操作。</p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C" target="_blank" rel="noopener">memory barrier</a> 在维基的定义是:</p>
<blockquote>
<p>内存屏障（英语：Memory barrier），也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。<br>大多数现代计算机为了提高性能而采取乱序执行，这使得内存屏障成为必须。</p>
</blockquote>
<p>而对于 Objective C 的实现来说，几乎所有的加锁操作最后都会设置 memory barrier ，官方文档的解释:</p>
<blockquote>
<p>Note: Most types of locks also incorporate a memory barrier to ensure that any preceding load and store instructions are completed before entering the critical section.</p>
</blockquote>
<p>为了防止编译器对我们的代码做优化，改变我们代码的指令顺序，可以采用 barrier 设置对我们的代码顺序做保证。</p>
<h3 id="CFRunLoopCreate"><a href="#CFRunLoopCreate" class="headerlink" title="CFRunLoopCreate"></a>CFRunLoopCreate</h3><p>讲完 Run Loop 怎么获取，再看 Run Loop 怎么创建。</p>
<p>对于 CFRunLoopCreate :</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">CFRunLoopRef</span> __CFRunLoopCreate(pthread_t t) &#123;</span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> loop = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> rlm;</span><br><span class="line">    uint32_t size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __CFRunLoop) - <span class="keyword">sizeof</span>(<span class="built_in">CFRuntimeBase</span>);</span><br><span class="line">    loop = (<span class="built_in">CFRunLoopRef</span>)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, <span class="built_in">CFRunLoopGetTypeID</span>(), size, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == loop) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    (<span class="keyword">void</span>)__CFRunLoopPushPerRunData(loop);</span><br><span class="line">    __CFRunLoopLockInit(&amp;loop-&gt;_lock);</span><br><span class="line">    loop-&gt;_wakeUpPort = __CFPortAllocate();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CFPORT_NULL</span> == loop-&gt;_wakeUpPort) HALT;</span><br><span class="line">    __CFRunLoopSetIgnoreWakeUps(loop);</span><br><span class="line">    loop-&gt;_commonModes = <span class="built_in">CFSetCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;kCFTypeSetCallBacks);</span><br><span class="line">    <span class="built_in">CFSetAddValue</span>(loop-&gt;_commonModes, kCFRunLoopDefaultMode);</span><br><span class="line">    loop-&gt;_commonModeItems = <span class="literal">NULL</span>;</span><br><span class="line">    loop-&gt;_currentMode = <span class="literal">NULL</span>;</span><br><span class="line">    loop-&gt;_modes = <span class="built_in">CFSetCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;kCFTypeSetCallBacks);</span><br><span class="line">    loop-&gt;_blocks_head = <span class="literal">NULL</span>;</span><br><span class="line">    loop-&gt;_blocks_tail = <span class="literal">NULL</span>;</span><br><span class="line">    loop-&gt;_counterpart = <span class="literal">NULL</span>;</span><br><span class="line">    loop-&gt;_pthread = t;</span><br><span class="line"><span class="meta">#if DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">    loop-&gt;_winthread = GetCurrentThreadId();</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    loop-&gt;_winthread = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    rlm = __CFRunLoopFindMode(loop, kCFRunLoopDefaultMode, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm) __CFRunLoopModeUnlock(rlm);</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大体说一下创建的流程:</p>
<ol>
<li>通过 CFRuntimeCreateInstance ，创建一个 CFRunLoopRef 实例。</li>
<li>对  loop 做初始化设置，比如唤醒端口，commonModes 等的设置。</li>
</ol>
<blockquote>
<p>注意:<br> CFRunLoopPushPerRunData 会在创建时做一些初始化设置，<br>__CFPortAllocate() 会设置唤醒的端口，<br> CFRunLoopSetIgnoreWakeUps 调用的原因时，目前处于唤醒状态，对它的消息做忽略。<br> HALT 命令可以停止系统运行，假如 wakeUpPort 为 CFPORT_NULL</p>
</blockquote>
<h3 id="CFRuntimeCreateInstance"><a href="#CFRuntimeCreateInstance" class="headerlink" title="CFRuntimeCreateInstance"></a>CFRuntimeCreateInstance</h3><p>真正创建得到 CFRunLoopRef 类型的 loop ，调用的是 <code>CFRuntimeCreateInstance</code> 来创建的。</p>
<p>它是一个用来创建 CF 实例类型的函数:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CF_EXPORT</span> <span class="built_in">CFTypeRef</span> _CFRuntimeCreateInstance(<span class="built_in">CFAllocatorRef</span> allocator, <span class="built_in">CFTypeID</span> typeID, <span class="built_in">CFIndex</span> extraBytes, <span class="keyword">unsigned</span> <span class="keyword">char</span> *category);</span><br></pre></td></tr></table></figure>
<p>更具体的解释可以查看 <a href="https://opensource.apple.com/source/CF/CF-1153.18/CFRuntime.h.auto.html" target="_blank" rel="noopener">CFRuntime.h</a> 对它的定义。</p>
<p>CFRunLoopCreate 给它传入了一个默认的分配器 kCFAllocatorSystemDefault ，一个 CFRunLoopGetTypeID() ,一个 size 。</p>
<p>CFRunLoopGetTypeID() 的操作如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CFTypeID CFRunLoopGetTypeID(void) &#123;</span><br><span class="line">    static dispatch_once_t initOnce;</span><br><span class="line">    dispatch_once(&amp;initOnce, ^&#123; </span><br><span class="line">    __kCFRunLoopTypeID = _CFRuntimeRegisterClass(&amp;__CFRunLoopClass); </span><br><span class="line">    __kCFRunLoopModeTypeID = _CFRuntimeRegisterClass(&amp;__CFRunLoopModeClass); </span><br><span class="line">    &#125;);</span><br><span class="line">    return __kCFRunLoopTypeID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它在里面注册了 CFRunLoopClass 和 CFRunLoopModeClass 的类型，并用返回值，给对应的 typeID 赋值。作为单例，只运行一次。 </p>
<p>size 的计算为 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint32_t size = sizeof(struct __CFRunLoop) - sizeof(CFRuntimeBase);</span><br></pre></td></tr></table></figure>
<p>size 是一个 CFRunLoop 类型本身的大小，减掉 CFRuntimeBase 类型的大小得到的结果。</p>
<p>为什么要减去一个  CFRuntimeBase 的类型大小？</p>
<p>查看 <a href="https://opensource.apple.com/source/CF/CF-1153.18/CFRuntime.c.auto.html" target="_blank" rel="noopener">CFRuntime.c</a> 对源码，发现里面会把减掉的 sizeof(CFRuntimeBase) 再给加回来:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFIndex size = sizeof(CFRuntimeBase) + extraBytes + (usesSystemDefaultAllocator ? 0 : sizeof(CFAllocatorRef));</span><br></pre></td></tr></table></figure>
<h3 id="CFRunLoopFindMode"><a href="#CFRunLoopFindMode" class="headerlink" title="CFRunLoopFindMode"></a>CFRunLoopFindMode</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">CFRunLoopModeRef</span> __CFRunLoopFindMode(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> modeName, Boolean create)</span><br></pre></td></tr></table></figure>
<p>CFRunLoopFindMode 是一个用来查找 mode 的函数，同时也可以来创建 mode 。</p>
<p>它其中有利用两个宏，来对 timer 的种类进行判断.查阅了一下定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if DEPLOYMENT_TARGET_MACOSX</span><br><span class="line">#define USE_DISPATCH_SOURCE_FOR_TIMERS 1</span><br><span class="line">#define USE_MK_TIMER_TOO 1</span><br><span class="line">#else</span><br><span class="line">#define USE_DISPATCH_SOURCE_FOR_TIMERS 0</span><br><span class="line">#define USE_MK_TIMER_TOO 1</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>也就是说，在 MACOSX 下，同时还会有使用 dispatch timer 来做定时器。而 MK_TIMER 是两个平台下都有的。</p>
<p>函数的大体逻辑是先判断有无，有就返回. 没有的话，就根据 create 的值决定是否新创建一个 mode .</p>
<p>在 CFRunLoopCreate 里面，调用的代码是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopFindMode(loop, kCFRunLoopDefaultMode, true)</span><br></pre></td></tr></table></figure>
<p>它会新创建一个 mode 返回。</p>
<h2 id="运行-Run-Loop"><a href="#运行-Run-Loop" class="headerlink" title="运行 Run Loop"></a>运行 Run Loop</h2><p>启动 Run Loop 有 2 个函数,一个是 <code>CFRunLoopRun</code> , 一个是 <code>CFRunLoopRunInMode</code> ：</p>
<ul>
<li>DefaultMode 启动</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CFRunLoopRun</span>(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：1.0e10，这个表示1.0乘以10的10次方，这个参数主要是规定RunLoop的时间，传这个时间，表示线程常驻。</p>
<p>主线程的RunLoop调用函数，就是使用了  CFRunLoopRun</p>
<ul>
<li>指定 Mode 启动，允许设置RunLoop超时时间</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">CFRunLoopRunInMode</span>(<span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看上面两个启动 Run Loop 运行的函数实现，发现都使用了 <code>CFRunLoopRunSpecific</code> .</p>
<h3 id="CFRunLoopRunSpecific"><a href="#CFRunLoopRunSpecific" class="headerlink" title="CFRunLoopRunSpecific"></a>CFRunLoopRunSpecific</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;     /* DOES CALLOUT */</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false);</span><br><span class="line">    if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;</span><br><span class="line">	   Boolean did = false;</span><br><span class="line">	   if (currentMode) __CFRunLoopModeUnlock(currentMode);</span><br><span class="line">	   __CFRunLoopUnlock(rl);</span><br><span class="line">	   return did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;</span><br><span class="line">    &#125;</span><br><span class="line">    volatile _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);</span><br><span class="line">    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;</span><br><span class="line">    rl-&gt;_currentMode = currentMode;</span><br><span class="line">    int32_t result = kCFRunLoopRunFinished;</span><br><span class="line"></span><br><span class="line">	if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">	result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">	if (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line"></span><br><span class="line">    __CFRunLoopModeUnlock(currentMode);</span><br><span class="line">    __CFRunLoopPopPerRunData(rl, previousPerRun);</span><br><span class="line">	rl-&gt;_currentMode = previousMode;</span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.通过 runloop 的 modeName 查找当前 mode。因为 CFRunLoopFindMode 的 create 参数为 false , 如果没找到，直接为 null ，不会创建新的 mode.<br>2.如果当前 mode 为空，函数结束，返回 CFRunLoopRunFinished .</p>
<blockquote>
<p>这里比较奇怪的是 <code>Boolean did = false</code> 直接写死了 did 的值，后面又是 <code>return did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished</code> . 怀疑 did 的值，应该还有一段代码是决定<code>kCFRunLoopRunHandledSource</code>的结果，被苹果隐藏了没有开源出来。</p>
</blockquote>
<p>3.如果当前 mode 存在，做一些赋值操作 .<br>4.向观察者发送 kCFRunLoopEntry 的消息，即将进入 RunLoop .<br>5.进入 CFRunLoopRun 函数，在这里做一系列观察和操作。<br>6.向观察者发送 kCFRunLoopExit 的消息,即将退出 RunLoop .</p>
<p>关于  CFRunLoopRun 在运行的时候，有 4 个枚举值表示它的状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* Reasons for CFRunLoopRunInMode() to Return */</span><br><span class="line">enum &#123;</span><br><span class="line">    kCFRunLoopRunFinished = 1,//结束</span><br><span class="line">    kCFRunLoopRunStopped = 2,//暂停</span><br><span class="line">    kCFRunLoopRunTimedOut = 3,//超时</span><br><span class="line">    kCFRunLoopRunHandledSource = 4 //执行事件</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="CFRunLoopDoObservers"><a href="#CFRunLoopDoObservers" class="headerlink" title="CFRunLoopDoObservers"></a>CFRunLoopDoObservers</h4><p>CFRunLoopDoObservers 的官方文档说明如下:</p>
<blockquote>
<p>A CFRunLoopObserver provides a general means to receive callbacks at different points within a running run loop. In contrast to sources, which fire when an asynchronous event occurs, and timers, which fire when a particular time passes, observers fire at special locations within the execution of the run loop, such as before sources are processed or before the run loop goes to sleep, waiting for an event to occur. Observers can be either one-time events or repeated every time through the run loop’s loop.</p>
</blockquote>
<blockquote>
<p>Each run loop observer can be registered in only one run loop at a time, although it can be added to multiple run loop modes within that run loop.</p>
</blockquote>
<p>一个 CFRunLoopObserver 提供了一个通用的方法，在不同的时机去接受运行中的 runloop 的回调。与在一个异步事件发生时触发的源，和在特定时间之后触发的定时器相比，在 run loop 执行的过程中， 观察者会在特定的位置发送信号，例如 sources 执行之前活着  run loop 将要休眠之前，等待事件的发生. 观察者可以是一次性的，或者在通过每次 run loop 的循环里重复。</p>
<p>每个 run loop 观察者只能在 run loop 中注册一次，尽管它可以添加到该 run loop 内的多个 run loop mode 中。</p>
<h3 id="CFRunLoopRun"><a href="#CFRunLoopRun" class="headerlink" title="CFRunLoopRun"></a>CFRunLoopRun</h3><p>这里其实有两个 CFRunLoopRun 函数，一个是暴露给我们在外面使用的，不带参数的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CF_EXPORT void CFRunLoopRun(void);</span><br></pre></td></tr></table></figure>
<p>现在要说的，是这一个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) __attribute__((noinline))；</span><br></pre></td></tr></table></figure>
<p>因为函数比较长，所以分段来进行讲解.</p>
<p>1.runloop 状态判断 / GCD 队列的端口设置:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取开始时间</span></span><br><span class="line">uint64_t startTSR = mach_absolute_time();</span><br><span class="line"></span><br><span class="line"><span class="comment">//对 runloop 状态做判断，检查是否处于 stop 的情况</span></span><br><span class="line"><span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">       __CFRunLoopUnsetStopped(rl);</span><br><span class="line">    <span class="keyword">return</span> kCFRunLoopRunStopped;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">    rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> kCFRunLoopRunStopped;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明 dispatchPort 变量，作为一个 mach_port 通信的端口，初始化值为 MACH_PORT_NULL</span></span><br><span class="line">mach_port_name_t dispatchPort = MACH_PORT_NULL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测是否在主线程 &amp;&amp; ( (是队列发的消息&amp;&amp;mode为null)||(不是队列发的消息&amp;&amp;不在主队列))</span></span><br><span class="line">Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; <span class="literal">NULL</span> == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; <span class="number">0</span> == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是队列安全的，并且是主线程runloop,设置它对应的通信端口</span></span><br><span class="line"><span class="keyword">if</span> (libdispatchQSafe &amp;&amp; (<span class="built_in">CFRunLoopGetMain</span>() == rl) &amp;&amp; <span class="built_in">CFSetContainsValue</span>(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();</span><br></pre></td></tr></table></figure>
<ul>
<li>HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY 0</span><br></pre></td></tr></table></figure>
<p>这里对于它的定义是 0 ，写死了。我猜测应该还是有一个函数去做判断的。 </p>
<p>目前只能从字面意思猜测，代表是否只分发 dispatch 消息的</p>
<ul>
<li>_dispatch_get_main_queue_port_4CF</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define _dispatch_get_main_queue_port_4CF _dispatch_get_main_queue_handle_4CF</span><br></pre></td></tr></table></figure>
<p>它是 dispatch_get_main_queue_handle_4CF 的宏，存在 libdispatch 中，里面对它的实现为:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_runloop_handle_t</span><br><span class="line">_dispatch_get_main_queue_handle_4CF(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">dispatch_queue_t</span> dq = &amp;_dispatch_main_q;</span><br><span class="line">	dispatch_once_f(&amp;_dispatch_main_q_handle_pred, dq,</span><br><span class="line">			_dispatch_runloop_queue_handle_init);</span><br><span class="line">	<span class="keyword">return</span> _dispatch_runloop_queue_get_handle(dq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回的是主线程 runloop 所关联的的端口。</p>
<p>2.MACOSX 下，声明一个 mode 的队列通信端口（在 MACOSX 环境中）:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">    mach_port_name_t modeQueuePort = MACH_PORT_NULL;</span><br><span class="line">    <span class="keyword">if</span> (rlm-&gt;_queue) &#123;</span><br><span class="line">        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</span><br><span class="line">        <span class="keyword">if</span> (!modeQueuePort) &#123;</span><br><span class="line">            CRASH(<span class="string">"Unable to get port for run loop mode queue (%d)"</span>, <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure>
<p>3.根据超时 seconds 的时长，做对应操作。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   dispatch_source_t timeout_timer = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">struct</span> __timeout_context *timeout_context = (<span class="keyword">struct</span> __timeout_context *)malloc(<span class="keyword">sizeof</span>(*timeout_context));</span><br><span class="line">   <span class="comment">//小于等于 0 ,片刻的超时(instant timeout),直接设置为 0 ，不超时</span></span><br><span class="line">   <span class="keyword">if</span> (seconds &lt;= <span class="number">0.0</span>) &#123; </span><br><span class="line">       seconds = <span class="number">0.0</span>;</span><br><span class="line">       timeout_context-&gt;termTSR = <span class="number">0</span>ULL;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;<span class="comment">//在限制的超时间隔内</span></span><br><span class="line">   <span class="comment">//根据是否为主线程，设置队列是主队列还是后台队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = pthread_main_np() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground();</span><br><span class="line"><span class="comment">//创建一个 GCD Timer</span></span><br><span class="line">timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">   dispatch_retain(timeout_timer);</span><br><span class="line">timeout_context-&gt;ds = timeout_timer;</span><br><span class="line">timeout_context-&gt;rl = (<span class="built_in">CFRunLoopRef</span>)<span class="built_in">CFRetain</span>(rl);</span><br><span class="line">timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</span><br><span class="line"><span class="comment">//把 timer 和 context 给关联起来</span></span><br><span class="line">dispatch_set_context(timeout_timer, timeout_context); </span><br><span class="line">dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</span><br><span class="line">  dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</span><br><span class="line">  uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * <span class="number">1000000000</span>ULL);</span><br><span class="line">  dispatch_source_set_timer(timeout_timer, dispatch_time(<span class="number">1</span>, ns_at), DISPATCH_TIME_FOREVER, <span class="number">1000</span>ULL);</span><br><span class="line">  <span class="comment">//恢复唤起 timer 执行</span></span><br><span class="line">  dispatch_resume(timeout_timer);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">   	 <span class="comment">//无限期超时</span></span><br><span class="line">       seconds = <span class="number">9999999999.0</span>;</span><br><span class="line">       timeout_context-&gt;termTSR = <span class="built_in">UINT64_MAX</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>4.进入 do - while 循环，直到 reVal 不为 0 。以下代码为更好理解，删去 windows 相关:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line">    // 设置判断是否为最后一次 dispatch 的端口通信的变量</span><br><span class="line">    Boolean didDispatchPortLastTime = true;</span><br><span class="line">    // 设置一个结果变量，最后为几个 CFRunLoopRunInMode 里返回状态之一。</span><br><span class="line">    int32_t retVal = 0;</span><br><span class="line">    do &#123;</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">        // 一个状态变量，用于 消息状态 标志，初始值为 UNCHAMGED</span><br><span class="line">        voucher_mach_msg_state_t voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED;</span><br><span class="line">        voucher_t voucherCopy = NULL;</span><br><span class="line">#endif</span><br><span class="line">		 //声明一个 msg_buffer 数组</span><br><span class="line">        uint8_t msg_buffer[3 * 1024];</span><br><span class="line">        </span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">		 //声明和 mach port 有关的 port 和 msg 变量</span><br><span class="line">        mach_msg_header_t *msg = NULL;</span><br><span class="line">        mach_port_t livePort = MACH_PORT_NULL;</span><br><span class="line"></span><br><span class="line">		 // 声明一个类型为 CFPortSet 的 waitSet, 值为 run loop mode 里的 portSet.</span><br><span class="line">		 __CFPortSet waitSet = rlm-&gt;_portSet;</span><br><span class="line"></span><br><span class="line"> 		//将 run loop 从忽略唤醒消息的状态 unset ,开始接受唤醒消息</span><br><span class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</span><br><span class="line">        </span><br><span class="line">		 // 2. 通知 observers , Run Loop 即将触发 Timer 回调。</span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        // 3. 通知 observers , Run Loop 即将触发 Source0 (非 mach port) 回调。</span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">		 // 执行 block</span><br><span class="line">	     __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">		//  4. 执行 Source0 (非 mach port) 。</span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        if (sourceHandledThisLoop) &#123;// 执行完 source0 后，假如还有需要执行的，再执行一次 block</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// poll 变量，是否处理 source 或未超时</span><br><span class="line">        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);</span><br><span class="line">        </span><br><span class="line">	</span><br><span class="line">        if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">            msg = (mach_msg_header_t *)msg_buffer;</span><br><span class="line">            </span><br><span class="line">            // 5. 如果有 Source1 (基于port) 处于 ready 状态</span><br><span class="line">            //    直接处理这个 Source1 然后跳转去处理消息(handle_msg)。</span><br><span class="line">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</span><br><span class="line">                goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    didDispatchPortLastTime = false;</span><br><span class="line">    </span><br><span class="line">	// 6.通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span><br><span class="line">	// 注意到如果实际处理了 source0 或者超时，不会进入睡眠，所以不会通知</span><br><span class="line">	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">	</span><br><span class="line">	// 设置标志位， Run Loop 休眠</span><br><span class="line">	__CFRunLoopSetSleeping(rl);</span><br><span class="line"></span><br><span class="line">   // 使用 GCD 的话，将 GCD 端口加入监听端口集合中</span><br><span class="line">   __CFPortSetInsert(dispatchPort, waitSet);</span><br><span class="line">        </span><br><span class="line">	__CFRunLoopModeUnlock(rlm);</span><br><span class="line">	__CFRunLoopUnlock(rl);</span><br><span class="line">	// 休眠开始的时间，根据 poll 状态决定为 0 或者当前的绝对时间</span><br><span class="line">   CFAbsoluteTime sleepStart = poll ? 0.0 : CFAbsoluteTimeGetCurrent();</span><br><span class="line"></span><br><span class="line">// 7. 通过 CFRunLoopServiceMachPort 调用 mach_msg 休眠,等待被 mach_msg 消息唤醒</span><br><span class="line"></span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">// 如果在 MACOSX 中</span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">		// 处理 GCD timer </span><br><span class="line">        do &#123;</span><br><span class="line">            if (kCFUseCollectableAllocator) &#123;//假如有kCFUseCollectableAllocator分配器，使用 memset 清空msg_buffer</span><br><span class="line">                // objc_clear_stack(0);</span><br><span class="line">                // &lt;rdar://problem/16393959&gt;</span><br><span class="line">                memset(msg_buffer, 0, sizeof(msg_buffer));</span><br><span class="line">            &#125;</span><br><span class="line">            msg = (mach_msg_header_t *)msg_buffer;</span><br><span class="line">            </span><br><span class="line">            // 设置 mach port 通信，会睡眠线程</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">            </span><br><span class="line">            // modeQueue 存在，而且为 livePort</span><br><span class="line">            if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class="line">                // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</span><br><span class="line">                //执行 run loop mode 里的队列，直到队列都执行完成</span><br><span class="line">                while (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</span><br><span class="line">                </span><br><span class="line">                if (rlm-&gt;_timerFired) &#123;//假如 _timerFired 为真，把 livePort 作为队列端口，在之前服务于 timers</span><br><span class="line">                    rlm-&gt;_timerFired = false;</span><br><span class="line">                    //退出</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;// _timerFired 为假, 并且 msg 存在不为 msg_buffer, 释放 msg</span><br><span class="line">                    if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //退出</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (1);</span><br><span class="line">        </span><br><span class="line">#else // 不在 MACOSX 中</span><br><span class="line">        if (kCFUseCollectableAllocator) &#123;//如果 kCFUseCollectableAllocator 分配器，使用 memset 清空 msg_buffer</span><br><span class="line">            // objc_clear_stack(0);</span><br><span class="line">            // &lt;rdar://problem/16393959&gt;</span><br><span class="line">            memset(msg_buffer, 0, sizeof(msg_buffer));</span><br><span class="line">        &#125;</span><br><span class="line">        msg = (mach_msg_header_t *)msg_buffer;</span><br><span class="line">        //CFRunLoopServiceMachPort 会让线程休眠</span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">#endif</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        //上锁</span><br><span class="line">        __CFRunLoopLock(rl);</span><br><span class="line">        __CFRunLoopModeLock(rlm);</span><br><span class="line">        </span><br><span class="line">		// 根据 poll 的值，记录休眠时间</span><br><span class="line">        rl-&gt;_sleepTime += (poll ? 0.0 : (CFAbsoluteTimeGetCurrent() - sleepStart));</span><br><span class="line"></span><br><span class="line">		//对 waitSet 里的 dispatchPort 端口做移除</span><br><span class="line">        __CFPortSetRemove(dispatchPort, waitSet);</span><br><span class="line">        </span><br><span class="line">        //让 Run Loop 忽略唤醒消息，因为已经重新在运行了</span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line"></span><br><span class="line">        // user callouts now OK again</span><br><span class="line">		__CFRunLoopUnsetSleeping(rl);</span><br><span class="line">		</span><br><span class="line">	     // 8. 通知 observers: kCFRunLoopAfterWaiting, 线程刚被唤醒</span><br><span class="line">        // 注意实际处理过 source 0 或者已经超时的话，不会通知（因为没有睡）</span><br><span class="line">		if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">		</span><br><span class="line">		//处理对应唤醒的消息</span><br><span class="line">        handle_msg:;</span><br><span class="line">        </span><br><span class="line">        //将 Run Loop 重新忽略唤醒消息，因为已经重新在运行了</span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if (MACH_PORT_NULL == livePort) &#123;// livePort 为空，什么事都不做</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</span><br><span class="line">            // handle nothing</span><br><span class="line">        &#125; else if (livePort == rl-&gt;_wakeUpPort) &#123;// livePort 等于 run loop 的 _wakeUpPort</span><br><span class="line">            // 被 CFRunLoopWakeUp 函数唤醒的</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">// 在 MACOSX 里</span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;//livePort 等于 modeQueuePort</span><br><span class="line">        	 //9.1-1 被 timers 唤醒，处理 timers</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                // Re-arm the next timer, because we apparently fired early</span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if USE_MK_TIMER_TOO </span><br><span class="line">        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;//livePort 等于 run loop mode 的 _timerPort</span><br><span class="line">        	 // 9.1-2 被 timers 唤醒，处理 timers</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            // On Windows, we have observed an issue where the timer port is set before the time which we requested it to be set. For example, we set the fire time to be TSR 167646765860, but it is actually observed firing at TSR 167646764145, which is 1715 ticks early. The result is that, when __CFRunLoopDoTimers checks to see if any of the run loop timers should be firing, it appears to be &apos;too early&apos; for the next timer, and no timers are handled.</span><br><span class="line">            // In this case, the timer port has been automatically reset (since it was returned from MsgWaitForMultipleObjectsEx), and if we do not re-arm it, then no timers will ever be serviced again unless something adjusts the timer list (e.g. adding or removing timers). The fix for the issue is to reset the timer here if CFRunLoopDoTimers did not handle a timer itself. 9308754</span><br><span class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                // Re-arm the next timer</span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">        else if (livePort == dispatchPort) &#123;// livePort 等于 dispatchPort</span><br><span class="line">        	 // 9.2 如果有dispatch到main_queue的block，执行block</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</span><br><span class="line">            </span><br><span class="line">            //解锁</span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">            __CFRunLoopUnlock(rl);</span><br><span class="line">            </span><br><span class="line">            //设置 CFTSDKeyIsInGCDMainQ 位置的 TSD 为 6 .</span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);</span><br><span class="line">			</span><br><span class="line">			// 处理 msg</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            </span><br><span class="line">            //设置 CFTSDKeyIsInGCDMainQ 位置的 TSD 为 0.</span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);</span><br><span class="line">            </span><br><span class="line">            //上锁</span><br><span class="line">            __CFRunLoopLock(rl);</span><br><span class="line">            __CFRunLoopModeLock(rlm);</span><br><span class="line">            </span><br><span class="line">            //设置变量</span><br><span class="line">            sourceHandledThisLoop = true;</span><br><span class="line">            didDispatchPortLastTime = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //9.3 被 source (基于 mach port) 唤醒</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</span><br><span class="line">            </span><br><span class="line">            // 假如我们 从这个 mach_msg 中接收到一个 voucher，然后在 TSD 中放置一个复制的新的 voucher.</span><br><span class="line">            // CFMachPortBoost 会在 TSD 中去查找这个 voucher. </span><br><span class="line">            // 通过使用 TSD 中的值，我们将 CFMachPortBoost 绑定到这个接收到的 mach_msg 中，在这两段代码之间没有任何机会再次设置凭证</span><br><span class="line">            voucher_t previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (void *)voucherCopy, os_release);</span><br><span class="line"></span><br><span class="line">            // Despite the name, this works for windows handles as well</span><br><span class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">            </span><br><span class="line">            if (rls) &#123;//如果 rls 存在</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">				mach_msg_header_t *reply = NULL;</span><br><span class="line">				//处理 Source ,并返回执行结果</span><br><span class="line">				sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">				if (NULL != reply) &#123;//发送reply消息(假如 reply 不为空)</span><br><span class="line">		    		(void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</span><br><span class="line">		    		//释放 reply 变量</span><br><span class="line">		    		CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">	    	&#125;</span><br><span class="line">            </span><br><span class="line">            // Restore the previous voucher</span><br><span class="line">            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);</span><br><span class="line">            </span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">        if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">   // 执行加入到Loop的block</span><br><span class="line">	__CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">	//根据一次循环后的状态，给 retVal 赋值 。状态不变则继续循环</span><br><span class="line">	if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">	    retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">	    </span><br><span class="line">   &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">        retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">        </span><br><span class="line">	&#125; else if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">        __CFRunLoopUnsetStopped(rl);</span><br><span class="line">	    retVal = kCFRunLoopRunStopped;</span><br><span class="line">	    </span><br><span class="line">	&#125; else if (rlm-&gt;_stopped) &#123;</span><br><span class="line">	    rlm-&gt;_stopped = false;</span><br><span class="line">	    retVal = kCFRunLoopRunStopped;</span><br><span class="line">	&#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">	    retVal = kCFRunLoopRunFinished;</span><br><span class="line">	&#125;</span><br><span class="line">        </span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">		// 循环一次后收尾处理</span><br><span class="line">        voucher_mach_msg_revert(voucherState);</span><br><span class="line">        os_release(voucherCopy);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    &#125; while (0 == retVal);</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">上面的代码，有几个地方的定义可能需要结合其它地方才能理解:</span><br><span class="line"></span><br><span class="line">- voucher_mach_msg_state_t 在 [mach.h](https://opensource.apple.com/source/xnu/xnu-2782.30.5/libsyscall/mach/mach/mach.h) 中：</span><br><span class="line"></span><br><span class="line"> ```objc</span><br><span class="line"> /*!</span><br><span class="line"> * @typedef voucher_mach_msg_state_t</span><br><span class="line"> *</span><br><span class="line"> * @abstract</span><br><span class="line"> * Opaque object encapsulating state changed by voucher_mach_msg_adopt().</span><br><span class="line"> */</span><br><span class="line">typedef struct voucher_mach_msg_state_s *voucher_mach_msg_state_t;</span><br></pre></td></tr></table></figure>
<p>不透明的对象封装状态由 voucher_mach_msg_adopt() 改变,它代表一种 mach_msg 通信时的状态。</p>
<ul>
<li>HANDLE:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_EXPORT HANDLE _dispatch_get_main_queue_handle_4CF(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<p>返回作为主队列相关联的 run loop 。</p>
<ul>
<li>memset ：作用是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法。</li>
</ul>
<p>5.释放 timerout_timer 定时器相关</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (timeout_timer) &#123;<span class="comment">//如果存在，取消并释放</span></span><br><span class="line">    dispatch_source_cancel(timeout_timer);</span><br><span class="line">    dispatch_release(timeout_timer);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//不存在，将对应的 timeour_context 释放</span></span><br><span class="line">    free(timeout_context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结束返回 retVal 状态。</span></span><br><span class="line"><span class="keyword">return</span> retVal;</span><br></pre></td></tr></table></figure>
<h3 id="CFRunLoopServiceMachPort"><a href="#CFRunLoopServiceMachPort" class="headerlink" title="CFRunLoopServiceMachPort"></a>CFRunLoopServiceMachPort</h3><p>这个函数是让线程休眠的关键，它在里面做了和 mach port 相关的操作。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Boolean __CFRunLoopServiceMachPort(mach_port_name_t port, mach_msg_header_t **buffer, size_t buffer_size, mach_port_t *livePort, mach_msg_timeout_t timeout, voucher_mach_msg_state_t *voucherState, voucher_t *voucherCopy) &#123;</span><br><span class="line">    Boolean originalBuffer = <span class="literal">true</span>;</span><br><span class="line">    kern_return_t ret = KERN_SUCCESS;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;		<span class="comment">/* In that sleep of death what nightmares may come ... */</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// msg 相关数据设置</span></span><br><span class="line">        mach_msg_header_t *msg = (mach_msg_header_t *)*buffer;</span><br><span class="line">        msg-&gt;msgh_bits = <span class="number">0</span>;</span><br><span class="line">        msg-&gt;msgh_local_port = port;</span><br><span class="line">        msg-&gt;msgh_remote_port = MACH_PORT_NULL;</span><br><span class="line">        msg-&gt;msgh_size = buffer_size;</span><br><span class="line">        msg-&gt;msgh_id = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据 timeout 的值，决定 Run Loop 是休眠还是执行</span></span><br><span class="line">        <span class="comment">// timeout  为 TIMEOUT_INFINITY 时，才执行 CFRUNLOOP_SLEEP() 休眠</span></span><br><span class="line">        <span class="keyword">if</span> (TIMEOUT_INFINITY == timeout) &#123; <span class="built_in">CFRUNLOOP_SLEEP</span>(); &#125; <span class="keyword">else</span> &#123; <span class="built_in">CFRUNLOOP_POLL</span>(); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发送并接收 mach port 消息</span></span><br><span class="line">        ret = mach_msg(msg, MACH_RCV_MSG|(voucherState ? MACH_RCV_VOUCHER : <span class="number">0</span>)|MACH_RCV_LARGE|((TIMEOUT_INFINITY != timeout) ? MACH_RCV_TIMEOUT : <span class="number">0</span>)|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_AV), <span class="number">0</span>, msg-&gt;msgh_size, port, timeout, MACH_PORT_NULL);</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 在 mach_msg 之后注意所有 voucher 相关的正常运行</span></span><br><span class="line">        <span class="comment">// 假如我们没有释放前面的 voucher , 将会出现内存泄漏</span></span><br><span class="line">        voucher_mach_msg_revert(*voucherState);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 会有调用者去负责调用 voucher_mach_msg_revert .它会让接收到的 voucher 变成当前的这一个值。</span></span><br><span class="line">        *voucherState = voucher_mach_msg_adopt(msg);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (voucherCopy) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*voucherState != VOUCHER_MACH_MSG_STATE_UNCHANGED) &#123;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 调用者 在这里 请求了一个 voucher 的复制的值。通过在 mach_msg 前后做这个操作，我们确保在 mach_msg 返回和使用 voucher 的复制值的时候，没有涉及设置 voucher 的值。</span></span><br><span class="line">                <span class="comment">// 为确保  CFMachPortBoost 使用的  voucher ，所以我们只在 voucher 不是  state_unchanged 的时候，去设置 TSD 。</span></span><br><span class="line">                *voucherCopy = voucher_copy();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">//值为 VOUCHER_MACH_MSG_STATE_UNCHANGED ，置为 null</span></span><br><span class="line">                *voucherCopy = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 唤醒 Run Loop</span></span><br><span class="line">        <span class="built_in">CFRUNLOOP_WAKEUP</span>(ret);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (MACH_MSG_SUCCESS == ret) &#123;<span class="comment">// ret 成功后，设置 livePort 的值，返回 true</span></span><br><span class="line">            *livePort = msg ? msg-&gt;msgh_local_port : MACH_PORT_NULL;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (MACH_RCV_TIMED_OUT == ret) &#123;<span class="comment">// ret 超时，释放 msg ，有关变量置空,返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (!originalBuffer) free(msg);</span><br><span class="line">            *buffer = <span class="literal">NULL</span>;</span><br><span class="line">            *livePort = MACH_PORT_NULL;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//ret 不为 MACH_RCV_TOO_LARGE ，退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (MACH_RCV_TOO_LARGE != ret) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//ret 为 MACH_RCV_TOO_LARGE，做释放操作，重新进入循环</span></span><br><span class="line">        buffer_size = round_msg(msg-&gt;msgh_size + MAX_TRAILER_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (originalBuffer) *buffer = <span class="literal">NULL</span>;</span><br><span class="line">        originalBuffer = <span class="literal">false</span>;</span><br><span class="line">        *buffer = realloc(*buffer, buffer_size);</span><br><span class="line">    &#125;</span><br><span class="line">    HALT;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有查询 CFRUNLOOP_SLEEP() 和 CFRUNLOOP_POLL() 等函数，都是 <code>do { } while (0)</code> 这样的宏，没有真正实现代码，所以无法再看到具体的情况。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一次学习的过程，最大的感触，就是对于知识的相通性。</p>
<p>例如对于 TSD 线程私有数据的理解，搜寻很多跟 iOS 有关资料都找不到说明，最后是在 unix 相关的文章才看到解释。还有 Event Loop 的机制在其它平台等实现。</p>
<p>比较遗憾的是，有一些地方，苹果并没有给出具体的代码实现或者明确的解释。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://godbasin.github.io/2017/09/29/data-driven-or-event-driven/#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">前端思维转变–从事件驱动到数据驱动</a></p>
<p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23" target="_blank" rel="noopener">苹果文档–RunLoop</a></p>
<p><a href="https://opensource.apple.com/source/CF/CF-1153.18/CFRunLoop.c.auto.html" target="_blank" rel="noopener">CFRunLoop.c 源码</a></p>
<p><a href="https://opensource.apple.com/source/xnu/xnu-2050.48.11/bsd/kern/kern_fork.c" target="_blank" rel="noopener">XNU 源码</a></p>
<p><a href="http://zdyi.com/books/apue/s11/11.9.html" target="_blank" rel="noopener">线程私有数据</a></p>
<p><a href="https://blog.csdn.net/armlinuxww/article/details/9663323" target="_blank" rel="noopener">UNIX环境高级编程——线程私有数据</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/08/technology/2018-03-01-LockForiOS/" rel="next" title="谈 iOS 的锁">
                <i class="fa fa-chevron-left"></i> 谈 iOS 的锁
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/09/18/life/2018-09-18-LifeRecord/" rel="prev" title="个人职业上的思考">
                个人职业上的思考 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=2112728" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/author.jpg"
                alt="ZenonHuang" />
            
              <p class="site-author-name" itemprop="name">ZenonHuang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Event-Loop"><span class="nav-number">2.</span> <span class="nav-text">Event Loop</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Event-Driven"><span class="nav-number">3.</span> <span class="nav-text">Event Driven</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Event"><span class="nav-number">3.1.</span> <span class="nav-text">Event</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Event-Handler"><span class="nav-number">3.2.</span> <span class="nav-text">Event Handler</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Event-Loop-解决了什么问题"><span class="nav-number">3.3.</span> <span class="nav-text">Event Loop 解决了什么问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Run-Loop-实现"><span class="nav-number">4.</span> <span class="nav-text">Run Loop 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#获取-Run-Loop"><span class="nav-number">4.1.</span> <span class="nav-text">获取 Run Loop</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CHECK-FOR-FORK"><span class="nav-number">4.1.1.</span> <span class="nav-text">CHECK_FOR_FORK()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FORK"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">FORK</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread-specific-data"><span class="nav-number">4.1.2.</span> <span class="nav-text">Thread-specific data</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CFGetTSD-CFSetTSD"><span class="nav-number">4.1.3.</span> <span class="nav-text">CFGetTSD / CFSetTSD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CFTSDTable"><span class="nav-number">4.1.4.</span> <span class="nav-text">CFTSDTable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CFRunLoopGet0"><span class="nav-number">4.1.5.</span> <span class="nav-text">CFRunLoopGet0</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OSAtomicCompareAndSwapPtrBarrier"><span class="nav-number">4.1.5.1.</span> <span class="nav-text">OSAtomicCompareAndSwapPtrBarrier</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#memory-barrier"><span class="nav-number">4.1.5.1.1.</span> <span class="nav-text">memory barrier</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CFRunLoopCreate"><span class="nav-number">4.1.6.</span> <span class="nav-text">CFRunLoopCreate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CFRuntimeCreateInstance"><span class="nav-number">4.1.7.</span> <span class="nav-text">CFRuntimeCreateInstance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CFRunLoopFindMode"><span class="nav-number">4.1.8.</span> <span class="nav-text">CFRunLoopFindMode</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行-Run-Loop"><span class="nav-number">4.2.</span> <span class="nav-text">运行 Run Loop</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CFRunLoopRunSpecific"><span class="nav-number">4.2.1.</span> <span class="nav-text">CFRunLoopRunSpecific</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CFRunLoopDoObservers"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">CFRunLoopDoObservers</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CFRunLoopRun"><span class="nav-number">4.2.2.</span> <span class="nav-text">CFRunLoopRun</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CFRunLoopServiceMachPort"><span class="nav-number">4.2.3.</span> <span class="nav-text">CFRunLoopServiceMachPort</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZenonHuang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://zenonhuang.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://zenonhuang.me/2018/04/17/technology/2018-04-17-Runloop/';
          this.page.identifier = '2018/04/17/technology/2018-04-17-Runloop/';
          this.page.title = 'RunLoop 源码阅读';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://zenonhuang.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("k2TRBWba0l1Gs8oDHKfxxSXD-gzGzoHsz", "lb4xG7itO28IvwoxTwydiiJC");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
