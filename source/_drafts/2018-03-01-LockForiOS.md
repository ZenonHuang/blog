又到了春天挪坑的季节，想起多次被问及到锁的概念，决定好好总结一番。

翻看目前关于 iOS 开发里的锁的文章，大部分都起源于 ibireme 的 [《不再安全的 OSSpinLock》](https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/)。

我想依次解决几个关于锁的疑问:

1. 锁是什么?
2. 为什么要有锁？
3. 锁的分类
4. 为什么 OSSpinLock 不安全？
5. 如何解决  OSSpinLock 不安全的问题？
6. 为什么换用 pthread_mutex 就可以解决问题，还有其它方式吗？
7. 自旋锁和互斥锁的关系是平行对立的吗？
8. 递归锁使用的场景
9. 共享锁使用的场景

# 锁是什么

在多线程编程时，需要一些同步工具，来保证线程安全。

锁 -- 就是保证线程安全的同步工具。

## 为什么要有锁？

前面说到了，锁是用来保护线程安全的工具。

可以试想一下，多线程编程时，没有锁的情况 -- 也就是线程不安全。

当多个线程同时对一块内存发生读和写的操作，就可能出现意料之外的结果:

当程序执行的顺序会被打乱,可能造成提前释放一个变量,计算结果错误等情况。

所以我们需要将线程不安全的代码 “锁” 起来。保证一段代码或者多段代码操作的原子性。

### 属性设置 atomic  

上面提到了原子性，我马上想到了属性关键字里， atomic 的作用。

设置 atomic 之后，默认生成的 getter 和 setter 方法执行是原子的。 

但是它只保证了自身的读/写操作，却不能说是线程安全。

如下情况: 

	//thread A
	for (int i = 0; i < 100000; i ++) {
    if (i % 2 == 0) {
        self.arr = @[@"1", @"2", @"3"];
    }
    else {
        self.arr = @[@"1"];
    }
    	NSLog(@"Thread A: %@\n", self.arr);
	}

    
	//thread B
	if (self.arr.count >= 2) {
    	NSString* str = [self.arr objectAtIndex:1];
	}
	

就算在 **thread B** 中针对 arr 数组进行了大小判断，但是仍然可能在 `objectAtIndex:` 操作时被改变数组长度，导致出错。这种情况声明为 atomic 也没有用。

而解决方式，就是进行加锁。需要注意的是，读/写的操作都需要加锁，不仅仅是对一段代码加锁。

# 锁的分类

锁的分类方式，根据锁的状态，锁的特性等有很多种分类方式，很多锁并不是并列关系。可以参考 [几个关于锁的名词联系是什么](https://www.zhihu.com/question/39850927) 中 `Tim Chen` 的回答。

很多谈论锁的文章，都会提到互斥锁，自旋锁。但是很少有提到它们的关系，其实自旋锁，也是互斥锁的一种实现，`spin lock`和 `mutex` 都是为了解决某项资源的互斥使用,在任何时刻只能有一个保持者。

区别在于 `spin lock`和 `mutex` 调度机制上略有不同。

## OSSpinLock 

OSSpinLock 是一种自旋锁。 它的特点是在等待时会一直轮询，线程处于忙等状态。自旋锁由此得名。

自旋锁看起来是比较耗费 cpu 的，然而在互斥临界区计算量较小的场景下，它的效率远高于其它的锁。

因为它是一直处于 running 状态，减少了线程切换上下文的消耗。

### 为什么 OSSpinLock 不再安全？

关于 OSSpinLock 不再安全，原因就在于优先级反转问题。

#### 优先级反转(Priority Inversion)

什么情况叫做优先级反转？

wikipedia 上是这么定义的：

>优先级倒置，又称优先级反转、优先级逆转、优先级翻转，是一种不希望发生的任务调度状态。在该种状态下，一个高优先级任务间接被一个低优先级任务所抢先(preemtped)，使得两个任务的相对优先级被倒置。
>这往往出现在一个高优先级任务等待访问一个被低优先级任务正在使用的临界资源，从而阻塞了高优先级任务；同时，该低优先级任务被一个次高优先级的任务所抢先，从而无法及时地释放该临界资源。这种情况下，该次高优先级任务获得执行权。

再消化一下

>有：高优先级任务A / 次高优先级任务B / 低优先级任务C / 资源Z 。
>A 等待 C 使用 Z，然后 B 抢先使用 Z。
>这种情况造成 A 在 B 之后使用 Z,任务执行的优先级被倒置了。

而 OSSpinLock 就存在这种等待资源使用，从而出现优先级反转的问题，会导致任务迟迟完不成，不释放 lock 。

#### 优先级反转的解决方案

关于优先级反转一般有以下三种解决方案

##### 优先级继承

优先级继承，故名思义，是将占有锁的线程优先级，继承等待该锁的线程高优先级，如果存在多个线程等待，就取其中之一最高的优先级继承。

##### 优先级天花板

优先级天花板，则是直接设置优先级上限，给临界区一个最高优先级，进入临界区的进程都将获得这个高优先级。

如果其他试图进入临界区的进程的优先级，都低于这个最高优先级，那么优先级反转就不会发生。

##### 禁止中断

禁止中断的特点，在于任务只存在两种优先级：可被抢占的 / 禁止中断的 。

前者为一般任务运行时的优先级，后者为进入临界区的优先级。

通过禁止中断来保护临界区，没有其它第三种的优先级，也就不可能发生反转了。

# 为什么使用其它的锁，可以解决优先级反转？

我们看到很多使用 OSSpinLock 的项目，都该用了其它方式替代，比如 `pthread_mutex` 和 ` dispatch_semaphore` 。

那么为什么其它的方式，就不会有优先级反转的问题呢？这也是大部分文章，没有说明的。

## pthread_mutex

首先解决上面的疑问，`pthread_mutex` 可以解决优先级反转问题，在于它本身就拥有一个优先级继承的设置。

通过设置它的协议，来解决优先级反转:
>pthread_mutexattr_setprotocol(pthread_mutexattr_t *attr, int protocol) 

其中协议包括以下几种：
- PTHREAD_PRIO_NONE：线程的优先级和调度不会受到互斥锁拥有权的影响。 - PTHREAD_PRIO_INHERIT：当高优先级的等待低优先级的线程锁定互斥量时，低优先级的线程以高优先级线程的优先级运行。这种方式将以继承的形式传递。当线程解锁互斥量时，线程的优先级自动被降到它原来的优先级。该协议就是支持优先级继承类型的互斥锁，它不是默认选项，需要在程序中进行设置。 - PTHREAD_PRIO_PROTECT：当线程拥有一个或多个使用 PTHREAD_PRIO_PROTECT 初始化的互斥锁时，此协议值会影响其他线程（如 thrd2）的优先级和调度。thrd2 以其较高的优先级或者以 thrd2 拥有的所有互斥锁的最高优先级上限运行。基于被 thrd2 拥有的任一互斥锁阻塞的较高优先级线程对于 thrd2的调度没有任何影响。

所以，我们可以通过设置协议为 `PTHREAD_PRIO_INHERIT` 类型，解决优先级反转的问题。

## dispatch_semaphore

### 信号量机制

## NSLock

## NSCondition

## NSConditionLock

## NSRecursiveLock

## @synchonized

@synchonized(self) 更适合使用在你 需要确保在发生错误时代码不会死锁，而是抛出异常的时候。






## 其它保证线程安全的方式

### 使用单线程访问

### 不对资源做修改

因此，如果都是访问共享资源而不去修改共享资源也可以保证线程安全。

总的来说，比如 NSArry 这样不可变类是线程安全的。然而它们的可变版本，比如 NSMutableArray 是线程不安全的。事实上，如果是在一个队列中串行地进行访问的话，在不同线程中使用它们也是没有问题的。




# 参考

[linux c学习笔记----互斥锁属性](http://lobert.iteye.com/blog/1762844)

[Java中的锁分类](https://www.cnblogs.com/qifengshi/p/6831055.html)

[正确使用多线程同步锁@synchronized()](http://mrpeak.cn/blog/synchronized/)

[iOS多线程到底不安全在哪里？](http://mrpeak.cn/blog/ios-thread-safety/)

[iOS 中几种常用的锁总结](https://www.jianshu.com/p/1e59f0970bf5)



