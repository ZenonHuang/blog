1. Event Loop 到底是什么样的机制？
2. 为什么 CFRunLoopRef 是线程安全的， NSRunLoop 反而线程不安全？
3. 主线程 Runloop 有什么不同吗？
4. 主线程 RunLoop 的销毁发生在什么时候？
5. RunLoop 与 Autorelease Pool 是什么关系？
6. Source0 和 Source1 事件的该如何使用
7. mach port 是什么？
8. mach_msg_trap() 做了什么
9. mode里没有source/timer/observer, 会直接返回吗？
10. 线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有”，如果我一直不获取runloop的话，这个线程就不能处理事件吗？
11. 为什么在主线程添加一个 Runloop 后会卡死？（主线程加上 NSRunLoop.mainRunLoop().run() 整个程序就卡死了）
12. UI 触摸事件，到底是从 source0 还是 source1 调起的？ 
13. RunLoop 内部的逻辑图第7步，唤醒的条件port-based input source，应该是source1吧？
14. Runloop 实际应用的场景？
15. 事件响应
苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。但按钮的事件处理是停在__CFRunLoopDoSources0, 是Sources0而不是Source1？
16. 测试[[NSRunLoop currentRunLoop] run];NSLog(@”is running”);, 发现没有打印？
17. Runloop 和线程的关系？

# Event Loop

Run Loop 是一个 iOS 开发里的基础概念，它并非独有的机制，很多系统和框架都有类似的实现，Run Loop 是 Event Loop （事件循环）机制的在 iOS 平台的一种实现。
查阅 [wikipedia](https://en.wikipedia.org/wiki/Event_loop) 有关 Event Loop 的描述:
>在计算机科学里， Event Loop / Run Loop 是一个用于等待和发送消息/事件的程序结构，在程序中等待和派发一系列事件或者消息。它通过向“事件提供者”发出请求来工作，通常会阻塞请求，直到事件到达，然后调用相应的事件处理程序。


# Event Driven 

说到 Event Loop ，其实还应该了解到 Event-Driven (事件驱动)。Event-Driven 的出现，在于解决图形界面和用户交互的问题：
>通常 GUI 程序的交互事件执行是由用户来控制的，无法预测它发生的节点，对应这样的情况，需要采用 Event-Driven 的编程方法。

Event-Driven 的实现原理，基本就是使用 Event Loop 完成。Event-Driven 程序的执行，可以概括成: 
>启动 ——> 事件循环（即等待事件发生并处理之）。

在 GUI 的设计场景下，一般写代码会是下面的思维：
> 用户输入 -> 事件响应 -> 代码运行 -> 刷新页面状态

## Event 

我们一直在说 Event Loop , Event-Driven，那什么是 Event (事件) 呢？

在 Event-Driven 中，可以把一切行为都抽象为 Event . 例如: IO 操作完成， 用户点击按钮，一个图片加载完成,文本框的文字改变等等情况，都可以看作是个 Event .

## Event Handler

当 Event 被放到 Event Loop 里进行处理的时候，会调用预先注册过的代码对 Event 做处理。这就叫 Event Handler 。

Event Handler 其实就是对 Event 的响应，可以叫做事件回调，事件处理，事件响应，都是一样的概念。

这里需要注意的是，一个 Event 并不一定有 Event Handler .


## Event Loop 解决了什么问题

一般来说，操作分为同步和异步。

同步操作，是一个接一个的处理。等前一个处理完，再执行下一个。那么在一些耗时任务上，比如有很多 I/O 操作 或者 网络请求 的任务，线程就会有长时间在等待任务结果。

异步操作，是不用等待执行结果的，可以直接在这期间执行另外的任务。等到任务结果出来之后，再进行处理。

实际上 Event Loop 就是实现异步的一种方法。对于有回调的 Event,线程不用一直等待任务的结果出来再去执行下一个。而是等 Event 被加入到 Event Loop 时，再去执行。如果一个 Event 也没有，那线程就会休眠，避免浪费资源。

如果没有 Event Loop 来实现异步操作，那我们的程序会很容易出现卡顿。

> JavaScript 在单线程条件下运行，可以完成异步操作的原因，也是基于 Event Loop 机制。可以参考
[JavaScript异步编程](https://zhuanlan.zhihu.com/p/26567159) 的内容来理解。

# 

# Run Loop 休眠/唤醒

关于 Run Loop 当中核心的功能，就是让线程在没有任务时休眠和有在任务时唤醒。

## 休眠

如下代码，让线程休眠，等待接收唤醒消息。

```objc
...
__CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort) {
        mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg
}

...
```

## mach_msg()

这里特殊的地方，就在于发送和接受消息是通过同一个 API 进行的，mach_msg() 既发出了休眠的消息。同时也得到一个返回

## mach_msg_trap() 

## 唤醒

```objc
...
CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);
sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);
if (sourceHandledThisLoop) {
             mach_msg(reply, MACH_SEND_MSG, reply);
}
...
```

# Run Loop 销毁

# 观察者


【准确讲，使用事件驱动的系统中，必然有非常非常多的事件。如果事件都产生，都要主循环去处理，必然会导致主线程繁忙。那对于应用层的代码而言，肯定有很多不关心的事件（比如只关心点击事件，不关心定时器事件）。这会导致一定浪费。】
【这篇文章里没有讲到的一个重要概念是watcher。观察者。】
【事实上，不是所有的事件都放置在一个队列里。】
【不同的事件，放置在不同的队列。】
【当我们没有使用定时器时，则完全不用关心定时器事件这个队列】
【当我们进行定时器调用时，首先会设置一个定时器watcher。事件循环的过程中，会去调用该watcher，检查它的事件队列上是否产生事件（比对时间的方式）】
【当我们进行磁盘IO的时候，则首先设置一个io watcher，磁盘IO完成后，会在该io watcher的事件队列上添加一个事件。事件循环的过程中从该watcher上处理事件。处理完已有的事件后，处理下一个watcher】
【检查完所有watcher后，进入下一轮检查】
【对某类事件不关心时，则没有相关watcher】

程序的某些操作会不断产生事件，而事件循环过程中需要用于判断是否有事件需要处理的观察者，比如有文件I/O观察者，网络I/O观察者等，对于非I/O操作，对于setTime和setInterval有定时器观察者，process.nextTick()有idle观察者，setImmediate有check观察者等等。
一个观察者里可能有多个事件，这些事件以队列的方式存在于观察者中，然后每次tick向观察者们循环需要处理的事件


# Runloop 和线程的关系

## Runloop 和线程，是一个上下的包含关系，还是并列的关系？

大部分说 Runloop 的文章，都要提到 Runloop 和线程是个一对一的关系，却没有具体解释，它是怎么对应的？是 Runloop 本身就运行在对应的线程之中嘛？还是 Runloop 是专门放在另一个线程中的？

关于 Runloop 运行的基本原理，每篇相关的文章都会上这么一段代码:

	while(!exit) {
	    //dosomthing 处理IO等等，没有事件调用系统休眠
   		 waitforEvents
	}	


就是上面这样一个简单的循环而已。

我假设 Runloop 运行在它对应的线程之中，那么就会产生一个矛盾:
>如果没有手动去退出，线程暂时也没有任务处理，Runloop 会让线程休眠。同时， Runloop 自己却是保持循环，等待接收事件进行处理。
>同一个线程，同一时间，它的状态怎么既可以运行，又可以休眠？

而 Runloop 可能运行在另一个线程中，按照 Javascript 中的 Event Loop 的实现机制， Javascript 本身是单线程操作的，不可能存在多线程。

而答案，的确是 Runloop 跟着线程一起休眠了，而信号的发出和唤醒，来自于系统。


## 协程

线程和进程这些都是操作系统调度的，现在为了优化线程切换又有用户态线程叫”协程"

效率高，一个线程中，不需要切换。

不需要使用锁，一个线程不存在同时多读多写。

## 定时器问题

但定时器事件是靠事件循环不停检查系统时间来判定是否到达时间点来产生事件】


# 主线程 Runloop

关于 Runloop 与线程的关系，是一一对应的。但是很少有人想过，主线程的 Runloop 是否可以被停止？它与子线程 Runloop 有什么不同？


## 主线程 Runloop 和 子线程 Runloop 的区别
 
 
## 主线程 Runloop 何时销毁？



# Source0 和 Source1  所接受的事件

Source1 用于接收系统事件，通过 mach_port 通信。


## 一个触摸事件，是由哪个 Source 分发的？

然后这些事件又由 SpringBoard 接收，它只接收收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event
接着用mach port转发给需要的App进程
随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue()进行应用内部的分发

# Runloop 不获取就不创建?

对于一些子线程的事件，没有获取 Runloop ，那这个线程就没有 Runloop 存在了吗？

# Runloop 和 AutoReleasePool 的关系



## 什么时候使用 Run Loop


# 参考

[苹果文档--RunLoop](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23)

[前端思维转变--从事件驱动到数据驱动](https://godbasin.github.io/2017/09/29/data-driven-or-event-driven/#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B)

[理解Python事件驱动编程(Event Loop)](https://blog.csdn.net/woshijidutu/article/details/77934028)



