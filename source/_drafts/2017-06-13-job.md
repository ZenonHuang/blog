---
layout: post
date: 2017-06-01 10:25:00
title: iOS 面试题
category: 技术
keywords: iOS
description: 收集了一些 iOS 面试题，可以对自己的知识查漏补缺
---

# 内存管理

## 什么是ARC

ARC 是 Automatic Reference Counting 的缩写，即自动引用计数。

关于 ARC,当我初出茅庐的时候,大概是这样告诉面试官的：
> ARC 相当于在代码里，自动插入了 `retain`, `release`和`autorelease`。我们不用自己手动去管理引用计数。

实际上，ARC 需要答到 `引用计数` 的关键点上去。

- ARC 中的强引用，依然保留 MRC 的方式，即对象的引用计数为 0 时，进行释放。因为这样实现的方式代价很低。

- ARC 中出现弱引用，则将内存对象在系统中建立映射表；一旦内存对象因为所有强引用归零而释放，则将所有弱引用指针归零（指向 nil）——应该有一个链表。

而将`弱引用`强制指向 nil ，也是一种无奈的方式，按理说，这依然是个隐患，是代码逻辑的缺陷，只是人家帮你将错误的代价降到最低而已。

总结：

`强引用`的逻辑是--如果都不用了，我就释放掉；

`弱引用`的逻辑是--如果对象释放了，我就置 nil。

strong:
>只要某个对象被任一 strong 指针指向，那么它将不会被销毁。
>如果对象没有被任何 strong 指针指向，那么就将被销毁。
>在默认情况下，所有的实例变量和局部变量都是 strong 类型的。可以说 strong 类型的指针在行为上和 MRC 时代 retain 的 property 是比较相似的。

weak:
>一个常见的例子就是 oc 中常见的 delegate 设计模式，viewController 中有一个 strong 指针指向它所负责管理的 UITableView，而UITableView中的 dataSource 和 delegate 指针都是指向 viewController 的 weak 指针。一旦 viewController 释放掉，dataSource 和 delegate 就置 nil 了

在类似情况下，使用 weak 关键字，是没有意义的:

```
__weak NSString *str = [[NSString alloc] initWithFormat:…]; 
NSLog(@"%@",str); //输出是"(null)"
```

由于对象 str 是 weak，它不会持有 alloc 出来的 NSString 对象.而这个对象，由于没有有效的 strong 指针指向，所以在生成的同时就被销毁了。


## Java 区别

引用计数和垃圾回收

ARC 不同于 java 的垃圾回收，垃圾回收的原理是什么？

基于引用计数与基于trace这两大类别的自动内存管理方式最大的不同之处在于：前者只需要局部信息，而后者需要全局信息。

[引用计数与垃圾收集之比较](https://blog.codingnow.com/2008/06/gc.html)

[](https://www.zhihu.com/question/21539353)

- 标记-清除算法
- 复制算法
- 标记-压缩(Mark-Compact)算法
- 分代 (Generational Collecting)
- 增量算法 (Incremental Collecting)

## MRC 

手动引用计数的机理，简单来说，只要遵循以下三点就可以在手动内存管理中避免绝大部分的麻烦：

> 如果需要持有一个对象，那么对其发送 retain. 
> 如果之后不再使用该对象，那么需要对其发送 release（或者autorealse）. 
> 每一次对 retain,alloc 或者 new 的调用，需要对应一次 release 或 autorealse 调用

## autorelease 重点

在 `MRC` 下,我们可以在创建对象的时候给对象发送“autorelease”消息，然后当NSAutoreleasePool 结束的时候，“标记过”autorelease的对象都会被“release”掉，也就是会被释放掉。

```
NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
NSString* str = [[[NSString alloc] initWithString:@"tutuge"] autorelease];
//use str...
[pool release];
//str is released
```

在`ARC`下, 我们甚至可以不需要知道 autorelease 是什么都能管理好内存.但是有的场景，仍然需要你知道 autorelease ,利用它进行优化，在某些情况下，大幅度降低程序的内存占用 。

苹果的官方文档，有对使用 atuorelease 场景的解释：

- If you are writing a program that is not based on a UI framework, such as a command-line tool.
- If you write a loop that creates many temporary objects.
You may use an autorelease pool block inside the loop to dispose of those objects before the next iteration. Using an autorelease pool block in the loop helps to reduce the maximum memory footprint of the application.
- If you spawn a secondary thread.
You must create your own autorelease pool block as soon as the thread begins executing; otherwise, your application will leak objects.

翻译过来：

- 程序不是基于 UI framework, 例如命令行项目
- 循环体中，创建了大量临时对象，你需要在循环体内创建一个autorelease pool block，并且在每次循环结束前，处理 autoreleased 对象. 在循环中使用autorelease pool block可以降低内存峰值
- 你创建了一个新线程，当线程开始执行的时候你必须立马创建一个autorelease pool block, 否则你的应用会造成内存泄露（非Cocoa程序创建线程时才需要）.

看完下来，其实在我们平常 iOS 程序中，就是 循环创建大量临时变量的时候，需要使用 @autoreleasepool 来优化循环就可以了。


## AutoReleasePool

在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop


官方文档建议，for循环中遍历产生大量autorelease变量时，就需要手加局部AutoreleasePool咯。


## 关键字的区别

- assign vs weak

>assign:
>assign 关键字修饰，不更改引用计数。适用于基本数据类型的修饰。这里要问一个，为什么呢？ 
>assign 修饰对象，造成野指针--assign 其实也可以用来修饰对象。那么我们为什么不用它修饰对象呢？因为被 assign 修饰的对象（一般编译的时候会产生警告：Assigning retained object to unsafe property; object will be released after assignment）在释放之后，指针的地址还是存在的，也就是说指针并没有被置为nil，造成野指针.对象一般分配在堆上的某块内存，如果在后续的内存分配中，刚好分到了这块野指针的地址，程序就会崩溃掉。
> 基础数据类型的内存分配--因为基础数据类型一般分配在`栈`上。栈的内存，会由系统自己自动处理，也就不会造成野指针。所以使用 assign 来修饰基本数据类型。
> weak:
> weak 修饰的对象在 释放 之后，指针地址会被置为nil.跟上面 ARC 里提到概念一样。
>这里就补充一下使用场景:
- 在ARC下,在有可能出现循环引用的时候，往往要通过让其中一端使用weak来解决，比如: delegate代理属性，通常就会声明为weak。
- 自身已经对它进行一次强引用，没有必要再强引用一次时也会使用weak。比如：自定义 IBOutlet控件属性一般也使用weak,当然，也可用 strong

-  __block vs __weak

> __block
>__block是用来修饰一个变量，这个变量就可以在block中被修改。
>使用 __block 修饰的变量在 block 代码块中会被 retain（ARC下会retain，MRC下不会retain）
>retain：属性在赋值的时候，先release之前的值，然后再赋新值给属性，引用计数再加1。
>__weak
>使用 __weak 修饰的变量不会在 block 代码块中被retain。
>例如，在ARC下，要避免block出现循环引用 __weak typedof(self)weakSelf = self;

- copy VS strong

copy 操作，会在内存里拷贝一份对象，原来对象的指针，和 copy 后的新对象指针，分别指向不同的内存地址。

通过 copy ，就可以把 block 从 栈上 拷贝到 堆上，保证block的声明域外使用。

block 使用 copy 是从 MRC 遗留下来的`传统`

> 在ARC环境下，系统底层也会做一次copy操作.使 block 从 栈区 复制一块内存空间到 堆区 .所以strong 和 copy 在对 block 的修饰上,是没有本质区别的

NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary。他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。


## 内存泄漏

内存泄漏是常见情况，有几种会造成。

- 循环引用 

## Xib ／ SB 属性

IBOutlet 连出来的视图属性为什么可以被设置成weak?

参考链接：[ ***Should IBOutlets be strong or weak under ARC?***](http://stackoverflow.com/questions/7678469/should-iboutlets-be-strong-or-weak-under-arc)

文章告诉我们：

> 因为既然有外链那么视图在xib或者storyboard中肯定存在，视图已经对它有一个强引用了。

不过这个回答漏了个重要知识，使用storyboard（xib不行）创建的vc，会有一个叫 _topLevelObjectsToKeepAliveFromStoryboard 的私有数组强引用所有 top level 的对象，所以这时即便outlet声明成weak也没关系

## weak 的实现

weak 变量的自动置 nil？

weak 关键字的作用弱引用，所引用对象的计数器不会加一，并在引用对象被释放的时候自动被设置为 nil.

用一张记录对象的弱引用表，当释放时，根据弱引用表。 key 是对象的内存地址， value 是该对象的所有弱引用的指针数组,把它们置 nil.

# Block

iOS开发中经常会使用block结合gcd来完成多线程编程，block也属于对象，主要有三种类型.

- NSConcreteGlobalBlock 类型

全局静态Block,不访问任何外部变量，不会涉及到任何拷贝

存储在程序的数据区域(text段).

NSGlobalBlock：在block内部没有引用任何外部变量

```
void (^globalBlock) () = ^ () {
      NSLog(@"global block");
};

NSLog(@"%@", globalBlock);
//输出：<__NSGlobalBlock__: 0x1096e20c0>
```

对 NSGlobalBlock 的 retain、copy、release 操作都无效。

它既不在栈中，也不在堆中，我理解为它可能在内存的全局区。

- NSConcreteStackBlock 类型

存储在栈上.

有访问到外部变量的Block,该保存在栈中，当函数返回时被销毁

当栈中的block执行一次之后就被清除出栈了，所以无法多次使用。

- NSConcreteMallocBlock 类型

存储在堆上.

block 通常不会在源码中直接出现，因为默认它是当一个 block 被 copy 的时候，才会将这个 block 复制到堆中.

该类型的Block是由NSConcreteStackBlock 复制到堆中形成的。

## 三种 Block 关系

如果 Block 在记述全局变量的地方被设置或者 Block 没有捕获外部变量，那就生成一个 _NSConcreteGlobalBlock 实例。

其它情况都会生成一个 _NSConcreteStackBlock 实例，也就是说，它是在栈上的，所以一旦它所属的变量超出了变量作用域，该 Block 就被废弃了。

而当发生以下任一情况时：

- 手动调用 Block 的实例方法copy
- Block 作为函数返回值返回
- 将 Block 赋值给附有__strong修饰符的成员变量
- 在方法名中含有usingBlock的 Cocoa 框架方法或 GCD 的 API 中传递 Block

如果此时 Block 在栈上，那就复制一份到堆上，并将复制得到的 Block 实例的isa指针设为 _NSConcreteMallocBlock。

此时 Block 已经在堆上，那就把该 Block 的引用计数加1

## 为什么把 Block 从栈复制到堆中 


## block 关键字修饰

block 变量,定义时的关键字修饰

block 本身是像对象一样可以retain，和release。

block在创建的时候，它的内存是分配在`栈(stack)`上，由系统自行处理，可能被随时回收，而不是在`堆(heap)`上。作于域是属于创建时候的作用域，一旦在创建时候的作用域，被外面调用 block 将导致程序崩溃。

## Block 循环引用

当block获取到外部变量时，由于编译器无法预测获取到的变量何时会被突然释放，为了保证程序能够正确运行，让block持有获取到的变量。

这就可能造成循环引用的问题。

主要思路，就是打破引用链，可以通过三种方法：
第一个，调用完 Block 后就将它置空
第二个，对于引用的对象，作为 weak 处理
第三个，对于引用的对象使用后置空

weak-strong dance:

strong 延长捕获对象的生命周期，一旦 Block 执行完，对象被释放，而 Block 也会被释放.

# 多线程

## Pthreads

>POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用Pthreads作为操作系统的线程。

## NSThread

## GCD

>串行队列，并行队列
>同步提交，异步提交
  
为什么说 GCD 死锁是队列导致的而不是线程，死锁不是操作系统的概念么？

GCD队列种类：
- dispatch_get_main_queue（主队列）串行队列.
- dispatch_get_global_queue(全局队列) 并发队列 子线程执行，
- dispatch_queue_create（用户队列）串并都可以，子线程执行.
  
  主要的死锁就是当前串行队列里面同步执行当前串行队列。解决的方法就是将同步的串行队列放到另外一个线程执行。
  
### GCD里面有哪几种Queue？

两种queue，串行和并行。main queue是串行，global queue是并行。有些开发者为了在工作线程串行的处理任务会自己建立一个serial queue。背后是苹果维护的线程池，各种queue要用线程都是这个池子里取的。GCD大家都用过，但很多关键的概念不少人都理解的模凌两可。串行，并行，同步，异步是GCD的核心概念。

- 你自己建立过串行queue吗？背后的线程模型是什么样的？


## NSOperation & NSOperationQueue

> NSOperation 是苹果公司对 GCD 的封装，完全面向对象，所以使用起来更好理解。 大家可以看到 NSOperation 和 NSOperationQueue 分别对应 GCD 的 任务 和 队列 。操作步骤也很好理解：
>将要执行的任务封装到一个 NSOperation 对象中。
>将此任务添加到一个 NSOperationQueue 对象中。

## 使用 atomic 一定是线程安全吗

## 线程安全的概念

多条线程同时工作的情况下,通过运用线程锁,原子性等方法避免多条线程因为同时访问同一快内存造成的数据错误或冲突.

## 多线程不安全的原因

每条线程都有自己独立的栈空间. 但是他们公用了堆. 所以他们可能同时访问同一块内存空间. 因此造成数据冲突.

----

atomic 通过 property 的方式使用才能保证安全，还有人知道这个用来做多线程安全会有性能损耗。

当使用atomic时，虽然对属性的读和写是原子性的，但是仍然可能出现线程错误：当线程A进行写操作，这时其他线程的读或者写操作会因为该操作而等待。当A线程的写操作结束后，B线程进行写操作，然后当A线程需要读操作时，却获得了在B线程中的值，这就破坏了线程安全.如果有线程C在A线程读操作前release了该属性，那么还会导致程序崩溃。

>atomic所说的线程安全,只是保证了getter和setter存取方法的线程安全，并不能保证整个对象是线程安全的。

如：

```
@property(atomic,strong) NSMutableArray *arr;
```

如果一个线程循环的读数据，一个线程循环写数据，那么肯定会产生内存问题，因为这和setter、getter没有关系。如使用[self.arr objectAtIndex:index]就不是线程安全的。好的解决方案就是加锁。

好的解决方案就是加锁。据说，atomic要比nonatomic慢大约20倍

## 锁


Objective-C中几种不同方式实现的锁

atomic,synchronized,NSLock,pthread mutex,OSSpinLock的差别

- NSLock

- @synchronized

- 自旋锁

## iOS 死锁 

- 死锁的原因

- 具体哪些操作会引发死锁

# Runloop

NSRunLoop 和 CFRunLoopRef.

CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。
NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。

线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。

主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。

## runloop 的 mode 作用是什么？

## runloop 和线程

## runloop 应用

- FDTemplateCell 利用 runloop 在空闲时加载数据


# Runtime 

Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理

Runtime基本上是用C和汇编写的，这个库使得C语言有了面向对象的能力。是 Objective-C 面向对象和动态机制的基石。

在Runtime中，对象可以用C语言中的结构体表示，而方法可以用C函数来实现，另外再加上了一些额外的特性。

当程序执行[object doSomething]时，会向消息接收者(object)发送一条消息(doSomething)，runtime会根据消息接收者`是否能响应该消息`而做出`不同的反应`。

## OC 和 C 语言的对比

> C：
>在很多语言，比如 C ，调用一个方法其实就是跳到内存中的某一点并开始执行一段代码。没有任何动态的特性，因为这在编译时就决定好了。
> OC ：
>而在 Objective-C 中，[object foo] 语法并不会立即执行 foo 这个方法的代码。它是在运行时给 object 发送一条叫 foo 的消息。这个消息，也许会由 object 来处理，也许会被转发给另一个对象，或者不予理睬假装没收到这个消息。

## 消息机制

## 动态得创建类和对象

## 进行消息传递和转发

消息传递的关键藏于 objc_object 中的 isa 指针和 objc_class 中的 class dispatch table。


## JSPatch 实现原理

直接看 [JSPatch 实现原理详解](https://github.com/bang590/JSPatch/wiki/JSPatch-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3)



# UIKit

## UIView 和 CALayer 关系

能说出 UIView 主要处理事件，CALayer 负责绘制

- UIView：

在 View显示的时候，UIView 做为 Layer 的 CALayerDelegate,View 的显示内容由内部的 CALayer 的 display

- layer ：

和UIView最大的不同是CALayer不处理用户的交互。

layer 内部维护着三分 layer tree(图层树),分别是 presentLayer Tree(动画树),modeLayer Tree(模型树), Render Tree (渲染树),在做 iOS动画的时候，我们修改动画的属性，在动画的其实是 Layer 的 presentLayer的属性值,而最终展示在界面上的其实是提供 View的 modelLayer

## 取消隐式动画

* 每一个UIView内部都默认关联着一个CALayer，我们可用称这个Layer为Root Layer（根层）

* 所有的非Root Layer，也就是手动创建的CALayer对象，都存在着隐式动画

* 什么是隐式动画？

    * 当对非Root Layer的部分属性进行修改时，默认会自动产生一些动画效果
    * 而这些属性称为Animatable Properties(可动画属性)


可以通过动画事务(CATransaction)关闭默认的隐式动画效果

```
 [CATransaction begin];
 [CATransaction setDisableActions:YES];
 self.myview.layer.position = CGPointMake(10, 10);
 [CATransaction commit];
```

事务（transaction）：

隐式动画中有一个「事务」的概念。

事务（transaction）实际上是Core Animation用来包含一系列属性动画集合的机制，用指定事务去改变可以做动画的图层属性，不会立刻发生变化，而是提交事务时用一个动画过渡到新值。
Core Animation中的事务通过CATransaction类来做管理，这个类有些奇怪，它没有属性或实例方法，并且也不能创建实例，但可以用类方法begin()或commit()分别来入栈或出栈。



## UIImageView加圆角

离屏渲染并非由设置圆角导致的。
```
 view.layer.cornerRadius = 5
```

无影响

```
 view.layer.cornerRadius = 5
 view.layer.masksToBounds = true
```

有影响

解决办法：

利用 Core Graphics 自己画出了一个圆角矩形。除了一些必要的代码外，最核心的就是 CGContextAddArcToPoint 函数。它中间的四个参数表示曲线的起点和终点坐标，最后一个参数表示半径。调用了四次函数后，就可以画出圆角矩形。最后再从当前的绘图上下文中获取图片并返回。

### 离屏渲染

OpenGL 中，GPU 屏幕渲染有以下两种方式：

* On-Screen Rendering 意为当前屏幕渲染，指的是 GPU 的渲染操作是在当前用于显示的屏幕缓冲区中进行。

* Off-Screen Rendering 意为离屏渲染，指的是 GPU 在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。

相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面：

* 创建新缓冲区 要想进行离屏渲染，首先要创建一个新的缓冲区。

* 上下文切换 离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。

所以在图形生成的步骤我们要尽可能的避免离屏渲染，或者开启 *shouldRasterize* 属性。

# 音视频

- 音频

- 视频

## 直播

- GOP ：
 I 帧：
 B 帧：
 P 帧：
 
- 直播协议

# 图像处理 OpenGL ES

OpenGL都用三角形来绘图

假设当我们想告诉OpenGL去画线段而不是三角形的时候，我们通过改变一些上下文变量来改变OpenGL状态，从而告诉OpenGL如何去绘图。一旦我们改变了OpenGL的状态为绘制线段，下一个绘制命令就会画出线段而不是三角形。

GPU 需要知道内存中的哪个位置来存储渲染出来的 2D 图像像素数据，接收渲染结果的缓冲区称为 帧缓冲区 (frame buffer) 。渲染指令会在适当的时候替换帧缓冲区中的内容，OpenGL ES 会根据特定平台硬件配置和功能设置数据类型和偏移。通常来说，渲染结果可以存储到任意数量的 frame buffer 中。上面提到的双缓冲的两个缓冲称之为 前帧缓冲区 (front frame buffer) 和 后帧缓冲区 (back frame buffer) 。

在 OpenGL ES 中，所有的图像都可以由点，线段和三角形构成，所以 OpenGL ES 只渲染这三种图形。在接收到一些顶点数据后，经过顶点着色器 (vertex shader) 处理，装配输出给片元着色器 (fragment shader) ,再经过一些操作最终输出给帧缓冲区。什么是片元呢？通常在顶点着色器输出几何图形数据后，会进行光栅化 (rasterizing) 将这些形状数据转换为帧缓存中的颜色像素，而每一个颜色像素就叫做片元 (fragment) 。

## GLKView

## 坐标系

OpenGLES的世界坐标系是[-1, 1]，故而点(0, 0)是在屏幕的正中间。

纹理坐标系的取值范围是[0, 1]，原点是在左下角。故而点(0, 0)在左下角，点(1, 1)在右上角

## 绘制单位

## 图片大小计算

60*60 的


# 通知

- 如何实现通知的自动移除？

- 如何实现一个通知中心？

# 网络

## http的post和get啥区别

post比 get ，安全一点点。。。。并非主要。

最显著的，是post 有body。

如果希望缓存或者大量访问的，用 get 可以大大减轻服务器的压力。

如果有敏感的操作，如 删除日志 等等，用post ,不可以直接被输入。

安全方面，该用 https 还是用 https 

## OSI 网络模型 

分层有几种分法, OSI 七层 :

- 应用层
- 表示层
- 会话层
- 传输层
- 网络层
- 链路层
- 物理层

七层模型中，表示层和会话层是没有对应协议在里面的

TCP/IP 四层 ，TCP/IP网络协议栈四层分为：

- 应用层（Application）:FTP SMTP HTTP ... 
- 传输层（Transport）:TCP UDP 
- 网络层（Network）:IP ICMP ARP 
- 链路层（Link）:以太网 令牌环 FDDI ...

包含了一系列构成互联网基础的网络协议。
这些协议最早发源于美国国防部的 DARPA 互联网项目。
TCP/IP 字面上代表了两个协议:TCP 传输控制协议和 IP 互联网协议。 

五层： 基于 TCP/IP 加了一个物理层

[网络分层](http://www.ha97.com/3215.html)

## TCP 连接

- 三次握手：

C->S: syn,
S->C: syn ack,
C->S: ack

如果少一次握手，会有什么问题?

少了一次就建立连接，那么超时请求过来，就又将开启连接，浪费资源。这时候对于 S 回来的信息，C已经关闭，没有请求新的连接，会无视S这一次的ACK、Seq和ACK number。而对A来讲，连接已经建立了，其为此次连接分配的资源会一直等待下去

- TCP 四次挥手：

C->S : FIN,准备关闭
S->C : ACK.知道.

C 进入 FIN_WAIT 状态

S->C : FIN.可以关闭了.
C->S : ACK,好的

C 进入 TIME_WAIT 状态一小段时间，如果Server端没有收到ACK则可以重传。时间过后，进行关闭。



## htpps 加密

## SS

- 大体原理

- SS 协议具体连接过程

- SS 客户端工作

如何跑起来，怎么建立一个本地服务器，怎么监听转发所有端口

## SockS5协议 (socketS缩写)

## Socket

## WebSocket协议

WebSocket是HTML5出的东西（协议），也就是说HTTP协议没有变化，或者说没关系，但HTTP是不支持持久连接的（长连接，循环连接的不算）。它是实现了浏览器与服务器全双工通信(full-duplex)。

现很多网站为了实现即时通讯，所用的技术都是轮询(polling)。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP request，然后由服务器返回最新的数据给客服端的浏览器。这种传统的HTTP request 的模式带来很明显的缺点 – 浏览器需要不断的向服务器发出请求，然而HTTP request 的header是非常长的，里面包含的数据可能只是一个很小的值，这样会占用很多的带宽。

而最比较新的技术去做轮询的效果是Comet – 用了AJAX。但这种技术虽然可达到全双工通信，但依然需要发出请求。


在 WebSocket API，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送，改变了原有的B/S模式。

## iOS 的 HTTP 缓存策略

- NSURLRequestUseProtocolCachePolicy
- NSURLRequestReturnCacheDataElseLoad
- NSURLRequestReturnCacheDataDontLoad

# 架构/编程方式

## 函数式编程 

无状态

## MVVM

# 算法／数据结构

## 时间复杂度

冒泡 O( n^2 )

快排 ：O( n log n ) 

二叉树 ： O( log 2^n )

## LRU 算法

## 哈希表

- 哈希碰撞

### 哈希表实现字典

字典时间复杂度 O(1),空间换时间。

# 持久化方案

- Plist文件

- NSUserDefaults

- NSKeyedArchiver 归档

- SQLite3

- CoreData


# iOS 里的缓存

- URLCache

URLCache 提供了内存和硬盘缓存的综合缓存机制，能够控制内存和硬盘缓存的大小，并且可以控制缓存数据的存储路径。

网络缓存减少了需要向服务器发送请求的次数，同时也提升了离线或在低速网络中使用应用的体验。如果系统遇到硬盘/内存空间太小的情况，系统也会主动清除一些硬盘/内存缓存的。设置一个全局 URLCache 可以有效的减轻服务端压力。

- Cache

cache的另一个重要知识点是cache的淘汰策略，不同的策略表现也不一样，FIFO，LRU，2Queues等等，现在有不少成熟的第三方cache框架可以使用，系统也提供了淘汰策略不明确的NSCache，如果没有动手写过任何cache淘汰策略，我还是建议大家自己动手试着做一个，至少要读一下相关的实现源码，了解这些淘汰策略很有必要，在做一些深度优化的时候需要因地制宜来做决定。

- 内存缓存

- 磁盘缓存


# 开源作品

## FlexBox

性能差异

语法优势

动态下发

跨平台

## 人脸识别，换背景 

# JavascriptCore

# 源码阅读

## AFN

## Masonry

## YYKit

### YYCache 项目

## Aspects

## JSPatch

# 其它问题

## kvo 

kvo的实现

Apple 使用了 isa 混写（isa-swizzling）来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为：NSKVONotifying_A 的新类，该类继承自对象A的本类，且 KVO 为 NSKVONotifying_A 重写观察属性的 setter 方法，setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象属性值的更改情况。
（备注： isa 混写（isa-swizzling）isa：is a kind of ； swizzling：混合，搅合；

观察者观察的是属性，只有遵循 KVO 变更属性值的方式才会执行 KVO 的回调方法，例如是否执行了 setter 方法、或者是否使用了 KVC 赋值。
如果赋值没有通过 setter 方法或者 KVC，而是直接修改属性对应的成员变量，例如：仅调用 _name = @"newName"，这时是不会触发 KVO 机制，更加不会调用回调方法的。
所以使用 KVO 机制的前提是遵循 KVO 的属性设置方式来变更属性值。

##  IB 配置

IB 中 User Defined Runtime Attributes 如何使用？

它能够通过KVC的方式配置一些你在 interface builder 中不能配置的属性。当你希望在IB中作尽可能多得事情，这个特性能够帮助你编写更加轻量级的viewcontroller

## load / initialize

+(void)load; +(void)initialize；有什么用处？

这两个方法在类被使用时会自动调用。但是两个方法的不同点会导致应用层面上性能的显著差异。

load和initialize方法内部使用了锁，因此他们是线程安全的，实现时要尽可能简单，避免线程阻塞，不要再次使用锁。

load方法常用来method swizzle，initialize常常用于初始化全局变量和静态变量.

- +initialize 
>这个方法会在 第一次初始化这个类之前 被调用，我们用它来初始化静态变量。
>`+ initialize` 方法类似一个懒加载，如果没有使用这个类，那么系统默认不会去调用这个方法，且默认只加载一次；
`+ initialize `的调用,发生在 +init 方法之前。
>创建子类的时候，子类会去调用父类的` + initialize `方法

- +load 
> 顾名思义，load方法在这个文件被程序装载时调用。只要是在Compile Sources中出现的文件总是会被装载，这与这个类是否被用到无关，因此load方法总是在main函数之前调用。父类先于子类执行，类先于分类执行。
>如果一个类没有实现load方法，那么就不会调用它父类的load方法，这一点与正常的类继承和方法调用不一样，需要额外注意一下。
>并没有对类做任何操作的情况下，+load 方法会被默认执行，并且是在 main 函数之前执行的。

一般来说，除了Method Swizzle，别的逻辑都不应该放在load方法中实现。

```
+ (void)load {
    Method originalFunc = class_getInstanceMethod([self class], @selector(originalFunc));
    Method swizzledFunc = class_getInstanceMethod([self class], @selector(swizzledFunc));
 
//交换两个方法的地址method_exchangeImplementations(originalFunc, swizzledFunc);
}
```

## 单例

```
+ (__class *)sharedInstance 
{ 
static dispatch_once_t once; 
static __class * __singleton__; 
dispatch_once( &once, ^{ __singleton__ = [[__class alloc] init]; } ); 
return __singleton__; 
}
```



# 参考资料

[(译)缓存在AFNetworking中是如何工作的？AFImageCache和NSUrlCache给你答案](http://devtian.me/2015/03/24/translate-how-does-cache-work-in-AFNetworking/)

[block](http://blog.ibireme.com/2013/11/27/objc-block/)

[Objective-C 中的消息与消息转发](http://blog.ibireme.com/2013/11/26/objective-c-messaging/)

[iOS 保持界面流畅的技巧](http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)

[YYCache 设计思路](http://blog.ibireme.com/2015/10/26/yycache/)

[iOS当中的Cache设计](http://mrpeak.cn/blog/ios-cache/)

[iOS网络缓存扫盲篇--使用两行代码就能完成80%的缓存需求](http://www.jianshu.com/p/fb5aaeac06ef)

[谈谈iOS中的HTTP缓存策略](http://chesterlee.github.io/blog/2014/08/10/ioszhong-de-urlcacheji-zhi/)

[隐式动画](http://zhangbuhuai.com/implicit-animations/)

[iOS 常见知识点（三）：Lock](http://www.jianshu.com/p/ddbe44064ca4)

[关于 @synchronized，这儿比你想知道的还要多](http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/)

[UIKit 性能调优](http://www.jianshu.com/p/619cf14640f3)

[MVVM 介绍](https://objccn.io/issue-13-1/)

[HTTP 的构成](http://mrpeak.cn/blog/http-constitution/)

[Objective-C Runtime](http://tech.glowing.com/cn/objective-c-runtime/)

[runtime 方法交换](http://www.jianshu.com/p/552651c962c3)

[iOS内存管理：从MRC到ARC实践](https://dev.qq.com/topic/59194943f473278853516915)


