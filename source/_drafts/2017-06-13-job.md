---
layout: post
date: 2017-06-01 10:25:00
title: iOS 面试题
category: 技术
keywords: iOS
description: 收集了一些 iOS 面试题，可以对自己的知识查漏补缺
---

# 编译过程

源代码 > 预处理器 > 编译器 > 汇编器 > 机器码 > 链接器 > 可执行文件

1.预处理（Pre-process）：把宏替换，删除注释，展开头文件，产生 .i 文件。
2.编译（Compliling）：把之前的 .i 文件转换成汇编语言，产生 .s文件。
3.汇编（Asembly）：把汇编语言文件转换为机器码文件，产生 .o 文件。
4.链接（Link）：对.o文件中的对于其他的库的引用的地方进行引用，生成最后的可执行文件（同时也包括多个 .o 文件进行 link）。

# 内存管理

[引用计数](http://yulingtianxia.com/blog/2015/12/06/The-Principle-of-Refenrence-Counting/#isa-%E6%8C%87%E9%92%88%EF%BC%88NONPOINTER-ISA%EF%BC%89)

## 什么是ARC

ARC 是 Automatic Reference Counting 的缩写，即自动引用计数。

关于 ARC,当我初出茅庐的时候,大概是这样告诉面试官的：
> ARC 相当于在代码里，自动插入了 `retain`, `release`和`autorelease`。我们不用自己手动去管理引用计数。

实际上，ARC 需要答到 `引用计数` 的关键点上去。

- ARC 中的强引用，依然保留 MRC 的方式，即对象的引用计数为 0 时，进行释放。因为这样实现的方式代价很低。

- ARC 中出现弱引用，则将内存对象在系统中建立映射表；一旦内存对象因为所有强引用归零而释放，则将所有弱引用指针归零（指向 nil）——应该有一个链表。

而将`弱引用`强制指向 nil ，也是一种无奈的方式，按理说，这依然是个隐患，是代码逻辑的缺陷，只是人家帮你将错误的代价降到最低而已。

总结：

`强引用`的逻辑是--如果都不用了，我就释放掉；

`弱引用`的逻辑是--如果对象释放了，我就置 nil。

strong:
>只要某个对象被任一 strong 指针指向，那么它将不会被销毁。
>如果对象没有被任何 strong 指针指向，那么就将被销毁。
>在默认情况下，所有的实例变量和局部变量都是 strong 类型的。可以说 strong 类型的指针在行为上和 MRC 时代 retain 的 property 是比较相似的。

weak:
>一个常见的例子就是 oc 中常见的 delegate 设计模式，viewController 中有一个 strong 指针指向它所负责管理的 UITableView，而UITableView中的 dataSource 和 delegate 指针都是指向 viewController 的 weak 指针。一旦 viewController 释放掉，dataSource 和 delegate 就置 nil 了

在类似情况下，使用 weak 关键字，是没有意义的:

```
__weak NSString *str = [[NSString alloc] initWithFormat:…]; 
NSLog(@"%@",str); //输出是"(null)"
```

由于对象 str 是 weak，它不会持有 alloc 出来的 NSString 对象.而这个对象，由于没有有效的 strong 指针指向，所以在生成的同时就被销毁了。


## Java 区别

引用计数和垃圾回收

ARC 不同于 java 的垃圾回收，垃圾回收的原理是什么？

基于引用计数与基于trace这两大类别的自动内存管理方式最大的不同之处在于：前者只需要局部信息，而后者需要全局信息。

[引用计数与垃圾收集之比较](https://blog.codingnow.com/2008/06/gc.html)

[](https://www.zhihu.com/question/21539353)

- 标记-清除算法
- 复制算法
- 标记-压缩(Mark-Compact)算法
- 分代 (Generational Collecting)
- 增量算法 (Incremental Collecting)

一个语言是解释型语言，一个语言是编译型。

java 可以利用java虚拟机 JVM ，一次编译，到处运行。

## MRC 

手动引用计数的机理，简单来说，只要遵循以下三点就可以在手动内存管理中避免绝大部分的麻烦：

> 如果需要持有一个对象，那么对其发送 retain. 
> 如果之后不再使用该对象，那么需要对其发送 release（或者autorealse）. 
> 每一次对 retain,alloc 或者 new 的调用，需要对应一次 release 或 autorealse 调用

## autorelease 重点

在 `MRC` 下,我们可以在创建对象的时候给对象发送“autorelease”消息，然后当NSAutoreleasePool 结束的时候，“标记过”autorelease的对象都会被“release”掉，也就是会被释放掉。

```
NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
NSString* str = [[[NSString alloc] initWithString:@"tutuge"] autorelease];
//use str...
[pool release];
//str is released
```

在`ARC`下, 我们甚至可以不需要知道 autorelease 是什么都能管理好内存.但是有的场景，仍然需要你知道 autorelease ,利用它进行优化，在某些情况下，大幅度降低程序的内存占用 。

苹果的官方文档，有对使用 atuorelease 场景的解释：

- If you are writing a program that is not based on a UI framework, such as a command-line tool.
- If you write a loop that creates many temporary objects.
You may use an autorelease pool block inside the loop to dispose of those objects before the next iteration. Using an autorelease pool block in the loop helps to reduce the maximum memory footprint of the application.
- If you spawn a secondary thread.
You must create your own autorelease pool block as soon as the thread begins executing; otherwise, your application will leak objects.

翻译过来：

- 程序不是基于 UI framework, 例如命令行项目
- 循环体中，创建了大量临时对象，你需要在循环体内创建一个autorelease pool block，并且在每次循环结束前，处理 autoreleased 对象. 在循环中使用autorelease pool block可以降低内存峰值
- 你创建了一个新线程，当线程开始执行的时候你必须立马创建一个autorelease pool block, 否则你的应用会造成内存泄露（非Cocoa程序创建线程时才需要）.

看完下来，其实在我们平常 iOS 程序中，就是 循环创建大量临时变量的时候，需要使用 @autoreleasepool 来优化循环就可以了。


## AutoReleasePool

在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的runloop迭代结束时释放的，
而它能够释放的原因是:
>系统在每个runloop迭代中都加入了自动释放池Push和Pop.

官方文档建议，for循环中遍历产生大量autorelease变量时，就需要手加局部AutoreleasePool咯。


## 关键字的区别

- assign vs weak

>assign:
>assign 关键字修饰，不更改引用计数。适用于基本数据类型的修饰。这里要问一个，为什么呢？ 
>assign 修饰对象，造成野指针--assign 其实也可以用来修饰对象。那么我们为什么不用它修饰对象呢？因为被 assign 修饰的对象（一般编译的时候会产生警告：Assigning retained object to unsafe property; object will be released after assignment）在释放之后，指针的地址还是存在的，也就是说指针并没有被置为nil，造成野指针.对象一般分配在堆上的某块内存，如果在后续的内存分配中，刚好分到了这块野指针的地址，程序就会崩溃掉。
> 基础数据类型的内存分配--因为基础数据类型一般分配在`栈`上。栈的内存，会由系统自己自动处理，也就不会造成野指针。所以使用 assign 来修饰基本数据类型。
> weak:
> weak 修饰的对象在 释放 之后，指针地址会被置为nil.跟上面 ARC 里提到概念一样。
>这里就补充一下使用场景:
- 在ARC下,在有可能出现循环引用的时候，往往要通过让其中一端使用weak来解决，比如: delegate代理属性，通常就会声明为weak。
- 自身已经对它进行一次强引用，没有必要再强引用一次时也会使用weak。比如：自定义 IBOutlet控件属性一般也使用weak,当然，也可用 strong

-  __block vs __weak

> __block
>__block是用来修饰一个变量，这个变量就可以在block中被修改。
>使用 __block 修饰的变量在 block 代码块中会被 retain（ARC下会retain，MRC下不会retain）
>retain：属性在赋值的时候，先release之前的值，然后再赋新值给属性，引用计数再加1。
>__weak
>使用 __weak 修饰的变量不会在 block 代码块中被retain。
>例如，在ARC下，要避免block出现循环引用 __weak typedof(self)weakSelf = self;

- copy VS strong

copy 操作，会在内存里拷贝一份对象，原来对象的指针，和 copy 后的新对象指针，分别指向不同的内存地址。

通过 copy ，就可以把 block 从 栈上 拷贝到 堆上，保证block的声明域外使用。

block 使用 copy 是从 MRC 遗留下来的`传统`

> 在ARC环境下，系统底层也会做一次copy操作.使 block 从 栈区 复制一块内存空间到 堆区 .所以strong 和 copy 在对 block 的修饰上,是没有本质区别的

NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary。他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。


## 内存泄漏

内存泄漏是常见情况，有几种会造成。

- 循环引用 

## Xib ／ SB 属性

IBOutlet 连出来的视图属性为什么可以被设置成weak?

参考链接：[ ***Should IBOutlets be strong or weak under ARC?***](http://stackoverflow.com/questions/7678469/should-iboutlets-be-strong-or-weak-under-arc)

文章告诉我们：

> 因为既然有外链那么视图在xib或者storyboard中肯定存在，视图已经对它有一个强引用了。

不过这个回答漏了个重要知识，使用storyboard（xib不行）创建的vc，会有一个叫 _topLevelObjectsToKeepAliveFromStoryboard 的私有数组强引用所有 top level 的对象，所以这时即便outlet声明成weak也没关系

## weak 的实现

weak 变量的自动置 nil？

weak 关键字的作用弱引用，所引用对象的计数器不会加一，并在引用对象被释放的时候自动被设置为 nil.

用一张记录对象的弱引用表，当释放时，根据弱引用表。 key 是对象的内存地址， value 是该对象的所有弱引用的指针数组,把它们置 nil.



# Block

iOS开发中经常会使用block结合gcd来完成多线程编程，block也属于对象，主要有三种类型.

- NSConcreteGlobalBlock 类型

全局静态Block,不访问任何外部变量，不会涉及到任何拷贝

存储在程序的数据区域(text段).

NSGlobalBlock：在block内部没有引用任何外部变量

```
void (^globalBlock) () = ^ () {
      NSLog(@"global block");
};

NSLog(@"%@", globalBlock);
//输出：<__NSGlobalBlock__: 0x1096e20c0>
```

对 NSGlobalBlock 的 retain、copy、release 操作都无效。

它既不在栈中，也不在堆中，我理解为它可能在内存的全局区。

- NSConcreteStackBlock 类型

存储在栈上.

有访问到外部变量的Block,该保存在栈中，当函数返回时被销毁

当栈中的block执行一次之后就被清除出栈了，所以无法多次使用。

- NSConcreteMallocBlock 类型

存储在堆上.

block 通常不会在源码中直接出现，因为默认它是当一个 block 被 copy 的时候，才会将这个 block 复制到堆中.

该类型的Block是由NSConcreteStackBlock 复制到堆中形成的。

## 三种 Block 关系

如果 Block 在记述全局变量的地方被设置或者 Block 没有捕获外部变量，那就生成一个 _NSConcreteGlobalBlock 实例。

其它情况都会生成一个 _NSConcreteStackBlock 实例，也就是说，它是在栈上的，所以一旦它所属的变量超出了变量作用域，该 Block 就被废弃了。

而当发生以下任一情况时：

- 手动调用 Block 的实例方法copy
- Block 作为函数返回值返回
- 将 Block 赋值给附有__strong修饰符的成员变量
- 在方法名中含有usingBlock的 Cocoa 框架方法或 GCD 的 API 中传递 Block

如果此时 Block 在栈上，那就复制一份到堆上，并将复制得到的 Block 实例的isa指针设为 _NSConcreteMallocBlock。

此时 Block 已经在堆上，那就把该 Block 的引用计数加1

## 为什么把 Block 从栈复制到堆中 

Block的内存地址显示在栈区,栈区的特点就是创建的对象随时可能被销毁,一旦被销毁后续再次调用空对象就可能会造成程序崩溃,在对block进行copy后,block存放在堆区,就由程序本身进行引用计数的管理。

## block 关键字修饰

block 变量,定义时的关键字修饰

block 本身是像对象一样可以retain，和release。

block在创建的时候，它的内存是分配在`栈(stack)`上，由系统自行处理，可能被随时回收，而不是在`堆(heap)`上。作于域是属于创建时候的作用域，一旦在创建时候的作用域，被外面调用 block 将导致程序崩溃。

## Block 循环引用

当block获取到外部变量时，由于编译器无法预测获取到的变量何时会被突然释放，为了保证程序能够正确运行，让block持有获取到的变量。

这就可能造成循环引用的问题。

主要思路，就是打破引用链，可以通过三种方法：
第一个，调用完 Block 后就将它置空
第二个，对于引用的对象，作为 weak 处理
第三个，对于引用的对象使用后置空

weak-strong dance:

strong 延长捕获对象的生命周期，一旦 Block 执行完，对象被释放，而 Block 也会被释放.

# 多线程

## Pthreads

>POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用Pthreads作为操作系统的线程。

## NSThread

## GCD

>串行队列，并行队列

>同步提交，异步提交
  
为什么说 GCD 死锁是队列导致的而不是线程，死锁不是操作系统的概念么？

GCD队列种类：
- dispatch_get_main_queue（主队列）串行队列.
- dispatch_get_global_queue(全局队列) 并发队列 子线程执行，
- dispatch_queue_create（用户队列）串并都可以，子线程执行.
  
主要的死锁就是当前串行队列里面同步执行当前串行队列。解决的方法就是将同步的串行队列放到另外一个线程执行。
  
GCD 实现原理

队列其实就是一个用来提交 block 的对象，当 block 提交到队列中后，将按照 “先入先出(FIFO)” 的顺序进行处理。系统在 GCD 的底层会维护一个线程池，用来执行这些 block。

dispatch_async，队列中保存了一个链表，我们首先将新的 block 添加到链表尾部，然后调用 dx_probe 宏，它依赖于 vtable 数据结构，GCD 中的大部分对象，比如队列等，都具有这个数据结构。它定义了对象在不同操作下该执行的方法，比如在这里(dispatch_async)的 probe 操作下，实际上会执行 _dispatch_queue_wakeup_global 方法.-》 pthread 线程.
dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调里执行这个 block。

dispatch_sync ，利用了线程专属信号量，保证了每次只有一个 block 被执行。这条调用栈有多个分支，如果向当前串行队列提交任务就会走到上述分支，导致死锁。如果是向其它串行队列提交 block，则会利用原子性操作来实现，因此不会有死锁问题。

dispatch_semaphore

dispatch_group

### GCD里面有哪几种Queue？

两种queue，串行和并行。main queue是串行，global queue是并行。有些开发者为了在工作线程串行的处理任务会自己建立一个serial queue。背后是苹果维护的线程池，各种queue要用线程都是这个池子里取的。GCD大家都用过，但很多关键的概念不少人都理解的模凌两可。串行，并行，同步，异步是GCD的核心概念。

- 你自己建立过串行queue吗？背后的线程模型是什么样的？

## NSOperation & NSOperationQueue

> NSOperation 是苹果公司对 GCD 的封装，完全面向对象，所以使用起来更好理解。 大家可以看到 NSOperation 和 NSOperationQueue 分别对应 GCD 的 任务 和 队列 。操作步骤也很好理解：
>将要执行的任务封装到一个 NSOperation 对象中。
>将此任务添加到一个 NSOperationQueue 对象中。

## 几种多线程方式对比

## 使用 atomic 一定是线程安全吗

## 线程安全的概念

多条线程同时工作的情况下,通过运用线程锁,原子性等方法避免多条线程因为同时访问同一快内存造成的数据错误或冲突.



## 多线程不安全的原因

每条线程都有自己独立的栈空间. 但是他们公用了堆. 所以他们可能同时访问同一块内存空间. 因此造成数据冲突.

----

atomic 通过 property 的方式使用才能保证安全，还有人知道这个用来做多线程安全会有性能损耗。

当使用atomic时，虽然对属性的读和写是原子性的，但是仍然可能出现线程错误：当线程A进行写操作，这时其他线程的读或者写操作会因为该操作而等待。当A线程的写操作结束后，B线程进行写操作，然后当A线程需要读操作时，却获得了在B线程中的值，这就破坏了线程安全.如果有线程C在A线程读操作前release了该属性，那么还会导致程序崩溃。

>atomic所说的线程安全,只是保证了getter和setter存取方法的线程安全，并不能保证整个对象是线程安全的。

如：

```
@property(atomic,strong) NSMutableArray *arr;
```

如果一个线程循环的读数据，一个线程循环写数据，那么肯定会产生内存问题，因为这和setter、getter没有关系。如使用[self.arr objectAtIndex:index]就不是线程安全的。好的解决方案就是加锁。

好的解决方案就是加锁。据说，atomic要比nonatomic慢大约20倍

## 锁


Objective-C中几种不同方式实现的锁

atomic,synchronized,NSLock,pthread mutex,OSSpinLock的差别

- NSLock

- @synchronized

- 自旋锁

## iOS 死锁 

- 死锁的原因

- 具体哪些操作会引发死锁

# Runloop

- Runloop 非 iOS 独有，其它平台如 JS 也有，叫做 Event Loop. 有它的原因，就是提高单线程的运行效率，把事件 Event 放进队列里。

- 异步操作就可以通过 Event Loop 和 轮巡 两种方式，一种是等待完成发消息，一种是不断的查看。


- NSRunLoop 和 CFRunLoopRef:
CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。
NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。

- 线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。但是线程和Runloop可能也是1对0，因为只有在主线程中，我们的iOS程序帮助我们开启了 RunLoop。而在我们自己定义或系统帮我们开启的子线程中，如果我们不显式的“创建” RunLoop ,我们的子线程就没有Runloop,用完就会销毁了。

- 线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。

- RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。获取方法:CFRunLoopGetMain() 和 CFRunLoopGetCurrent()

- 主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。
  这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。

- 一个 Runloop 可以有多个 Mode.  而 Mode 是一个数组，里面有 Observe/Timer/Source 等不同类型的事件。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。

- Observe/Timer/Source  统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。

- CFRunLoopSourceRef -- 是事件产生的地方。Source有两个版本：Source0 和 Source1。 Source0 只包含了一个回调（函数指针），它并不能主动触发事件。Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source1 能主动唤醒 RunLoop 的线程。

- CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。

- CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观察到时间点，有以下几个:

```objc
    kCFRunLoopEntry         = (1UL << 0), // 即将进入Loop
    kCFRunLoopBeforeTimers  = (1UL << 1), // 即将处理 Timer
    kCFRunLoopBeforeSources = (1UL << 2), // 即将处理 Source
    kCFRunLoopBeforeWaiting = (1UL << 5), // 即将进入休眠
    kCFRunLoopAfterWaiting  = (1UL << 6), // 刚从休眠中唤醒
    kCFRunLoopExit          = (1UL << 7), // 即将退出Loop
```
 
 - CommonModes: 一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中, 例如 @"AFNMode" 放到数组里）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 commonModeItems 数组里的 Source/Observer/Timer 同步到 CommonModes 内的所有 Mode 里。
 
 [深入理解Runloop](https://blog.ibireme.com/2015/05/18/runloop/)
 
 - Runloop 过程:
 
 ```objc
 /// RunLoop的实现
int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) {
    
    /// 首先根据modeName找到对应mode
    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);
    /// 如果mode里没有source/timer/observer, 直接返回。
    if (__CFRunLoopModeIsEmpty(currentMode)) return;
    
    /// 1. 通知 Observers: RunLoop 即将进入 loop。
    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);
    
    /// 内部函数，进入loop
    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) {
        
        Boolean sourceHandledThisLoop = NO;
        int retVal = 0;
        do {
 
            /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。
            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);
            /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。
            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);
            /// 执行被加入的block
            __CFRunLoopDoBlocks(runloop, currentMode);
            
            /// 4. RunLoop 触发 Source0 (非port) 回调。
            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);
            /// 执行被加入的block
            __CFRunLoopDoBlocks(runloop, currentMode);
 
            /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。
            if (__Source0DidDispatchPortLastTime) {
                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &msg)
                if (hasMsg) goto handle_msg;
            }
            
            /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。
            if (!sourceHandledThisLoop) {
                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);
            }
            
            /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。
            /// • 一个基于 port 的Source 的事件。
            /// • 一个 Timer 到时间了
            /// • RunLoop 自身的超时时间到了
            /// • 被其他什么调用者手动唤醒
            __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort) {
                mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg
            }
 
            /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。
            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);
            
            /// 收到消息，处理消息。
            handle_msg:
 
            /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。
            if (msg_is_timer) {
                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())
            } 
 
            /// 9.2 如果有dispatch到main_queue的block，执行block。
            else if (msg_is_dispatch) {
                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);
            } 
 
            /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件
            else {
                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);
                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);
                if (sourceHandledThisLoop) {
                    mach_msg(reply, MACH_SEND_MSG, reply);
                }
            }
            
            /// 执行加入到Loop的block
            __CFRunLoopDoBlocks(runloop, currentMode);
            
 
            if (sourceHandledThisLoop && stopAfterHandle) {
                /// 进入loop时参数说处理完事件就返回。
                retVal = kCFRunLoopRunHandledSource;
            } else if (timeout) {
                /// 超出传入参数标记的超时时间了
                retVal = kCFRunLoopRunTimedOut;
            } else if (__CFRunLoopIsStopped(runloop)) {
                /// 被外部调用者强制停止了
                retVal = kCFRunLoopRunStopped;
            } else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) {
                /// source/timer/observer一个都没有了
                retVal = kCFRunLoopRunFinished;
            }
            
            /// 如果没超时，mode里没空，loop也没被停止，那继续loop。
        } while (retVal == 0);
    }
    
    /// 10. 通知 Observers: RunLoop 即将退出。
    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);
}
 ```
 
 
1. Observer:即将进入Loop,
2. Observer:即将处理Timer,
3. Observer:即将处理Source0,
4. 处理Source0
5. 如果有 Source1，直接处理。（ 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。）
6. Observer:即将进入休眠,
7. 休眠，等待唤醒（Source1 port ，Timer,手动唤醒），重点，ibireme 文章Source0错误
8. Observer:刚从休眠中唤醒,

9. 处理消息:处理唤醒时，刚收到的消息（Timer,Source1）,跳回第2步:
如果一个 Timer 到时间了，触发这个Timer的回调
如果有dispatch到main_queue的block，执行block。
如果一个 Source1 (基于port) 发出事件了，处理这个事件
10. Observer:即将退出Loop,
 
 
 系统 Runloop 应用。
 
- AutoreleasePool

App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。

第一个 Observer 监视的事件是 Entry(即将进入Loop) - 会调用 _objc_autoreleasePoolPush() 创建自动释放池。
优先级最高，保证创建释放池发生在其他所有回调之前。

第二个 Observer 监视了两个事件： 
BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。优先级最低，保证其释放池子发生在其他所有回调之后。

在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了

- 事件触发

1. 屏幕硬件，感应到触摸，传递到 IOKit. IOKit.framework 封装整个触摸事件为 IOHIDEvent 对象 。 
2. IOKit 通过 mach port (IPC进程间通信) 将事件转发给 SpringBoard.app , 随后用 mach port 转发给需要的App进程.
3. 主线程 Runloop 收到转发来的消息苏醒，并触发对应 Mach Port 的 Source1 回调__IOHIDEventSystemClientQueueCallback() 。
4. Source1 的回调内部，触发 Source0 的回调 __UIApplicationHandleEventQueue() ,把 IOHIDEvent 封装为 UIEvent .

- performSelecter

当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。

项目工程 runloop 应用：

- FDTemplateCell 利用 runloop 在空闲时加载数据 , 马上要休眠时(default mode).
- AFN 线程保活
- ASDK 后台


# Runtime 

Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理

Runtime基本上是用C和汇编写的，这个库使得C语言有了面向对象的能力。是 Objective-C 面向对象和动态机制的基石。

在Runtime中，对象可以用C语言中的结构体表示，而方法可以用C函数来实现，另外再加上了一些额外的特性。

当程序执行[object doSomething]时，会向消息接收者(object)发送一条消息(doSomething)，runtime会根据消息接收者`是否能响应该消息`而做出`不同的反应`。

## Runtime 数据结构

## 对象的结构 重点

```
struct objc_class {

    Class isa  OBJC_ISA_AVAILABILITY;

#if !__OBJC2__

    Class super_class                                        OBJC2_UNAVAILABLE;

    const char *name                                         OBJC2_UNAVAILABLE;

    long version                                             OBJC2_UNAVAILABLE;

    long info                                                OBJC2_UNAVAILABLE;

    long instance_size                                       OBJC2_UNAVAILABLE;

    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;

    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;

    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;

    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;

#endif

} OBJC2_UNAVAILABLE;
```

## 发送的过程

下面详细叙述下消息发送步骤：

1.检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 retain, release 这些函数了。
2.检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉。
3.如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了找得到就跳到对应的函数去执行。
4.如果 cache 找不到就找一下方法分发表。
5.如果分发表找不到就到超类的分发表去找，一直找，直到找到NSObject类为止。
6.如果还找不到就要开始进入动态方法解析了，后面会提到。

## weak 实现

weak 表的作用是在对象执行 dealloc 的时候将所有指向该对象的 weak 指针的值设为 nil，避免悬空指针。这是 weak 表的结构：

struct weak_table_t {
    weak_entry_t *weak_entries;
    size_t    num_entries;
    uintptr_t mask;
    uintptr_t max_hash_displacement;
};
苹果使用一个全局的 weak 表来保存所有的 weak 引用。并将对象作为键，weak_entry_t 作为值。weak_entry_t 中保存了所有指向该对象的 weak 指针。

[dealloc 实现](https://github.com/liberalisman/iOS-InterviewQuestion-collection/blob/master/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/22.%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E9%A2%98.md)

strong 实现

## OC 和 C 语言的对比

> C：
>在很多语言，比如 C ，调用一个方法其实就是跳到内存中的某一点并开始执行一段代码。没有任何动态的特性，因为这在编译时就决定好了。

> OC ：
>而在 Objective-C 中，[object foo] 语法并不会立即执行 foo 这个方法的代码。它是在运行时给 object 发送一条叫 foo 的消息。这个消息，也许会由 object 来处理，也许会被转发给另一个对象，或者不予理睬假装没收到这个消息。

## 消息机制

## 动态得创建类和对象

## 进行消息传递和转发

消息传递的关键藏于 objc_object 中的 isa 指针和 objc_class 中的 class dispatch table。

## JSPatch 实现原理

直接看 [JSPatch 实现原理详解](https://github.com/bang590/JSPatch/wiki/JSPatch-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3)


# UIKit

## 响应链

## 传递链

## UIView 和 CALayer 关系

能说出 UIView 主要处理事件，CALayer 负责绘制

- UIView：

在 View显示的时候，UIView 做为 Layer 的 CALayerDelegate,View 的显示内容由内部的 CALayer 的 display

- layer ：

和UIView最大的不同是CALayer不处理用户的交互。

layer 内部维护着三分 layer tree(图层树),分别是 presentLayer Tree(动画树),modeLayer Tree(模型树), Render Tree (渲染树),在做 iOS动画的时候，我们修改动画的属性，在动画的其实是 Layer 的 presentLayer的属性值,而最终展示在界面上的其实是提供 View的 modelLayer

## 取消隐式动画

* 每一个UIView内部都默认关联着一个CALayer，我们可用称这个Layer为Root Layer（根层）

* 所有的非Root Layer，也就是手动创建的CALayer对象，都存在着隐式动画

* 什么是隐式动画？

    * 当对非Root Layer的部分属性进行修改时，默认会自动产生一些动画效果
    * 而这些属性称为Animatable Properties(可动画属性)


可以通过动画事务(CATransaction)关闭默认的隐式动画效果

```
 [CATransaction begin];
 [CATransaction setDisableActions:YES];
 self.myview.layer.position = CGPointMake(10, 10);
 [CATransaction commit];
```

事务（transaction）：

隐式动画中有一个「事务」的概念。

事务（transaction）实际上是Core Animation用来包含一系列属性动画集合的机制，用指定事务去改变可以做动画的图层属性，不会立刻发生变化，而是提交事务时用一个动画过渡到新值。
Core Animation中的事务通过CATransaction类来做管理，这个类有些奇怪，它没有属性或实例方法，并且也不能创建实例，但可以用类方法begin()或commit()分别来入栈或出栈。



## UIImageView加圆角

离屏渲染并非由设置圆角导致的。

```
 view.layer.cornerRadius = 5
```

无影响

```
 view.layer.cornerRadius = 5
 view.layer.masksToBounds = true
```

有影响

解决办法：

利用 Core Graphics 自己画出了一个圆角矩形。除了一些必要的代码外，最核心的就是 CGContextAddArcToPoint 函数。它中间的四个参数表示曲线的起点和终点坐标，最后一个参数表示半径。调用了四次函数后，就可以画出圆角矩形。最后再从当前的绘图上下文中获取图片并返回。

### 离屏渲染

OpenGL 中，GPU 屏幕渲染有以下两种方式：

* On-Screen Rendering 意为当前屏幕渲染，指的是 GPU 的渲染操作是在当前用于显示的屏幕缓冲区中进行。

* Off-Screen Rendering 意为离屏渲染，指的是 GPU 在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。

相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面：

* 创建新缓冲区 要想进行离屏渲染，首先要创建一个新的缓冲区。

* 上下文切换 离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。

所以在图形生成的步骤我们要尽可能的避免离屏渲染，或者开启 *shouldRasterize* 属性。

# 音视频

- 音频

- 视频

## 直播

- GOP ：
 I 帧：I帧表示关键帧。你可以理解为这一帧画面的完整保留；解码时只需要本帧数据就可以完成。（因为包含完整画面）
 B 帧：B帧是双向差别帧。B帧记录的是本帧与前后帧的差别（具体比较复杂，有4种情况）。换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。

B帧压缩率高，但是编解码时会比较耗费CPU，而且在直播中可能会增加直播延时，因此在移动端上一般不使用B帧。
 P 帧：P帧表示这一帧跟之前的一个关键帧（或P帧）的差别。解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）
 
- 直播协议

# 图像处理 OpenGL ES

OpenGL都用三角形来绘图

假设当我们想告诉OpenGL去画线段而不是三角形的时候，我们通过改变一些上下文变量来改变OpenGL状态，从而告诉OpenGL如何去绘图。一旦我们改变了OpenGL的状态为绘制线段，下一个绘制命令就会画出线段而不是三角形。

GPU 需要知道内存中的哪个位置来存储渲染出来的 2D 图像像素数据，接收渲染结果的缓冲区称为 帧缓冲区 (frame buffer) 。渲染指令会在适当的时候替换帧缓冲区中的内容，OpenGL ES 会根据特定平台硬件配置和功能设置数据类型和偏移。通常来说，渲染结果可以存储到任意数量的 frame buffer 中。上面提到的双缓冲的两个缓冲称之为 前帧缓冲区 (front frame buffer) 和 后帧缓冲区 (back frame buffer) 。

在 OpenGL ES 中，所有的图像都可以由点，线段和三角形构成，所以 OpenGL ES 只渲染这三种图形。在接收到一些顶点数据后，经过顶点着色器 (vertex shader) 处理，装配输出给片元着色器 (fragment shader) ,再经过一些操作最终输出给帧缓冲区。什么是片元呢？通常在顶点着色器输出几何图形数据后，会进行光栅化 (rasterizing) 将这些形状数据转换为帧缓存中的颜色像素，而每一个颜色像素就叫做片元 (fragment) 。

## GLKView

## 坐标系

OpenGLES的世界坐标系是[-1, 1]，故而点(0, 0)是在屏幕的正中间。

纹理坐标系的取值范围是[0, 1]，原点是在左下角。故而点(0, 0)在左下角，点(1, 1)在右上角

## 绘制单位

## 图片大小计算

60*60 的


# 通知

- 如何实现通知的自动移除？
Swizzle Method 在 dealloc 移除.[[NSNotificationCenter defaultCenter] removeObserver:self]

- 如何实现一个通知中心？

  单例保证全局唯一，字典根据 key 找到对象，还有方法。

# 网络

## http的post和get啥区别

post比 get ，安全一点点。。。。并非主要。

最显著的，是post 有body。

如果希望缓存或者大量访问的，用 get 可以大大减轻服务器的压力。

如果有敏感的操作，如 删除日志 等等，用post ,不可以直接被输入。

安全方面，该用 https 还是用 https 

ssl pining?

## OSI 网络模型 

分层有几种分法, OSI 七层 :

- 应用层
- 表示层
- 会话层
- 传输层
- 网络层
- 链路层
- 物理层

七层模型中，表示层和会话层是没有对应协议在里面的

TCP/IP 四层 ，TCP/IP网络协议栈四层分为：

- 应用层（Application）:FTP SMTP HTTP ... 
- 传输层（Transport）:TCP UDP 
- 网络层（Network）:IP ICMP ARP 
- 链路层（Link）:以太网 令牌环 FDDI ...

包含了一系列构成互联网基础的网络协议。
这些协议最早发源于美国国防部的 DARPA 互联网项目。
TCP/IP 字面上代表了两个协议:TCP 传输控制协议和 IP 互联网协议。 

五层： 基于 TCP/IP 加了一个物理层

[网络分层](http://www.ha97.com/3215.html)

## TCP 连接

- 三次握手：

C->S: syn,
S->C: syn ack,
C->S: ack

如果少一次握手，会有什么问题?

少了一次就建立连接，那么超时请求过来，就又将开启连接，浪费资源。这时候对于 S 回来的信息，C已经关闭，没有请求新的连接，会无视S这一次的ACK、Seq和ACK number。而对S来讲，连接已经建立了，其为此次连接分配的资源会一直等待下去

- TCP 四次挥手：

C->S : FIN,准备关闭
S->C : ACK.知道.

C 进入 FIN_WAIT 状态

S->C : FIN.可以关闭了.
C->S : ACK,好的

C 进入 TIME_WAIT 状态一小段时间，如果Server端没有收到ACK则可以重传。时间过后，进行关闭。



## htpps 加密

https 不是一个协议，是 http + ssl. ssl 为应用层的

## SS

- 大体原理 [ss源码解析](https://loggerhead.me/posts/shadowsocks-yuan-ma-fen-xi-xie-yi-yu-jie-gou.html#socks5)

### SockS5协议 (socketS缩写)

SOCKS5实际上是一个传输层／会话层的代理协议。象一个代理一样对客户端到服务器端或服务器和服务器之间的数据联系提供安全上的服务。只是简单地传递数据包，而不必关心是何种应用协议(比如FTP、HTTP和NNTP请求)

握手阶段：

客户端发送消息。
VER 字段是当前协议的版本号，也就是 5；
NMETHODS 字段是 METHODS 字段占用的字节数；
METHODS 字段的每一个字节表示一种认证方式，表示客户端支持的全部认证方式。

服务端回应客户端:
VER ：版本号。
METHOD： 检查自己支持的认证方法后，给出一个认证方式。

返回给客户端的值只有两种可能：

* `0x05 0x00`：告诉客户端采用无认证的方式建立连接；
* `0x05 0xff`：客户端的任意一种认证方式服务器都不支持。 

建立连接：

客户端会向服务器发起请求，请求的格式如下：

+----+-----+-------+------+----------+----------+
|VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
+----+-----+-------+------+----------+----------+
| 1  |  1  |   1   |  1   | Variable |    2     |
+----+-----+-------+------+----------+----------+

* `CMD` 字段：`command` 的缩写，shadowsocks 只用到了：
    * `0x01`：建立 TCP 连接
    * `0x03`：关联 UDP 请求
* `RSV` 字段：保留字段，值为 `0x00`；
* `ATYP` 字段：`address type` 的缩写，取值为：
    * `0x01`：IPv4
    * `0x03`：域名
    * `0x04`：IPv6
* `DST.ADDR` 字段：`destination address` 的缩写，取值随 `ATYP` 变化：
    * `ATYP == 0x01`：4 个字节的 IPv4 地址
    * `ATYP == 0x03`：1 个字节表示域名长度，紧随其后的是对应的域名
    * `ATYP == 0x04`：16 个字节的 IPv6 地址
* `DST.PORT` 字段：目的服务器的端口。

在收到客户端的请求后，服务器会返回如下格式的消息：

+----+-----+-------+------+----------+----------+
|VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
+----+-----+-------+------+----------+----------+
| 1  |  1  |   1   |  1   | Variable |    2     |
+----+-----+-------+------+----------+----------+


* `REP` 字段：用以告知客户端请求处理情况。在请求处理成功的情况下，shadowsocks 将这个字段的值设为 `0x00`，否则，shadowsocks 会直接断开连接；
* 其它字段和请求中字段的取值类型一样。


服务端采用了 eventloop 机制，单线程下表现好。考虑了路由器上的部署。使用 IO 复用，而不是多线程的方式，是因为前者能提供更好的性能和更少的内存开销

## Socket

SOCKET 应该算不上是个协议，应该是应用层与传输层间的一个抽象层，是个编程接口。

## WebSocket协议

WebSocket是HTML5出的东西（协议），也就是说HTTP协议没有变化，或者说没关系，但HTTP是不支持持久连接的（长连接，循环连接的不算）。它是实现了浏览器与服务器全双工通信(full-duplex)。应用层协议。

现很多网站为了实现即时通讯，所用的技术都是轮询(polling)。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP request，然后由服务器返回最新的数据给客服端的浏览器。这种传统的HTTP request 的模式带来很明显的缺点 – 浏览器需要不断的向服务器发出请求，然而HTTP request 的header是非常长的，里面包含的数据可能只是一个很小的值，这样会占用很多的带宽。

而最比较新的技术去做轮询的效果是Comet – 用了AJAX。但这种技术虽然可达到全双工通信，但依然需要发出请求。

在 WebSocket API，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送，改变了原有的B/S模式。

WebSocket的目的就是解决网络传输中的双向通信的问题，HTTP1.1默认使用持久连接（persistent connection），在一个TCP连接上也可以传输多个Request/Response消息对，但是HTTP的基本模型还是一个Request对应一个Response。

双向通信一般由三种: 
- 轮询，间隔时间请求一次
- 长轮询，建立一个超时时间很久的连接，服务器hold住这个连接，在有新数据到达时返回Response，相比#1，占用的网络带宽少了，其他类似。
- 长连接，其实有些人对长连接的概念是模糊不清的，我这里讲的其实是HTTP的长连接（1）。如果你使用Socket来建立TCP的长连接（2），那么，这个长连接（2）跟我们这里要讨论的WebSocket是一样的，实际上TCP长连接就是WebSocket的基础，但是如果是HTTP的长连接，本质上还是Request/Response消息对


## iOS 的 HTTP 缓存策略

- NSURLRequestUseProtocolCachePolicy
- NSURLRequestReturnCacheDataElseLoad
- NSURLRequestReturnCacheDataDontLoad

关于网络请求
iOS 中，关于网络请求的接口自下至上有如下几层:

## iOS 中的网络请求

由下到上:

```
CFSocket
CFNetwork       ->ASIHttpRequest
NSURLConnection ->AFNetworking
NSURLSession    ->AFNetworking2, Alamofire
```

## 移动端网络优化

DNS ： 取消 Domain, IP 直连， 使用 IP 表映射。 HTTPDNS 客户端直接访问HttpDNS接口，获取业务在域名配置管理系统上配置的访问延迟最优的IP.

连接 ： 不要每次请求都重新建立连接，复用连接或一直使用同一条连接(长连接)。
HTTP2这里是连接的多路复用，网络相关的还有一个I/O的多路复用(select/epoll)，指通过事件驱动的方式让多个网络请求返回的数据在同一条线程里完成读写。
客户端来说，iOS9 以上 NSURLSession 原生支持 HTTP2，只要服务端也支持就可以直接使用
QUIC 进一步解决 TCP 队头阻塞。

数据大小 : 压缩数据，减小传输的数据大小, ProtocolBuffer。

# 架构/编程方式

## 函数式编程 

无状态

## MVVM

# 设计模式

[iOS 中的 21 种设计模式](https://www.jianshu.com/p/6b302c7fe987)

单例，委托，观察者

类簇，mediator

# 算法／数据结构

## 时间复杂度

冒泡 O( n^2 )

快排 ：O( n log n ) 

二叉查找树 ： O( log 2^n )

## 空间复杂度

## 稳定性

## LRU 算法

## 哈希表

[字典时间复杂度 O1 数组 On](https://www.cnblogs.com/fcug/p/6279621.html)

- 构造方法 
直接定址法 a*k+b,当关键字基本连续时用这种方法十分方便，若关键字不连续的话将造成内存单元大量浪费。
除留余数法 k%b,计算比较简单，适用范围广，是最经常使用的一种哈希函数。
伪随机数法 h(k) = random(k);
平方取中法 可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。


- 哈希碰撞
字典时间复杂度 O(1)-O(n),空间换时间。

哈希表还有一个重要的属性: 负载因子(load factor)，它用来衡量哈希表的空/满程度，一定程度上也可以体现查询的效率，计算公式为:

负载因子 = 总键值对数 / 箱子个数

负载因子越大，意味着哈希表越满，越容易导致冲突，性能也就越低。因此，一般来说，当负载因子大于某个常数(可能是 1，或者 0.75 等)时，哈希表将自动扩容。

使用 拉链法 和 开发寻址法，进行扩容处理冲突。

拉链法: 所有哈希地址为i的元素构成一个同义词链表。链地址法适用于经常插入删除的情况，其中查找、插入和删除操作主要在同义词链中进行。

二次哈希，这种方法不易产生聚集，但增加了计算时间。

## 快速排序

[快速排序](https://blog.csdn.net/morewindows/article/details/6684558)

快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。

## 插入排序

[常见排序](https://www.jianshu.com/p/f6f2cab72025)

## 堆排序

[堆排序](https://blog.csdn.net/morewindows/article/details/6709644)

堆排序与快速排序，归并排序一样都是时间复杂度为O(N*logN)的几种常见排序方法。学习堆排序前，先讲解下什么是数据结构中的二叉堆。

### 二叉堆的定义

二叉堆是完全二叉树或者是近似完全二叉树。

二叉堆满足二个特性：

1．父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值。

2．每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。

当父结点的键值总是大于或等于任何一个子节点的键值时为最大堆。当父结点的键值总是小于或等于任何一个子节点的键值时为最小堆。下图展示一个最小堆：

### 堆的存储

一般都用数组来表示堆，i结点的父结点下标就为(i – 1) / 2。它的左右子结点下标分别为2 * i + 1和2 * i + 2。如第0个结点左右子结点下标分别为1和2。

### 堆的操作，排序

首先可以看到堆建好之后堆中第0个数据是堆中最小的数据。取出这个数据再执行下堆的删除操作。这样堆中第0个数据又是堆中最小的数据，重复上述步骤直至堆中只有一个数据时就直接取出这个数据。

## 归并排序

[归并](https://blog.csdn.net/morewindows/article/details/6678165)

归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。

递归的分解数列。

首先考虑下如何将将二个有序数列合并。这个非常简单，只要从比较二个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。

归并排序的效率是比较高的，设数列长为N，将数列分开成小数列一共要logN步，每步都是一个合并有序数列的过程，时间复杂度可以记为O(N)，故一共为O(N*logN)。

因为归并排序每次都是在相邻的数据中进行操作，所以归并排序在O(N*logN)的几种排序方法（快速排序，归并排序，希尔排序，堆排序）也是效率比较高的。

## C 语言

数组

int a[5]={1.2.3.4.5}
int *p  = int *(&a+1)

printf ( a+1,p-1) 输出: 2,5

&a 和 a 一样，为 a[0] 的值和地址。 a+1 取到a[1]。
(&a+1) 取到整个a数组的后面一位，p指针是指向了a[4]后的那个地址，而p本身的地址是在栈中分配的。p-1 相当于 a[4]

[](https://blog.csdn.net/eastmoon502136/article/details/8630790)
[](https://www.cnblogs.com/ccdev/archive/2012/09/11/2680334.html)

指针

链表操作

排序算法

# 持久化方案

- Plist文件

- NSUserDefaults

- NSKeyedArchiver 归档

- SQLite3

- CoreData


# iOS 里的缓存

- URLCache

URLCache 提供了内存和硬盘缓存的综合缓存机制，能够控制内存和硬盘缓存的大小，并且可以控制缓存数据的存储路径。

网络缓存减少了需要向服务器发送请求的次数，同时也提升了离线或在低速网络中使用应用的体验。如果系统遇到硬盘/内存空间太小的情况，系统也会主动清除一些硬盘/内存缓存的。设置一个全局 URLCache 可以有效的减轻服务端压力。

- Cache

cache的另一个重要知识点是cache的淘汰策略，不同的策略表现也不一样，FIFO，LRU，2Queues等等，现在有不少成熟的第三方cache框架可以使用，系统也提供了淘汰策略不明确的NSCache，如果没有动手写过任何cache淘汰策略，我还是建议大家自己动手试着做一个，至少要读一下相关的实现源码，了解这些淘汰策略很有必要，在做一些深度优化的时候需要因地制宜来做决定。

- 内存缓存

- 磁盘缓存


# 开源作品

## FlexBox

性能差异

语法优势

动态下发

跨平台

## 人脸识别，换背景 

# JavascriptCore

- JSContext 是 JS 执行上下文，你可以把它理解为 JS 运行的环境。
- JSValue 是对 JavaScript 值的引用，任何 JS 中的值都可以被包装为一个 JSValue。
- JSManagedValue 是对 JSValue 的包装，加入了“conditional retain”。
- JSVirtualMachine 表示 JavaScript 执行的独立环境.关于 JSVirtualMachine 的使用，一般情况下我们不用手动去创建 JSVirtualMachine。因为当我们获取 JSContext 时，获取到的 JSContext 从属于一个 JSVirtualMachine。

JSExport 协议：
实现将 Objective-C 类及其实例方法，类方法和属性导出为 JavaScript 代码的协议。


让 JSContext 访问我们的本地客户端代码的方式主要有两种：block 和 JSExport 协议.

# 源码阅读

## AFN

AFN 常驻线程保活: Runloop 添加，保持线程。不需要时休眠，线程不退出。

为什么需要线程保活?

Gcd group 多个异步请求任务同步返回。

## SDWebImage

一个异步下载图片并且支持缓存的 UIImageView 分类.

SDWebImage 中为 UIView 提供了一个分类叫做 WebCache, 这个分类中有一个最常用的接口, sd_setImageWithURL:placeholderImage:, 这个分类同时提供了很多类似的方法, 这些方法最终会调用一个同时具有 option progressBlock completionBlock 的方法, 而在这个类最终被调用的方法首先会检查是否传入了 placeholderImage 以及对应的参数, 并设置 placeholderImage.

然后会获取 SDWebImageManager 中的单例调用一个 downloadImageWithURL:... 的方法来获取图片, 而这个 manager 获取图片的过程有大体上分为两部分, 它首先会在 SDWebImageCache 中寻找图片是否有对应的缓存, 它会以 url 作为数据的索引先在内存中寻找是否有对应的缓存, 如果缓存未命中就会在磁盘中利用 MD5 处理过的 key 来继续查询对应的数据, 如果找到了, 就会把磁盘中的缓存备份到内存中.

然而, 假设我们在内存和磁盘缓存中都没有命中, 那么 manager 就会调用它持有的一个 SDWebImageDownloader 对象的方法 downloadImageWithURL:... 来下载图片, 这个方法会在执行的过程中调用另一个方法 addProgressCallback:andCompletedBlock:fotURL:createCallback: 来存储下载过程中和下载完成的回调, 当回调块是第一次添加的时候, 方法会实例化一个 NSMutableURLRequest 和 SDWebImageDownloaderOperation, 并将后者加入 downloader 持有的下载队列开始图片的异步下载.

而在图片下载完成之后, 就会在主线程设置 image, 完成整个图像的异步下载和配置.

## Masonry

链式调用，都会返回一个 MASConstraint 的实例。

mas_makeConstraint, 这个方法接受了一个 block, 这个 block 有一个 MASConstraintMaker 类型的参数, 这个 maker 会持有一个约束的数组, 这里保存着所有将被加入到视图中的约束.

配置结束后, 首先会调用 maker 的 install 方法, 而这个 maker 的 install 方法会遍历其持有的约束数组, 对其中的每一个约束发送 install 消息. 在这里就会使用到在上一步中配置的属性, 初始化 NSLayoutConstraint 的子类 MASLayoutConstraint 并添加到合适的视图上.

Block 不循环引用 ，因为 block 没有被self持有,用完自动释放了。

equalTo() 方法，对 @80，view，view.mas_right 等变量进行兼容判断

## YYKit

### YYCache 项目

## Aspects

实例方法，子类化调用

## JSPatch

JS->OC , JSCore 通过 JSContext 对 JS 脚本中的函数等进行 block 操作和定义。例如 defineclass 等函数。
JSPatch.js 中事先定义了一些 JS 方法，以便于传值到 OC 。例如global.defineClass = function(declaration, instMethods,     
clsMethods) . 

OC内处理，在 JSContext 关联的 Block 中，调用 OC 方法，对传进来的 类名，方法名进行处理:

runtime 注册和修改类 ，交换方法和添加方法 ORIGforwardInvocation 指向原始的实现IMP。替代方法走 objc_msgForward 转发，类的 forwardInvocation: 方法的实现被替换为JPForwardInvocation的实现，然后在转发方法里进行操作。


## AsyncDisplayKit

UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。

排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。
绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。
UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。

其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。

ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。

_ASAsyncTransactionGroup

## MLeaksFinder

hook 分类，在类似willDisappear 中，调用一个 willDealloc 方法，执行大概 3 秒延迟的block, weakself 调用 方法，进行断言，如 weakself 指向对象已经释放，则 nil 无法调用到断言。

# 其它问题

## 返回手势冲突

```
//一句话总结就是此方法返回YES时，手势事件会一直往下传递，不论当前层次是否对该事件进行响应。
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer {
    
    if ([self panBack:gestureRecognizer]) {
        return YES;
    }
    return NO;
    
}

```

## 野指针崩溃

野指针和空指针区别:

没有存储任何内存地址的指针就称为空指针(NULL指针)。空指针，被赋值为nil的指针，在没有被具体初始化之前，为nil。

NSNull中只有一个null方法 :[NSNull null]

"野指针"不是nil指针，是指向"垃圾"内存（不可用内存）的指针。野指针指向的对象已经被释放了。野指针是非常危险的。

向空指针发送消息不会报错，空指针没有储存任何的内存地址。但是给野指针发送消息会报错 -- exc_bad_access.

野指针指的是本来指针指向的对象已经释放了，但指向该对象的指针没有置 nil，指针指向随机的未知的内存，程序还以为该指针指向那个对象，导致存在一些潜在的危险访问操作，这些危险访问操作无法被指针指向的未知内存所处理，就会导致BAD_ACCESS错误造成程序崩溃。

为什么给 nil 发消息不崩溃?
OC的函数调用都是通过objc_msgSend进行消息发送来实现的，相对于C和C++来说，对于空指针的操作会引起Crash的问题，而objc_msgSend会通过判断self来决定是否发送消息，如果self为nil，那么selector也会为空，直接返回，所以不会出现问题。视方法返回值，向nil发消息可能会返回nil(返回值为对象)、0（返回值为一些基础数据类型）或0X0（返回值为id）等。但是对[NSNull
null]对象发送消息时，是会crash的，因为这个NSNull类只有一个null方法。

## kvo 

kvo的实现

Apple 使用了 isa 混写（isa-swizzling）来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为：NSKVONotifying_A 的新类，该类继承自对象A的本类，且 KVO 为 NSKVONotifying_A 重写观察属性的 setter 方法，setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象属性值的更改情况。
（备注： isa 混写（isa-swizzling）isa：is a kind of ； swizzling：混合，搅合；

观察者观察的是属性，只有遵循 KVO 变更属性值的方式才会执行 KVO 的回调方法，例如是否执行了 setter 方法、或者是否使用了 KVC 赋值。
如果赋值没有通过 setter 方法或者 KVC，而是直接修改属性对应的成员变量，例如：仅调用 _name = @"newName"，这时是不会触发 KVO 机制，更加不会调用回调方法的。
所以使用 KVO 机制的前提是遵循 KVO 的属性设置方式来变更属性值。

KVO 子类 setter 方法，如何同时更改父类？

##  IB 配置

IB 中 User Defined Runtime Attributes 如何使用？

它能够通过KVC的方式配置一些你在 interface builder 中不能配置的属性。当你希望在IB中作尽可能多得事情，这个特性能够帮助你编写更加轻量级的viewcontroller

## load / initialize

+(void)load; +(void)initialize；有什么用处？

这两个方法在类被使用时会自动调用。但是两个方法的不同点会导致应用层面上性能的显著差异。

load和initialize方法内部使用了锁，因此他们是线程安全的，实现时要尽可能简单，避免线程阻塞，不要再次使用锁。

load方法常用来method swizzle，initialize常常用于初始化全局变量和静态变量.

- +initialize 
>这个方法会在 第一次初始化这个类之前 被调用，我们用它来初始化静态变量。
>`+ initialize` 方法类似一个懒加载，如果没有使用这个类，那么系统默认不会去调用这个方法，且默认只加载一次；
`+ initialize `的调用,发生在 +init 方法之前。
>创建子类的时候，子类会去调用父类的` + initialize `方法

- +load 
> 顾名思义，load方法在这个文件被程序装载时调用。只要是在Compile Sources中出现的文件总是会被装载，这与这个类是否被用到无关，因此load方法总是在main函数之前调用。父类先于子类执行，类先于分类执行。
>如果一个类没有实现load方法，那么就不会调用它父类的load方法，这一点与正常的类继承和方法调用不一样，需要额外注意一下。
>并没有对类做任何操作的情况下，+load 方法会被默认执行，并且是在 main 函数之前执行的。

一般来说，除了Method Swizzle，别的逻辑都不应该放在load方法中实现。

```
+ (void)load {
    Method originalFunc = class_getInstanceMethod([self class], @selector(originalFunc));
    Method swizzledFunc = class_getInstanceMethod([self class], @selector(swizzledFunc));
 
//交换两个方法的地址method_exchangeImplementations(originalFunc, swizzledFunc);
}
```

## 单例


1.饿汉式：一进入程序就自动创建一个单例对象，但在移动端不是很适用； 
2.懒汉式：当第一次使用到单例对象时，才创建对象；

```
+ (__class *)sharedInstance 
{ 
static dispatch_once_t once; 
static __class * __singleton__; 
dispatch_once( &once, ^{ __singleton__ = [[__class alloc] init]; } ); 
return __singleton__; 
}
```

滥用单例：
就是在两个单例的初始化调用中直接相互调用。A<->B。也许这个Demo过于简单，大家轻易不会犯。但是如果是A->B->C->A，甚至是更多个模块的相互引用，那又该如何轻易避免呢？

1.仅仅使用一次的模块，可以不使用单例，可以采用在对应的周期内维护成员实例变量进行替换。
2.和状态无关的模块，可以采用静态（类）方法直接替换。
3.可以通过页面跳转进行依赖注入的模块，可以采用依赖注入或者变量传递等方式解决。

## 抽象工厂

类簇， NSNumber,NSString,NSArray,NSDictionary.

我们通过他们创建的对象都是其子类对象的实例化，并不是他本身的实例化.

做防护需求的时候，对类簇中的私有类做 Method Swizzling . __NSArrayI ,__NSArrayM(NSMutableArray)

## VC 生命周期

viewdidload viewdidappear viewunload

# 参考资料

[(译)缓存在AFNetworking中是如何工作的？AFImageCache和NSUrlCache给你答案](http://devtian.me/2015/03/24/translate-how-does-cache-work-in-AFNetworking/)

[block](http://blog.ibireme.com/2013/11/27/objc-block/)

[Objective-C 中的消息与消息转发](http://blog.ibireme.com/2013/11/26/objective-c-messaging/)

[iOS 保持界面流畅的技巧](http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)

[YYCache 设计思路](http://blog.ibireme.com/2015/10/26/yycache/)

[iOS当中的Cache设计](http://mrpeak.cn/blog/ios-cache/)

[iOS网络缓存扫盲篇--使用两行代码就能完成80%的缓存需求](http://www.jianshu.com/p/fb5aaeac06ef)

[谈谈iOS中的HTTP缓存策略](http://chesterlee.github.io/blog/2014/08/10/ioszhong-de-urlcacheji-zhi/)

[隐式动画](http://zhangbuhuai.com/implicit-animations/)

[iOS 常见知识点（三）：Lock](http://www.jianshu.com/p/ddbe44064ca4)

[关于 @synchronized，这儿比你想知道的还要多](http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/)

[UIKit 性能调优](http://www.jianshu.com/p/619cf14640f3)

[MVVM 介绍](https://objccn.io/issue-13-1/)

[HTTP 的构成](http://mrpeak.cn/blog/http-constitution/)

[Objective-C Runtime](http://tech.glowing.com/cn/objective-c-runtime/)

[runtime 方法交换](http://www.jianshu.com/p/552651c962c3)

[iOS内存管理：从MRC到ARC实践](https://dev.qq.com/topic/59194943f473278853516915)


