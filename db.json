{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/atom.xml","path":"atom.xml","modified":1,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/images/author.jpg","path":"images/author.jpg","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/atom.xml","hash":"a3c53382076683b8dfb205d33ad7151fb0a29a34","modified":1459951137000},{"_id":"source/.DS_Store","hash":"55887e76ac77aab423d11d8d07c109a5c0f970ee","modified":1473442625000},{"_id":"source/CNAME","hash":"7cc3933936ff2692510a5d9a202403b646e1ac3d","modified":1447416748000},{"_id":"themes/next/.bowerrc","hash":"80e096fdc1cf912ee85dd9f7e6e77fd40cf60f10","modified":1473009235000},{"_id":"themes/next/.DS_Store","hash":"8117c751786fc75ae1049b6e945e02bac6e40a60","modified":1473092134000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1473009235000},{"_id":"themes/next/.gitignore","hash":"c8d6a73b9e17f0f8a3716e4ada6960d3180425a6","modified":1473009235000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1473009235000},{"_id":"themes/next/.javascript_ignore","hash":"d619ee13031908cd72666e4ff652d2ea3483b1c3","modified":1473009235000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1473009235000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1473009235000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1473009235000},{"_id":"themes/next/_config.yml","hash":"22bacf0a655a9b66378ab5ad01858d3ce1d13ad7","modified":1473091969000},{"_id":"themes/next/bower.json","hash":"f89c6700a11d81e067cc97273ca6bf96cb88c8f9","modified":1473009235000},{"_id":"themes/next/gulpfile.coffee","hash":"26e5b1b945704c8bc78b928feede895c4c111c95","modified":1473009235000},{"_id":"themes/next/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1473009235000},{"_id":"source/_posts/.DS_Store","hash":"4d2aa2d1f7d33c454b747e6544fbeb9d41b90908","modified":1473442625000},{"_id":"source/categories/index.md","hash":"2599659b372b81b87168e0724576988ebbc6d9c2","modified":1473093594000},{"_id":"source/images/author.jpg","hash":"9f7e0748316ff507896245b78b83ec2337fdbdfa","modified":1460179630000},{"_id":"source/images/.DS_Store","hash":"2438b04b546a5a8d2bbe97ee69de44318d8d160d","modified":1473092124000},{"_id":"source/tags/index.md","hash":"85c6b62423b0a04874c78dfdf45383a2adc259e7","modified":1473093581000},{"_id":"source/resource/index.md","hash":"f669e924dc98648a7ee852fe9691bf89ceef00fd","modified":1460211118000},{"_id":"themes/next/.git/FETCH_HEAD","hash":"4eb6186fa557b2fed100566d5b060dd86ca16fed","modified":1473092143000},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1473009235000},{"_id":"themes/next/.git/config","hash":"ca83ce520f770c3104c997d323b9f293dd920073","modified":1473009235000},{"_id":"themes/next/.git/index","hash":"9c43376356a60d06f3aff80fcbfd0992541fb61a","modified":1473009236000},{"_id":"themes/next/.git/packed-refs","hash":"5299dd07c22750af4a0d99f89ea2c8e2d52787e3","modified":1473009235000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1473009235000},{"_id":"themes/next/.git/sourcetreeconfig","hash":"7f69931bfe59ea86f31d97d75235b7e2960645cd","modified":1473092143000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1473009235000},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1473009235000},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1473009235000},{"_id":"themes/next/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1473009235000},{"_id":"themes/next/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1473009235000},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1473009235000},{"_id":"themes/next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1473009235000},{"_id":"themes/next/languages/ko.yml","hash":"ce8b047c89daae77c03482fc76f16ffec6bdbf2d","modified":1473009235000},{"_id":"themes/next/languages/pt-BR.yml","hash":"462aa865ca3d479bcf6b363cba61247b50f230ff","modified":1473009235000},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1473009235000},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1473009235000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"b630db4e0dd9219ba269cf889768b5e3da94f0fb","modified":1473091783000},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1473009235000},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1473009235000},{"_id":"themes/next/layout/_layout.swig","hash":"74157f6cfd679ea11febec632542793f37c5e5d4","modified":1473009235000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1473009235000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1473009235000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1473009235000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1473009235000},{"_id":"themes/next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1473009235000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1473009235000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1473009235000},{"_id":"themes/next/source/.DS_Store","hash":"baba6649b559c048a199ea9bdc6c5906cdccddc7","modified":1473092134000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1473009235000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1473009235000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1473009235000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473009235000},{"_id":"source/_posts/技术/2015-11-10-CocoaPosdsDemo.md","hash":"15cc18ef6e6ea19c30418810cc9c91273267a8be","modified":1460288796000},{"_id":"source/_posts/技术/2015-10-14-ios-TableView.md","hash":"5cac88158f6be15d320195baae669de3cf18a041","modified":1460288852000},{"_id":"source/_posts/技术/2015-11-11-Reveal.md","hash":"422fef1915e7af404e257f0334fc30734d865dea","modified":1460288786000},{"_id":"source/_posts/技术/2015-11-6-ViewControllerDebug.md","hash":"5ec774558c2bf37703ce2acf454f3717bb5c3a99","modified":1460288812000},{"_id":"source/_posts/技术/.DS_Store","hash":"83019d378ff24507e4bbf2672dd015a2b5342279","modified":1470837267000},{"_id":"source/_posts/技术/2015-11-15-XcodePlugs.md","hash":"37dde61ff87b49a4555ef825d42120e1d630aa31","modified":1460210288000},{"_id":"source/_posts/技术/2015-11-12-DesignPatterns.md","hash":"29d837e4e5e4ba490b2cdf3098c8f7b798986a0c","modified":1460288773000},{"_id":"source/_posts/技术/2015-9-24-python-urllib2.md","hash":"17da7bff691ce762c1596bd22fdd6e8978802e84","modified":1473182794000},{"_id":"source/_posts/技术/2016-1-31-SourceOfiOS.md","hash":"fe3b3d46a24c2b0001ee2be8d276201b05a1498b","modified":1460994474000},{"_id":"source/_posts/技术/2016-7-9-Recruitment.markdown","hash":"323c0ec5d06b102e63045a8c477784a6390ed581","modified":1468167057000},{"_id":"source/_posts/技术/2016-3-23-ALAsset.md","hash":"934dd21ecf8d8db8f4c5bd8a72b5844a7bd2e826","modified":1460210172000},{"_id":"source/_posts/技术/2016-2-29-reviewcode.md","hash":"e4f04ccd8cfa21c08608832ad8268aab50e28a45","modified":1460210236000},{"_id":"source/_posts/技术/2016-3-31-codeGuide.md","hash":"eb36a2ae4980588f082774612cca319e39046801","modified":1471766405000},{"_id":"source/_posts/生活/2015-9-20-study-1.md","hash":"ea5bee7f4cf4266949fcdb42c2d2078a707ed7d2","modified":1473183051000},{"_id":"source/_posts/技术/2016-8-21-Objective-CCodeGuide.md","hash":"067d876f711dcdbb76c73d097835eccd1b5e09d7","modified":1471880819000},{"_id":"source/_posts/技术/2016-9-2-GoSpark.md","hash":"9cdc8f5a33cc11bdb7f7699fa17f25b6efbffc8b","modified":1473182696000},{"_id":"source/_posts/生活/2015-11-14-study-2.md","hash":"53316c1587ccff7af4de87c9e89e141a2ab8527e","modified":1460288938000},{"_id":"source/_posts/生活/2016-1-1-life.markdown","hash":"e44ca63b91a404bb61f725add281772529568965","modified":1460288985000},{"_id":"source/_posts/生活/.DS_Store","hash":"b189e70aee46c039fa87b7dad09346ebd64f0c58","modified":1473212685000},{"_id":"source/_posts/生活/2016-1-22-plan.markdown","hash":"3fd38ceda7ec3c4d4f847f89d538c0cb5519e610","modified":1460289316000},{"_id":"source/_posts/生活/2016-2-1-PlanOfiOS.markdown","hash":"cec4354ac7e8de7f89c9a69018d260294173e28a","modified":1460289057000},{"_id":"themes/next/.git/logs/HEAD","hash":"a04e300237db67864d6f3a5cedd1d508a964af45","modified":1473009235000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1473009235000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1473009235000},{"_id":"themes/next/layout/_macro/post.swig","hash":"f3895bf44a9fb7c462f2e57b9a914703c2f152ba","modified":1473009235000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"1a77843ce5eac62151dc3d38f0a36c43e19e1a74","modified":1473009235000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1473009235000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"58fd826ca75b0cbc48b61a58da4b841e2fa34403","modified":1473009235000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1473009235000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4fe588ff8ba8587885c2936db2df490774f89e10","modified":1473009235000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b0c495b8154ef8b2d2cb0a554e164ff22cdc962","modified":1473009235000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1473009235000},{"_id":"themes/next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1473009235000},{"_id":"themes/next/layout/_partials/header.swig","hash":"eb028685cb3c329537bbced06c063d23e6a33817","modified":1473009235000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1473009235000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1473009235000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1473009235000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1473009235000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1473009235000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1473009235000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1473009235000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1473009235000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1473009235000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1473009235000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1473009235000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1473009235000},{"_id":"themes/next/source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1473088824000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1473009235000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1473009235000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1473009235000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1473009235000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1473009235000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1473009235000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1473009235000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1473009235000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1473009235000},{"_id":"themes/next/source/vendors/.DS_Store","hash":"0c2e3cb54d92dffed17c0e375cc04f5c14a392a2","modified":1473092129000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473009235000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473009235000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473009235000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473009235000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473009235000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473009235000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473009235000},{"_id":"themes/next/.git/refs/heads/master","hash":"a000ff7ceba1704584e39c908e83fe3db5859335","modified":1473009235000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1473009235000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1473009235000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1473009235000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1473009235000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1473009235000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1473009235000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1473009235000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1473009235000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1473009235000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1473009235000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1473009235000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1473009235000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1473009235000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1473009235000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"7f7148c8f52e4d3cfc070d964160362179fa8e91","modified":1473009235000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1473009235000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1473009235000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1473009235000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1473009235000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1473009235000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1473009235000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"17624186f7a1f28daddea258d044f8e03b2f4bea","modified":1473009235000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1473009235000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1473009235000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1473009235000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1473009235000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1473009235000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1473009235000},{"_id":"themes/next/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1473009235000},{"_id":"themes/next/source/vendors/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1473009235000},{"_id":"themes/next/source/vendors/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1473009235000},{"_id":"themes/next/source/vendors/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1473009235000},{"_id":"themes/next/source/vendors/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1473009235000},{"_id":"themes/next/source/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1473009235000},{"_id":"themes/next/source/vendors/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1473009235000},{"_id":"themes/next/source/vendors/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1473009235000},{"_id":"themes/next/source/vendors/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1473009235000},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1473009235000},{"_id":"themes/next/source/vendors/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1473009235000},{"_id":"themes/next/source/vendors/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1473009235000},{"_id":"themes/next/source/vendors/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1473009235000},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1473009235000},{"_id":"themes/next/source/vendors/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1473009235000},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1473009235000},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1473009235000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1473009235000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1473009235000},{"_id":"themes/next/source/vendors/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1473009235000},{"_id":"themes/next/source/vendors/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1473009235000},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1473009235000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1473009235000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1473009235000},{"_id":"themes/next/source/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1473009235000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1473009235000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"a04e300237db67864d6f3a5cedd1d508a964af45","modified":1473009235000},{"_id":"themes/next/.git/objects/pack/pack-86fef626de1eb962abc5ba6bb6a3172ba82e6ec3.idx","hash":"df3e80c427ffb662152d057bc39d5e53ad3f3ffe","modified":1473009235000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1473009235000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1473009235000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1473009235000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"1e3e1c6231408e18e8485a8e0e59e8880349b210","modified":1473009235000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1473009235000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1473009235000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"bff3b18f56175c53f3bc6d733166c4d998e08732","modified":1473009235000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"696666141cdd204fd8818ac2ad18f05e320f8587","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1473009235000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1473009235000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1473009235000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1473009235000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1473009235000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1473009235000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1473009235000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1473009235000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1473009235000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1473009235000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1473009235000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1473009235000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1473009235000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1473009235000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1473009235000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1473009235000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1473009235000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1473009235000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1473009235000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1473009235000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"8d7cecde4933900c7df2db9d0a98f5f82f88dc93","modified":1473009235000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1473009235000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1473009235000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1473009235000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1473009235000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1473009235000},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1473009235000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1473009235000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1473009235000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1473009235000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1473009235000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1473009235000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1473009235000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1473009235000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1473009235000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1473009235000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1473009235000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1473009235000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1473009235000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1473009235000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1473009235000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1473009235000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1473009235000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1473009235000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1473009235000},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1473009235000},{"_id":"themes/next/source/vendors/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1473009235000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1473009235000},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"a04e300237db67864d6f3a5cedd1d508a964af45","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4da051c7f3924fa2db1e73c55b2baf1c2c150255","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1473009235000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1473009235000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1473009235000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1473009235000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1473009235000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1473009235000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1473009235000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1473009235000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1473009235000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1473009235000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1473009235000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1473009235000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1473009235000},{"_id":"themes/next/.git/objects/pack/pack-86fef626de1eb962abc5ba6bb6a3172ba82e6ec3.pack","hash":"8b28a22776ffc0e6313769e8f2cc855633f4de03","modified":1473009235000},{"_id":"public/categories/index.html","hash":"9e3624e92e8761af7cdf74aa7d76164bf7e73534","modified":1473442664402},{"_id":"public/tags/index.html","hash":"7389056bd8aea6fae87c7ccd83c7804b19bf679a","modified":1473442664402},{"_id":"public/categories/技术/page/2/index.html","hash":"552fe1ce4958defebeb544688cf24e4a94270ba2","modified":1473442664403},{"_id":"public/archives/2015/09/index.html","hash":"feb632830b3dbf3f95af771244502993c3d2d35e","modified":1473442664403},{"_id":"public/archives/2015/10/index.html","hash":"7f4a5d2ef3dd56a3031b0ec9a552e8952e9c23b7","modified":1473442664403},{"_id":"public/archives/2016/01/index.html","hash":"6537f844a1d3dd5c1f6ad27aa54cf34b84f41896","modified":1473442664403},{"_id":"public/archives/2016/02/index.html","hash":"7bdd24d358b3712cac24fd5e7bef7b0aef5954df","modified":1473442664403},{"_id":"public/archives/2016/03/index.html","hash":"2ca52a6f158669b866fbf9b985b728320eadcd56","modified":1473442664403},{"_id":"public/archives/2016/07/index.html","hash":"9191c70876d9c5c35a74d0f0288ec45c1f379615","modified":1473442664403},{"_id":"public/archives/2016/08/index.html","hash":"63ad9ce0519ec62a50f04c78ca5581fc94975648","modified":1473442664403},{"_id":"public/resource/index.html","hash":"981a23ef357e562b7a22fdf3d198f3585ae18177","modified":1473442664403},{"_id":"public/2016/08/25/技术/2016-9-2-GoSpark/index.html","hash":"95f53b6f9097194fdb9f20176a6e63d26a2e0cc8","modified":1473442664403},{"_id":"public/2016/08/21/技术/2016-8-21-Objective-CCodeGuide/index.html","hash":"5ca43c13fe3f1b20e6eef29b122366ee21985096","modified":1473442664403},{"_id":"public/2016/07/10/技术/2016-7-9-Recruitment/index.html","hash":"4cdf7917f4cb97e3d82d26acf5a3a0f9ad4fef7a","modified":1473442664404},{"_id":"public/2016/03/31/技术/2016-3-31-codeGuide/index.html","hash":"d443c0a7503ef1968715d69549f3e8087bb786c2","modified":1473442664404},{"_id":"public/2016/03/23/技术/2016-3-23-ALAsset/index.html","hash":"e06ddc2fd388c8f5e172dcabcd854b463277ef99","modified":1473442664404},{"_id":"public/2016/02/29/技术/2016-2-29-reviewcode/index.html","hash":"d8c6f40f6ba223fc6846387190647677f3c1085d","modified":1473442664404},{"_id":"public/2016/02/01/生活/2016-2-1-PlanOfiOS/index.html","hash":"c4d906a80526bb9bad227fcf4750e989752a0251","modified":1473442664404},{"_id":"public/2016/01/31/技术/2016-1-31-SourceOfiOS/index.html","hash":"e39840afeeb3c7b901c60ef9e47c24f507f177c5","modified":1473442664404},{"_id":"public/2016/01/22/生活/2016-1-22-plan/index.html","hash":"ff7be41a421a44f1f19dd952265f9104272f8bf3","modified":1473442664404},{"_id":"public/2016/01/01/生活/2016-1-1-life/index.html","hash":"06926c6b98caaef6d08cced07c92815df5f3106a","modified":1473442664405},{"_id":"public/2015/11/15/技术/2015-11-15-XcodePlugs/index.html","hash":"7769c4b5b8617af35f9ec0a3ac7b7522b8dfc0f7","modified":1473442664405},{"_id":"public/2015/11/14/生活/2015-11-14-study-2/index.html","hash":"3b3ec0f830cf657daa2e459441f546994e112ecc","modified":1473442664405},{"_id":"public/2015/11/12/技术/2015-11-12-DesignPatterns/index.html","hash":"5a8903db54d810901b1abe96867ae82cc5803d6d","modified":1473442664405},{"_id":"public/2015/11/11/技术/2015-11-11-Reveal/index.html","hash":"9167cbeee272d86eff2e7d93b3146656bc9c25cd","modified":1473442664405},{"_id":"public/2015/11/10/技术/2015-11-10-CocoaPosdsDemo/index.html","hash":"157fcfbdc92fd48f2d890f6d6f959547a2b5b62e","modified":1473442664405},{"_id":"public/2015/11/06/技术/2015-11-6-ViewControllerDebug/index.html","hash":"ef7a5bff31e4f67ab97afaa35cd914b605fe4741","modified":1473442664405},{"_id":"public/2015/10/14/技术/2015-10-14-ios-TableView/index.html","hash":"9843799e5cf7a99a5a04f694766de1ba67eed011","modified":1473442664405},{"_id":"public/2015/09/24/技术/2015-9-24-python-urllib2/index.html","hash":"cb529bfe8943bd3c03530e31b40bfeaadb4718d2","modified":1473442664405},{"_id":"public/2015/09/20/生活/2015-9-20-study-1/index.html","hash":"388eb16cc4c45286e1ae117f79245ba5d484b6a2","modified":1473442664405},{"_id":"public/categories/技术/index.html","hash":"e4d31f3f29d4187fcd22eaa06d748025565949b9","modified":1473442664405},{"_id":"public/categories/生活/index.html","hash":"eea81cd5bc6b3765f3ecb6aa9cb4fd56bdc528c5","modified":1473442664405},{"_id":"public/archives/index.html","hash":"fac19f84059dc3baf6db8e3c3be59fbec0cb9f1b","modified":1473442664406},{"_id":"public/archives/page/2/index.html","hash":"e7ea79c84fd909e9babf1645323ad77ac138927f","modified":1473442664406},{"_id":"public/archives/2015/index.html","hash":"a02d8c163611cf28d4462af8be98a8ac2f2de0a8","modified":1473442664406},{"_id":"public/archives/2015/11/index.html","hash":"4abee4b1f25c311c8400620e363e904e4bbc449f","modified":1473442664406},{"_id":"public/archives/2016/index.html","hash":"6d6998edddcfc8d93b6e8b7f998a31d8b13fdcf5","modified":1473442664406},{"_id":"public/index.html","hash":"2a65c8e18fac2af00cddbde31198f5e672d45520","modified":1473442664406},{"_id":"public/page/2/index.html","hash":"c6ef30b8967aa9ac411d68f0b126405004edd499","modified":1473442664406},{"_id":"public/tags/实习工作/index.html","hash":"371ead6df7cfad7cc51c193e4ab5d229ae3a4d01","modified":1473442664406},{"_id":"public/tags/资料/index.html","hash":"65f64c6464b773d1aeeb4bd7a6803c87ed60dfab","modified":1473442664406},{"_id":"public/atom.xml","hash":"a3c53382076683b8dfb205d33ad7151fb0a29a34","modified":1473442664431},{"_id":"public/CNAME","hash":"7cc3933936ff2692510a5d9a202403b646e1ac3d","modified":1473442664431},{"_id":"public/images/author.jpg","hash":"9f7e0748316ff507896245b78b83ec2337fdbdfa","modified":1473442664432},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1473442664432},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1473442664432},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1473442664432},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1473442664432},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1473442664432},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1473442664432},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1473442664432},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1473442664433},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1473442664433},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1473442664433},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1473442664433},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1473442664433},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1473442664433},{"_id":"public/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1473442664433},{"_id":"public/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1473442664433},{"_id":"public/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1473442664433},{"_id":"public/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1473442664433},{"_id":"public/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1473442664434},{"_id":"public/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1473442664434},{"_id":"public/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1473442664434},{"_id":"public/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1473442664434},{"_id":"public/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1473442664434},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1473442664434},{"_id":"public/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1473442664434},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1473442665878},{"_id":"public/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1473442665883},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1473442665885},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1473442665895},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1473442665895},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1473442665895},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1473442665895},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1473442665895},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1473442665895},{"_id":"public/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1473442665895},{"_id":"public/vendors/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1473442665895},{"_id":"public/vendors/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1473442665896},{"_id":"public/vendors/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1473442665896},{"_id":"public/vendors/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1473442665896},{"_id":"public/vendors/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1473442665896},{"_id":"public/vendors/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1473442665896},{"_id":"public/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1473442665896},{"_id":"public/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1473442665896},{"_id":"public/vendors/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1473442665896},{"_id":"public/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1473442665897},{"_id":"public/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1473442665897},{"_id":"public/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1473442665897},{"_id":"public/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1473442665897},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1473442665897},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1473442665897},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1473442665897},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1473442665897},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1473442665897},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1473442665897},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1473442665897},{"_id":"public/css/main.css","hash":"73eeeb948c641aaae56a93f261bdd6dff267773a","modified":1473442665898},{"_id":"public/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1473442665898},{"_id":"public/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1473442665898},{"_id":"public/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1473442665898},{"_id":"public/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1473442665898},{"_id":"public/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1473442665898},{"_id":"public/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1473442665898},{"_id":"public/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1473442665898},{"_id":"public/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1473442665898},{"_id":"public/vendors/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1473442665898},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1473442665899},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1473442665910}],"Category":[{"name":"技术","_id":"cisw1ptqy0006yrnt46k1vtt8"},{"name":"生活","_id":"cisw1ptsc0017yrntpwvyi4so"}],"Data":[],"Page":[{"title":"categories","date":"2016-09-05T16:01:35.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-09-06 00:01:35\ntype: \"categories\"\ncomments: false\n---\n","updated":"2016-09-05T16:39:54.000Z","path":"categories/index.html","layout":"page","_id":"cisw1ptnk0000yrntlwwhci39","content":"","excerpt":"","more":""},{"title":"tags","date":"2016-09-05T16:00:00.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-09-06 00:00:00\ntype: \"tags\"\ncomments: false\n---\n","updated":"2016-09-05T16:39:41.000Z","path":"tags/index.html","layout":"page","_id":"cisw1ptnn0001yrnt77zrsl20","content":"","excerpt":"","more":""},{"layout":"post","title":"resource","_content":"因为自己经常收藏很多资源，Chrome的收藏栏很乱。所以专门整理到一个文章中，以备需要时查看。\n\n# 搜索姿势\n\n[如何搜寻iOS第三方资源库](http://zhangbuhuai.com/2015/07/18/how-to-search-3rd-ios-resources/)\n\n[github oc star>1](https://github.com/search?l=Objective-C&o=desc&q=stars%3A%3E1&s=stars&type=Repositories)\n\n# 资源\n\n[oc框架排名列表](https://github.com/XCGit/awesome-objc-frameworks)\n\n[iOS,mac开源项目及库](https://github.com/XCGit/awesome-objc-frameworks)\n\n[iOS及mac开源项目和学习资料（很全面）](http://www.kancloud.cn/digest/ios-mac-study/84557)\n\n[为iOS应用添加夜间模式DKNightVersion](https://github.com/Draveness/DKNightVersion)\n\n[ibireme整理资源](http://github.ibireme.com/github/list/ios/)\n\n[折线图,环形统计图 PNChart](https://github.com/kevinzhow/PNChart)\n\n[actilces of iOS](https://github.com/JanzTam/iOS-blog-acticle/blob/master/acticles.md)\n\n[iOS开发常用细节](http://segmentfault.com/a/1190000003722059)\n\n[ibireme的iOS备忘](http://github.ibireme.com/github/list/ios/)\n\n[XcodePlugin开发探讨](https://github.com/MakeZL/CocoaPods-ToGithub-List)\n\n[SYNX:命令行工具，重组文件结构](https://github.com/venmo/synx?plg_nld=1&plg_uin=1&plg_auth=1&plg_nld=1&plg_usr=1&plg_vkey=1&plg_dev=1)\n\n[2016中国swift开发者大会](https://github.com/atConf/atswift-2016-resources)\n\n[17个提升iOS开发效率的必备工具](http://blog.fir.im/fir_im_weekly151119/?utm_source=weibo&utm_medium=link&utm_content=fir_im_weekly151119)\n","source":"resource/index.md","raw":"---\nlayout: post\ntitle: resource\n---\n因为自己经常收藏很多资源，Chrome的收藏栏很乱。所以专门整理到一个文章中，以备需要时查看。\n\n# 搜索姿势\n\n[如何搜寻iOS第三方资源库](http://zhangbuhuai.com/2015/07/18/how-to-search-3rd-ios-resources/)\n\n[github oc star>1](https://github.com/search?l=Objective-C&o=desc&q=stars%3A%3E1&s=stars&type=Repositories)\n\n# 资源\n\n[oc框架排名列表](https://github.com/XCGit/awesome-objc-frameworks)\n\n[iOS,mac开源项目及库](https://github.com/XCGit/awesome-objc-frameworks)\n\n[iOS及mac开源项目和学习资料（很全面）](http://www.kancloud.cn/digest/ios-mac-study/84557)\n\n[为iOS应用添加夜间模式DKNightVersion](https://github.com/Draveness/DKNightVersion)\n\n[ibireme整理资源](http://github.ibireme.com/github/list/ios/)\n\n[折线图,环形统计图 PNChart](https://github.com/kevinzhow/PNChart)\n\n[actilces of iOS](https://github.com/JanzTam/iOS-blog-acticle/blob/master/acticles.md)\n\n[iOS开发常用细节](http://segmentfault.com/a/1190000003722059)\n\n[ibireme的iOS备忘](http://github.ibireme.com/github/list/ios/)\n\n[XcodePlugin开发探讨](https://github.com/MakeZL/CocoaPods-ToGithub-List)\n\n[SYNX:命令行工具，重组文件结构](https://github.com/venmo/synx?plg_nld=1&plg_uin=1&plg_auth=1&plg_nld=1&plg_usr=1&plg_vkey=1&plg_dev=1)\n\n[2016中国swift开发者大会](https://github.com/atConf/atswift-2016-resources)\n\n[17个提升iOS开发效率的必备工具](http://blog.fir.im/fir_im_weekly151119/?utm_source=weibo&utm_medium=link&utm_content=fir_im_weekly151119)\n","date":"2016-04-09T14:11:58.000Z","updated":"2016-04-09T14:11:58.000Z","path":"resource/index.html","comments":1,"_id":"cisw1ptnq0002yrnt7npkl09y","content":"<p>因为自己经常收藏很多资源，Chrome的收藏栏很乱。所以专门整理到一个文章中，以备需要时查看。</p>\n<h1 id=\"搜索姿势\"><a href=\"#搜索姿势\" class=\"headerlink\" title=\"搜索姿势\"></a>搜索姿势</h1><p><a href=\"http://zhangbuhuai.com/2015/07/18/how-to-search-3rd-ios-resources/\" target=\"_blank\" rel=\"external\">如何搜寻iOS第三方资源库</a></p>\n<p><a href=\"https://github.com/search?l=Objective-C&amp;o=desc&amp;q=stars%3A%3E1&amp;s=stars&amp;type=Repositories\" target=\"_blank\" rel=\"external\">github oc star&gt;1</a></p>\n<h1 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h1><p><a href=\"https://github.com/XCGit/awesome-objc-frameworks\" target=\"_blank\" rel=\"external\">oc框架排名列表</a></p>\n<p><a href=\"https://github.com/XCGit/awesome-objc-frameworks\" target=\"_blank\" rel=\"external\">iOS,mac开源项目及库</a></p>\n<p><a href=\"http://www.kancloud.cn/digest/ios-mac-study/84557\" target=\"_blank\" rel=\"external\">iOS及mac开源项目和学习资料（很全面）</a></p>\n<p><a href=\"https://github.com/Draveness/DKNightVersion\" target=\"_blank\" rel=\"external\">为iOS应用添加夜间模式DKNightVersion</a></p>\n<p><a href=\"http://github.ibireme.com/github/list/ios/\" target=\"_blank\" rel=\"external\">ibireme整理资源</a></p>\n<p><a href=\"https://github.com/kevinzhow/PNChart\" target=\"_blank\" rel=\"external\">折线图,环形统计图 PNChart</a></p>\n<p><a href=\"https://github.com/JanzTam/iOS-blog-acticle/blob/master/acticles.md\" target=\"_blank\" rel=\"external\">actilces of iOS</a></p>\n<p><a href=\"http://segmentfault.com/a/1190000003722059\" target=\"_blank\" rel=\"external\">iOS开发常用细节</a></p>\n<p><a href=\"http://github.ibireme.com/github/list/ios/\" target=\"_blank\" rel=\"external\">ibireme的iOS备忘</a></p>\n<p><a href=\"https://github.com/MakeZL/CocoaPods-ToGithub-List\" target=\"_blank\" rel=\"external\">XcodePlugin开发探讨</a></p>\n<p><a href=\"https://github.com/venmo/synx?plg_nld=1&amp;plg_uin=1&amp;plg_auth=1&amp;plg_nld=1&amp;plg_usr=1&amp;plg_vkey=1&amp;plg_dev=1\" target=\"_blank\" rel=\"external\">SYNX:命令行工具，重组文件结构</a></p>\n<p><a href=\"https://github.com/atConf/atswift-2016-resources\" target=\"_blank\" rel=\"external\">2016中国swift开发者大会</a></p>\n<p><a href=\"http://blog.fir.im/fir_im_weekly151119/?utm_source=weibo&amp;utm_medium=link&amp;utm_content=fir_im_weekly151119\" target=\"_blank\" rel=\"external\">17个提升iOS开发效率的必备工具</a></p>\n","excerpt":"","more":"<p>因为自己经常收藏很多资源，Chrome的收藏栏很乱。所以专门整理到一个文章中，以备需要时查看。</p>\n<h1 id=\"搜索姿势\"><a href=\"#搜索姿势\" class=\"headerlink\" title=\"搜索姿势\"></a>搜索姿势</h1><p><a href=\"http://zhangbuhuai.com/2015/07/18/how-to-search-3rd-ios-resources/\">如何搜寻iOS第三方资源库</a></p>\n<p><a href=\"https://github.com/search?l=Objective-C&amp;o=desc&amp;q=stars%3A%3E1&amp;s=stars&amp;type=Repositories\">github oc star&gt;1</a></p>\n<h1 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h1><p><a href=\"https://github.com/XCGit/awesome-objc-frameworks\">oc框架排名列表</a></p>\n<p><a href=\"https://github.com/XCGit/awesome-objc-frameworks\">iOS,mac开源项目及库</a></p>\n<p><a href=\"http://www.kancloud.cn/digest/ios-mac-study/84557\">iOS及mac开源项目和学习资料（很全面）</a></p>\n<p><a href=\"https://github.com/Draveness/DKNightVersion\">为iOS应用添加夜间模式DKNightVersion</a></p>\n<p><a href=\"http://github.ibireme.com/github/list/ios/\">ibireme整理资源</a></p>\n<p><a href=\"https://github.com/kevinzhow/PNChart\">折线图,环形统计图 PNChart</a></p>\n<p><a href=\"https://github.com/JanzTam/iOS-blog-acticle/blob/master/acticles.md\">actilces of iOS</a></p>\n<p><a href=\"http://segmentfault.com/a/1190000003722059\">iOS开发常用细节</a></p>\n<p><a href=\"http://github.ibireme.com/github/list/ios/\">ibireme的iOS备忘</a></p>\n<p><a href=\"https://github.com/MakeZL/CocoaPods-ToGithub-List\">XcodePlugin开发探讨</a></p>\n<p><a href=\"https://github.com/venmo/synx?plg_nld=1&amp;plg_uin=1&amp;plg_auth=1&amp;plg_nld=1&amp;plg_usr=1&amp;plg_vkey=1&amp;plg_dev=1\">SYNX:命令行工具，重组文件结构</a></p>\n<p><a href=\"https://github.com/atConf/atswift-2016-resources\">2016中国swift开发者大会</a></p>\n<p><a href=\"http://blog.fir.im/fir_im_weekly151119/?utm_source=weibo&amp;utm_medium=link&amp;utm_content=fir_im_weekly151119\">17个提升iOS开发效率的必备工具</a></p>\n"}],"Post":[{"layout":"post","title":"IOS工具--CocoaPods","date":"2015-11-09T16:00:00.000Z","keywords":"ios","description":"ios日常工具","_content":"#前言\n学习ios的时间很短，从第一次开始，就接触了对于我来说，很庞大的项目。感谢严哥的信任。\n\n它的界面美观，功能齐全，用户众多。\n“我以后也要做一个这样的app”，我默默在心里许下愿望。\n\n我在里面看到了很多的库，应该有几十个。库的使用，很大程度上减少了我们的工作量。\n\n对于我这样的，连正式入行都还不算的学生来说，学会找到合适的库，利用库，是一项很不错的技能。\n\n很有幸，经过一个大项目，我学会了自己从网上（更多是直接在github）寻找库。\n\n#使用CocoaPods的原因\n目前我负责开发公司实验型的一个app，从基础界面，到主要功能，都要我自己去慢慢做的话，无疑要用到库。\n\n而且越到后期，我估计使用的库也会越多。\nCocoaPods的使用，可以大大节省我们的时间。\n我们不用再去重复这样的过程：\n\n1.把第三方库的源代码文件，复制到项目中。或设置成git的submodule\n\n2.手工地，将这些开源库的依赖系统的framework，一个个地添加到项目依赖中。\n\n3.对某些开源库，设置-licucore或者-fno-objc-arc登编译参数\n\n4.管理这些依赖包的更新\n\n#安装CocoaPods\n今天我自己做安装的时候，遇到了几点问题：\n\n1.ruby的软件源问题\n\n2.gem更新\n\n为了避免这些问题，我建议大家直接先更新ruby的源，再升级一次gem.做完这些工作以后，我相信安装的问题应该不大了。\n\n##ruby源替换\n一，移除原来官方的ruby源：\n\n\tgem sources --remove https://rubygems.org/\n \t \n \t \n二，替换成淘宝源：\n\n\tgem sources -a https://ruby.taobao.org/\n\t\n这里要提醒大家的是，在网上有些教程或者书籍中，使用的是http方式，现在已经改成了https。\n\n三，检查一下是否替换成功:\n\n\tgem sources -l\n \t\t\n \t\n打完之后出现下面这些的话，那么就证明成功了：\n\n\tzz:~ zzgo$ gem sources -l\n\t*** CURRENT SOURCES ***\n\n\thttps://ruby.taobao.org/\n\t\n##gem升级\ngem升级非常简单，在更换源之后，访问的限制也不存在，相信速度也非常快。只要输入如下代码：\n\n\tsudo gem update --system\n\n最后出现“RubyGems system software updated”，即为成功。\n##使用ruby的gem命令下载安装\n相信你已经迫不及待了，它的安装方式异常简单:\n\n\tsudo gem install cocoapods\n  \t\n出现“xx gems installed”，就算成功了。之后：\n\n\t pod setup\n  \t\n只要按照顺序，输入两行代码就能ok。不过在pod setup之后，还需要耐心等待一会。出现“Setup completed”就可以结束。\n\n#在项目里使用CocoaPods\n\n##Podfile\nPodfile是使用CocoaPods的关键文件。\n\n一，新建一个ios项目\n\n二，在*.xcodeproj文件的同级目录，新建一个名为Podfile的文件\n\n三，编辑Podfile文件，将依赖的库名字依次列在文件中：\n\n\t platform:ios\n\t pod 'ASIHTTPRequest', '~> 1.8.2'\n \t \n我们可以在使用之前，通过pod search命令，检查一下CocoaPods管理的库中，是否有要使用的库:\n\t\n\tzz:CocoaPodsDemo zzgo$ pod search ASIHTTP\n\n\n\t-> ASIHTTPRequest (1.8.2)\n\tEasy to use CFNetwork wrapper for HTTP requests, Objective-C, Mac OS X and iPhone.\n\tpod 'ASIHTTPRequest', '~> 1.8.2'\n\t- Homepage: http://allseeing-i.com/ASIHTTPRequest\n\t- Source:   https://github.com/pokeb/asi-http-request.git\n\t- Versions: 1.8.2, 1.8.1 [master repo]\n\t- Subspecs:\n    \t  \t- ASIHTTPRequest/Core (1.8.2)\n     \t \t- ASIHTTPRequest/ASIWebPageRequest (1.8.2)\n     \t  \t- ASIHTTPRequest/CloudFiles (1.8.2)\n     \t  \t- ASIHTTPRequest/S3 (1.8.2)\n\n\n我在上面使用了 'pod search ASIHTTP'搜索。就显示了库的信息和版本。\n\n之后就再我们的ios项目下，执行:\n\n\t  \tpod install\n\n出现类似：\n\n\tAnalyzing dependencies\n\tDownloading dependencies\n\tInstalling ASIHTTPRequest (1.8.2)\n\tGenerating Pods project\n\tIntegrating client project\n\n\t[!] From now on use `CocoaPodsDemo.xcworkspace`.\n\n\n那证明我们的第三方库已经下载完成，并且设置好了编译参数和依赖。注意：我们今后将使用提示的'*.xcworkspace'文件来打开工程。而不是原来的' *.xcodeproj'文件。\n\n打开项目，可以看到这样的结构：\n\n ![](http://7xiym9.com1.z0.glb.clouddn.com/prj.png)\n \n \n现在就可以import一下，来使用我们的库了。\n\n>本书参考：《ios开发进阶》电子工业出版社","source":"_posts/技术/2015-11-10-CocoaPosdsDemo.md","raw":"---\nlayout: post\ntitle: IOS工具--CocoaPods\ndate: 2015-11-10\ncategory: 技术\ntags: 实习工作\nkeywords: ios\ndescription: ios日常工具\n---\n#前言\n学习ios的时间很短，从第一次开始，就接触了对于我来说，很庞大的项目。感谢严哥的信任。\n\n它的界面美观，功能齐全，用户众多。\n“我以后也要做一个这样的app”，我默默在心里许下愿望。\n\n我在里面看到了很多的库，应该有几十个。库的使用，很大程度上减少了我们的工作量。\n\n对于我这样的，连正式入行都还不算的学生来说，学会找到合适的库，利用库，是一项很不错的技能。\n\n很有幸，经过一个大项目，我学会了自己从网上（更多是直接在github）寻找库。\n\n#使用CocoaPods的原因\n目前我负责开发公司实验型的一个app，从基础界面，到主要功能，都要我自己去慢慢做的话，无疑要用到库。\n\n而且越到后期，我估计使用的库也会越多。\nCocoaPods的使用，可以大大节省我们的时间。\n我们不用再去重复这样的过程：\n\n1.把第三方库的源代码文件，复制到项目中。或设置成git的submodule\n\n2.手工地，将这些开源库的依赖系统的framework，一个个地添加到项目依赖中。\n\n3.对某些开源库，设置-licucore或者-fno-objc-arc登编译参数\n\n4.管理这些依赖包的更新\n\n#安装CocoaPods\n今天我自己做安装的时候，遇到了几点问题：\n\n1.ruby的软件源问题\n\n2.gem更新\n\n为了避免这些问题，我建议大家直接先更新ruby的源，再升级一次gem.做完这些工作以后，我相信安装的问题应该不大了。\n\n##ruby源替换\n一，移除原来官方的ruby源：\n\n\tgem sources --remove https://rubygems.org/\n \t \n \t \n二，替换成淘宝源：\n\n\tgem sources -a https://ruby.taobao.org/\n\t\n这里要提醒大家的是，在网上有些教程或者书籍中，使用的是http方式，现在已经改成了https。\n\n三，检查一下是否替换成功:\n\n\tgem sources -l\n \t\t\n \t\n打完之后出现下面这些的话，那么就证明成功了：\n\n\tzz:~ zzgo$ gem sources -l\n\t*** CURRENT SOURCES ***\n\n\thttps://ruby.taobao.org/\n\t\n##gem升级\ngem升级非常简单，在更换源之后，访问的限制也不存在，相信速度也非常快。只要输入如下代码：\n\n\tsudo gem update --system\n\n最后出现“RubyGems system software updated”，即为成功。\n##使用ruby的gem命令下载安装\n相信你已经迫不及待了，它的安装方式异常简单:\n\n\tsudo gem install cocoapods\n  \t\n出现“xx gems installed”，就算成功了。之后：\n\n\t pod setup\n  \t\n只要按照顺序，输入两行代码就能ok。不过在pod setup之后，还需要耐心等待一会。出现“Setup completed”就可以结束。\n\n#在项目里使用CocoaPods\n\n##Podfile\nPodfile是使用CocoaPods的关键文件。\n\n一，新建一个ios项目\n\n二，在*.xcodeproj文件的同级目录，新建一个名为Podfile的文件\n\n三，编辑Podfile文件，将依赖的库名字依次列在文件中：\n\n\t platform:ios\n\t pod 'ASIHTTPRequest', '~> 1.8.2'\n \t \n我们可以在使用之前，通过pod search命令，检查一下CocoaPods管理的库中，是否有要使用的库:\n\t\n\tzz:CocoaPodsDemo zzgo$ pod search ASIHTTP\n\n\n\t-> ASIHTTPRequest (1.8.2)\n\tEasy to use CFNetwork wrapper for HTTP requests, Objective-C, Mac OS X and iPhone.\n\tpod 'ASIHTTPRequest', '~> 1.8.2'\n\t- Homepage: http://allseeing-i.com/ASIHTTPRequest\n\t- Source:   https://github.com/pokeb/asi-http-request.git\n\t- Versions: 1.8.2, 1.8.1 [master repo]\n\t- Subspecs:\n    \t  \t- ASIHTTPRequest/Core (1.8.2)\n     \t \t- ASIHTTPRequest/ASIWebPageRequest (1.8.2)\n     \t  \t- ASIHTTPRequest/CloudFiles (1.8.2)\n     \t  \t- ASIHTTPRequest/S3 (1.8.2)\n\n\n我在上面使用了 'pod search ASIHTTP'搜索。就显示了库的信息和版本。\n\n之后就再我们的ios项目下，执行:\n\n\t  \tpod install\n\n出现类似：\n\n\tAnalyzing dependencies\n\tDownloading dependencies\n\tInstalling ASIHTTPRequest (1.8.2)\n\tGenerating Pods project\n\tIntegrating client project\n\n\t[!] From now on use `CocoaPodsDemo.xcworkspace`.\n\n\n那证明我们的第三方库已经下载完成，并且设置好了编译参数和依赖。注意：我们今后将使用提示的'*.xcworkspace'文件来打开工程。而不是原来的' *.xcodeproj'文件。\n\n打开项目，可以看到这样的结构：\n\n ![](http://7xiym9.com1.z0.glb.clouddn.com/prj.png)\n \n \n现在就可以import一下，来使用我们的库了。\n\n>本书参考：《ios开发进阶》电子工业出版社","slug":"技术/2015-11-10-CocoaPosdsDemo","published":1,"updated":"2016-04-10T11:46:36.000Z","comments":1,"photos":[],"link":"","_id":"cisw1ptqj0003yrntd96p3ut6","content":"<p>#前言<br>学习ios的时间很短，从第一次开始，就接触了对于我来说，很庞大的项目。感谢严哥的信任。</p>\n<p>它的界面美观，功能齐全，用户众多。<br>“我以后也要做一个这样的app”，我默默在心里许下愿望。</p>\n<p>我在里面看到了很多的库，应该有几十个。库的使用，很大程度上减少了我们的工作量。</p>\n<p>对于我这样的，连正式入行都还不算的学生来说，学会找到合适的库，利用库，是一项很不错的技能。</p>\n<p>很有幸，经过一个大项目，我学会了自己从网上（更多是直接在github）寻找库。</p>\n<p>#使用CocoaPods的原因<br>目前我负责开发公司实验型的一个app，从基础界面，到主要功能，都要我自己去慢慢做的话，无疑要用到库。</p>\n<p>而且越到后期，我估计使用的库也会越多。<br>CocoaPods的使用，可以大大节省我们的时间。<br>我们不用再去重复这样的过程：</p>\n<p>1.把第三方库的源代码文件，复制到项目中。或设置成git的submodule</p>\n<p>2.手工地，将这些开源库的依赖系统的framework，一个个地添加到项目依赖中。</p>\n<p>3.对某些开源库，设置-licucore或者-fno-objc-arc登编译参数</p>\n<p>4.管理这些依赖包的更新</p>\n<p>#安装CocoaPods<br>今天我自己做安装的时候，遇到了几点问题：</p>\n<p>1.ruby的软件源问题</p>\n<p>2.gem更新</p>\n<p>为了避免这些问题，我建议大家直接先更新ruby的源，再升级一次gem.做完这些工作以后，我相信安装的问题应该不大了。</p>\n<p>##ruby源替换<br>一，移除原来官方的ruby源：</p>\n<pre><code>gem sources --remove https://rubygems.org/\n</code></pre><p>二，替换成淘宝源：</p>\n<pre><code>gem sources -a https://ruby.taobao.org/\n</code></pre><p>这里要提醒大家的是，在网上有些教程或者书籍中，使用的是http方式，现在已经改成了https。</p>\n<p>三，检查一下是否替换成功:</p>\n<pre><code>gem sources -l\n</code></pre><p>打完之后出现下面这些的话，那么就证明成功了：</p>\n<pre><code>zz:~ zzgo$ gem sources -l\n*** CURRENT SOURCES ***\n\nhttps://ruby.taobao.org/\n</code></pre><p>##gem升级<br>gem升级非常简单，在更换源之后，访问的限制也不存在，相信速度也非常快。只要输入如下代码：</p>\n<pre><code>sudo gem update --system\n</code></pre><p>最后出现“RubyGems system software updated”，即为成功。</p>\n<p>##使用ruby的gem命令下载安装<br>相信你已经迫不及待了，它的安装方式异常简单:</p>\n<pre><code>sudo gem install cocoapods\n</code></pre><p>出现“xx gems installed”，就算成功了。之后：</p>\n<pre><code>pod setup\n</code></pre><p>只要按照顺序，输入两行代码就能ok。不过在pod setup之后，还需要耐心等待一会。出现“Setup completed”就可以结束。</p>\n<p>#在项目里使用CocoaPods</p>\n<p>##Podfile<br>Podfile是使用CocoaPods的关键文件。</p>\n<p>一，新建一个ios项目</p>\n<p>二，在*.xcodeproj文件的同级目录，新建一个名为Podfile的文件</p>\n<p>三，编辑Podfile文件，将依赖的库名字依次列在文件中：</p>\n<pre><code>platform:ios\npod &apos;ASIHTTPRequest&apos;, &apos;~&gt; 1.8.2&apos;\n</code></pre><p>我们可以在使用之前，通过pod search命令，检查一下CocoaPods管理的库中，是否有要使用的库:</p>\n<pre><code>zz:CocoaPodsDemo zzgo$ pod search ASIHTTP\n\n\n-&gt; ASIHTTPRequest (1.8.2)\nEasy to use CFNetwork wrapper for HTTP requests, Objective-C, Mac OS X and iPhone.\npod &apos;ASIHTTPRequest&apos;, &apos;~&gt; 1.8.2&apos;\n- Homepage: http://allseeing-i.com/ASIHTTPRequest\n- Source:   https://github.com/pokeb/asi-http-request.git\n- Versions: 1.8.2, 1.8.1 [master repo]\n- Subspecs:\n          - ASIHTTPRequest/Core (1.8.2)\n          - ASIHTTPRequest/ASIWebPageRequest (1.8.2)\n           - ASIHTTPRequest/CloudFiles (1.8.2)\n           - ASIHTTPRequest/S3 (1.8.2)\n</code></pre><p>我在上面使用了 ‘pod search ASIHTTP’搜索。就显示了库的信息和版本。</p>\n<p>之后就再我们的ios项目下，执行:</p>\n<pre><code>pod install\n</code></pre><p>出现类似：</p>\n<pre><code>Analyzing dependencies\nDownloading dependencies\nInstalling ASIHTTPRequest (1.8.2)\nGenerating Pods project\nIntegrating client project\n\n[!] From now on use `CocoaPodsDemo.xcworkspace`.\n</code></pre><p>那证明我们的第三方库已经下载完成，并且设置好了编译参数和依赖。注意：我们今后将使用提示的’<em>.xcworkspace’文件来打开工程。而不是原来的’ </em>.xcodeproj’文件。</p>\n<p>打开项目，可以看到这样的结构：</p>\n<p> <img src=\"http://7xiym9.com1.z0.glb.clouddn.com/prj.png\" alt=\"\"></p>\n<p>现在就可以import一下，来使用我们的库了。</p>\n<blockquote>\n<p>本书参考：《ios开发进阶》电子工业出版社</p>\n</blockquote>\n","excerpt":"","more":"<p>#前言<br>学习ios的时间很短，从第一次开始，就接触了对于我来说，很庞大的项目。感谢严哥的信任。</p>\n<p>它的界面美观，功能齐全，用户众多。<br>“我以后也要做一个这样的app”，我默默在心里许下愿望。</p>\n<p>我在里面看到了很多的库，应该有几十个。库的使用，很大程度上减少了我们的工作量。</p>\n<p>对于我这样的，连正式入行都还不算的学生来说，学会找到合适的库，利用库，是一项很不错的技能。</p>\n<p>很有幸，经过一个大项目，我学会了自己从网上（更多是直接在github）寻找库。</p>\n<p>#使用CocoaPods的原因<br>目前我负责开发公司实验型的一个app，从基础界面，到主要功能，都要我自己去慢慢做的话，无疑要用到库。</p>\n<p>而且越到后期，我估计使用的库也会越多。<br>CocoaPods的使用，可以大大节省我们的时间。<br>我们不用再去重复这样的过程：</p>\n<p>1.把第三方库的源代码文件，复制到项目中。或设置成git的submodule</p>\n<p>2.手工地，将这些开源库的依赖系统的framework，一个个地添加到项目依赖中。</p>\n<p>3.对某些开源库，设置-licucore或者-fno-objc-arc登编译参数</p>\n<p>4.管理这些依赖包的更新</p>\n<p>#安装CocoaPods<br>今天我自己做安装的时候，遇到了几点问题：</p>\n<p>1.ruby的软件源问题</p>\n<p>2.gem更新</p>\n<p>为了避免这些问题，我建议大家直接先更新ruby的源，再升级一次gem.做完这些工作以后，我相信安装的问题应该不大了。</p>\n<p>##ruby源替换<br>一，移除原来官方的ruby源：</p>\n<pre><code>gem sources --remove https://rubygems.org/\n</code></pre><p>二，替换成淘宝源：</p>\n<pre><code>gem sources -a https://ruby.taobao.org/\n</code></pre><p>这里要提醒大家的是，在网上有些教程或者书籍中，使用的是http方式，现在已经改成了https。</p>\n<p>三，检查一下是否替换成功:</p>\n<pre><code>gem sources -l\n</code></pre><p>打完之后出现下面这些的话，那么就证明成功了：</p>\n<pre><code>zz:~ zzgo$ gem sources -l\n*** CURRENT SOURCES ***\n\nhttps://ruby.taobao.org/\n</code></pre><p>##gem升级<br>gem升级非常简单，在更换源之后，访问的限制也不存在，相信速度也非常快。只要输入如下代码：</p>\n<pre><code>sudo gem update --system\n</code></pre><p>最后出现“RubyGems system software updated”，即为成功。</p>\n<p>##使用ruby的gem命令下载安装<br>相信你已经迫不及待了，它的安装方式异常简单:</p>\n<pre><code>sudo gem install cocoapods\n</code></pre><p>出现“xx gems installed”，就算成功了。之后：</p>\n<pre><code>pod setup\n</code></pre><p>只要按照顺序，输入两行代码就能ok。不过在pod setup之后，还需要耐心等待一会。出现“Setup completed”就可以结束。</p>\n<p>#在项目里使用CocoaPods</p>\n<p>##Podfile<br>Podfile是使用CocoaPods的关键文件。</p>\n<p>一，新建一个ios项目</p>\n<p>二，在*.xcodeproj文件的同级目录，新建一个名为Podfile的文件</p>\n<p>三，编辑Podfile文件，将依赖的库名字依次列在文件中：</p>\n<pre><code>platform:ios\npod &apos;ASIHTTPRequest&apos;, &apos;~&gt; 1.8.2&apos;\n</code></pre><p>我们可以在使用之前，通过pod search命令，检查一下CocoaPods管理的库中，是否有要使用的库:</p>\n<pre><code>zz:CocoaPodsDemo zzgo$ pod search ASIHTTP\n\n\n-&gt; ASIHTTPRequest (1.8.2)\nEasy to use CFNetwork wrapper for HTTP requests, Objective-C, Mac OS X and iPhone.\npod &apos;ASIHTTPRequest&apos;, &apos;~&gt; 1.8.2&apos;\n- Homepage: http://allseeing-i.com/ASIHTTPRequest\n- Source:   https://github.com/pokeb/asi-http-request.git\n- Versions: 1.8.2, 1.8.1 [master repo]\n- Subspecs:\n          - ASIHTTPRequest/Core (1.8.2)\n          - ASIHTTPRequest/ASIWebPageRequest (1.8.2)\n           - ASIHTTPRequest/CloudFiles (1.8.2)\n           - ASIHTTPRequest/S3 (1.8.2)\n</code></pre><p>我在上面使用了 ‘pod search ASIHTTP’搜索。就显示了库的信息和版本。</p>\n<p>之后就再我们的ios项目下，执行:</p>\n<pre><code>pod install\n</code></pre><p>出现类似：</p>\n<pre><code>Analyzing dependencies\nDownloading dependencies\nInstalling ASIHTTPRequest (1.8.2)\nGenerating Pods project\nIntegrating client project\n\n[!] From now on use `CocoaPodsDemo.xcworkspace`.\n</code></pre><p>那证明我们的第三方库已经下载完成，并且设置好了编译参数和依赖。注意：我们今后将使用提示的’<em>.xcworkspace’文件来打开工程。而不是原来的’ </em>.xcodeproj’文件。</p>\n<p>打开项目，可以看到这样的结构：</p>\n<p> <img src=\"http://7xiym9.com1.z0.glb.clouddn.com/prj.png\" alt=\"\"></p>\n<p>现在就可以import一下，来使用我们的库了。</p>\n<blockquote>\n<p>本书参考：《ios开发进阶》电子工业出版社</p>\n</blockquote>\n"},{"layout":"post","title":"IOS开发--自定义TableView","date":"2015-10-13T16:00:00.000Z","keywords":"ios","description":"tableView进阶","_content":"# ios--自定义TableView\n一般情况来说，我们要对TableView做自定义的话。可以采用两种基本方法：\n\n1.在创建TableViewCell时，通过程序，向UITableViewCell添加子视图。\n\n2.从nib文件中，加载一组子视图。\n\n简单的来说，就是分为代码自定义方式，和nib文件自定义方式。今天我所说的，是通过代码的方式来添加子视图，完成我们的自定义TableView.\n\n我们要自定义的tableview,效果如下图：\n\n![view](http://7xiym9.com1.z0.glb.clouddn.com/tableview.png)\n\n## 创建TableView\n1.双击main.storyboard.向主视图中添加一个Table View.\n\n2.选中Table View,按下option+command+6打开关联检查器。\n将dataSource和delegate旁边的小圆圈，拖动到View Controller的图标上。完成关联。\n\n3.保持table view的选中状态，按下option+command+4打开属性检查器。滚动到View分区中，在Tag文本框中输入“1”.\n\n如果我们为视图指定了唯一的标记值，在代码中获取视图时，可以使用到它。\n\n##创建UITableViewCell子类\n\n1.创建TestCell.h和TestCell.m文件\n\n2.选中TestCell.h\n\n添加代码如下：\n\n\t#import <Foundation/Foundation.h>\n\t#import <UIKit/UIKit.h>\n\n\t//自定义Cell一定要记得，继承UITableViewCell\n\t//类TestCell的属性声明\n\t@interface TestCell : UITableViewCell\n\t@property (copy,nonatomic) NSString *name;\n\t@property (copy,nonatomic) NSString *color;\n\t@end\n\n正如注释所说，我们要创建一个新的UITableViewCell子类，那么就必须继承UITableViewCell。\n而添加的两个属性，将在接下来用到。\n\n3.单击TestCell.m\n\n添加代码如下：\n\n\t#import <Foundation/Foundation.h>\n\t#import \"TestCell.h\"\n    \n    //声明\n\t@interface TestCell()\n\n\t@property (strong,nonatomic) UILabel *nameLabel;\n\t@property (strong,nonatomic) UILabel *colorLabel;\n\n\t@end\n\n\n\n\t//类TestCell的实现\n\t@implementation TestCell\n\n\n\t//initWithStyle:reuseIdentifier:方法\n\t-(id)initWithStyle:(UITableViewCellStyle)style \n\treuseIdentifier:(NSString \t*)reuseIdentifier\n\t{\n\n    \t\tself=[super initWithStyle:style\n                reuseIdentifier:reuseIdentifier];\n    if (self) {\n        //初始化代码\n        \n        //定义name Label\n        CGRect nameLabelRect=CGRectMake(0, 5, 70, 15);//x,y,width,height\n        UILabel *nameMarker=[[UILabel alloc]\n                             initWithFrame:nameLabelRect];\n        nameMarker.textAlignment=NSTextAlignmentRight;\n        nameMarker.text=@\"Name:\";\n        nameMarker.font=[UIFont boldSystemFontOfSize:12];\n        [self.contentView addSubview:nameMarker];\n        \n        //定义color Label\n        CGRect colorLabelRect=CGRectMake(0, 26, 70, 15);\n        UILabel *colorMarker=[[UILabel alloc]\n                             initWithFrame:colorLabelRect];\n        colorMarker.textAlignment=NSTextAlignmentRight;\n        colorMarker.text=@\"Color:\";\n        colorMarker.font=[UIFont boldSystemFontOfSize:12];\n        [self.contentView addSubview:colorMarker];\n        \n        \n        //name Label右边要显示的value Label\n        CGRect nameValueRect=CGRectMake(80, 5, 200, 15);\n        _nameLabel=[[UILabel alloc]\n                    initWithFrame:nameValueRect];\n        [self.contentView addSubview:_nameLabel];\n        \n        //color Label右边要显示的value Label\n        CGRect colorValueRect=CGRectMake(80, 25, 200, 15);\n        _colorLabel=[[UILabel alloc]\n                     initWithFrame:colorValueRect];\n        [self.contentView addSubview:_colorLabel];\n        \n        \n    }\n    \t\treturn self;\n\n\t}\n\n\t-(void)setName:(NSString *)n\n\t{\n    if(![n isEqualToString:_name]){//_name为h文件中定义的name\n        _name=[n copy];\n        self.nameLabel.text=_name;\n    }\n\t}\n\t-(void)setColor:(NSString *)c\n\t{\n    if (![c isEqualToString:_color]) {\n        _color=[c copy];\n        self.colorLabel.text=_color;\n    }\n\t}\n\t@end\n\t\n\t\n上面的代码，主要是在TestCell中，定义了四个要显示的Label.以及setName和setColor的方法用于设置两个label的text的值。\n\n## 编写控制器代码\n1.单击我们的ViewController.h文件。\n\n添加代码如下：\n\n\t#import <UIKit/UIKit.h>\n\n\t@interface ViewController : \t\t\t\n\tUIViewController<UITableViewDataSource,UITableViewDelegate>\n\t@end\n\t\n\t\n上面代码的作用，是让类遵循两个协议。即：UITableViewDataSource,UITableViewDelegate。类只用遵循这两个协议，才能成为table view的委托和数据源。\n\n2.单击ViewController.m文件。\n\n添加代码如下：\n\n\t#import \"ViewController.h\"\n\t#import \"TestCell.h\"\n\n\t static NSString *CellTabIdentifier=@\"CellTableIdentifier\";\n\t\n\t\n\t@interface ViewController ()\n\t\n\t@property (copy,nonatomic) NSArray *computers;\n\t\n\t@end\n\n\n\n\t@implementation ViewController\n\n\t- (void)viewDidLoad {\n       [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n    //视图加载完成之后，通常是从nib文件加载，做额外的设置\n    self.computers=@[@{@\"Name\":@\"Macbook\",@\"Color\":@\"Silver\"},@{@\"Name\":@\"Air\",@\"Color\":@\"Silver\"},@{@\"Name\":@\"Dellbook\",@\"Color\":@\"Silver\"},@{@\"Name\":@\"AirMini\",@\"Color\":@\"Black\"}];\n    \n    //storyboard中指定的tableview,vieWithTag=1\n       UITableView *tableView=(id)[self.view viewWithTag:1];\n    //注册表单元类，以供后期反复使用。\n      [tableView registerClass:[TestCell class] \n      \t\t\tforCellReuseIdentifier:CellTabIdentifier];\n    \n      UIEdgeInsets contentInset=tableView.contentInset;\n      contentInset.top=20;\n      [tableView setContentInset:contentInset];\n\t}\n\n\t- (void)didReceiveMemoryWarning {\n    \t\t[super didReceiveMemoryWarning];\n    \t\t// Dispose of any resources that can be recreated.\n\t}\n\n\n\t//返回的section\n\t-(NSInteger)tableView:(UITableView *)tableView \n\t  numberOfRowsInSection:(NSInteger)section\n\t{\n      return [self.computers count];\n\t}\n\n\n\t-(UITableViewCell *)tableView:(UITableView *)tableView \n\t cellForRowAtIndexPath:(NSIndexPath *)indexPath\n\t{\n    //定义cell\n   \n    TestCell *cell=[tableView dequeueReusableCellWithIdentifier:CellTabIdentifier\n                    forIndexPath:indexPath];\n    \n    \n    //使用indexPath参数，确定表正在请求单元的哪一行。然后用该行的值为请求的行获取相应的字典。\n      NSDictionary *rowData=self.computers[indexPath.row];\n    \n    //使用所选行中获取的数据来填充cell(单元)\n      cell.name=rowData[@\"Name\"];\n      cell.color=rowData[@\"Color\"];\n    \n    \n      return cell;\n\t\t}\n\t\t\n\t\t\n\t@end\n\n我们需要多加注意的是viewDidLoad方法，我们在里面注册了TableViewCell子类，即我们之前定义的TestCell.还有tableView:cellForRowAtIndexPath:方法中，我们在里面使用了TestCell，以及对cell中数据的设置。\n\n完成上述步骤之后。command+R运行一下，就可以看到我们要实现的效果了。\n\n本文参考资料：\n\n>《精通IOS开发（第六版）》人民邮电出版社","source":"_posts/技术/2015-10-14-ios-TableView.md","raw":"---\nlayout: post\ntitle: IOS开发--自定义TableView\ndate: 2015-10-14\ncategory: 技术\ntags: 实习工作\nkeywords: ios\ndescription: tableView进阶\n---\n# ios--自定义TableView\n一般情况来说，我们要对TableView做自定义的话。可以采用两种基本方法：\n\n1.在创建TableViewCell时，通过程序，向UITableViewCell添加子视图。\n\n2.从nib文件中，加载一组子视图。\n\n简单的来说，就是分为代码自定义方式，和nib文件自定义方式。今天我所说的，是通过代码的方式来添加子视图，完成我们的自定义TableView.\n\n我们要自定义的tableview,效果如下图：\n\n![view](http://7xiym9.com1.z0.glb.clouddn.com/tableview.png)\n\n## 创建TableView\n1.双击main.storyboard.向主视图中添加一个Table View.\n\n2.选中Table View,按下option+command+6打开关联检查器。\n将dataSource和delegate旁边的小圆圈，拖动到View Controller的图标上。完成关联。\n\n3.保持table view的选中状态，按下option+command+4打开属性检查器。滚动到View分区中，在Tag文本框中输入“1”.\n\n如果我们为视图指定了唯一的标记值，在代码中获取视图时，可以使用到它。\n\n##创建UITableViewCell子类\n\n1.创建TestCell.h和TestCell.m文件\n\n2.选中TestCell.h\n\n添加代码如下：\n\n\t#import <Foundation/Foundation.h>\n\t#import <UIKit/UIKit.h>\n\n\t//自定义Cell一定要记得，继承UITableViewCell\n\t//类TestCell的属性声明\n\t@interface TestCell : UITableViewCell\n\t@property (copy,nonatomic) NSString *name;\n\t@property (copy,nonatomic) NSString *color;\n\t@end\n\n正如注释所说，我们要创建一个新的UITableViewCell子类，那么就必须继承UITableViewCell。\n而添加的两个属性，将在接下来用到。\n\n3.单击TestCell.m\n\n添加代码如下：\n\n\t#import <Foundation/Foundation.h>\n\t#import \"TestCell.h\"\n    \n    //声明\n\t@interface TestCell()\n\n\t@property (strong,nonatomic) UILabel *nameLabel;\n\t@property (strong,nonatomic) UILabel *colorLabel;\n\n\t@end\n\n\n\n\t//类TestCell的实现\n\t@implementation TestCell\n\n\n\t//initWithStyle:reuseIdentifier:方法\n\t-(id)initWithStyle:(UITableViewCellStyle)style \n\treuseIdentifier:(NSString \t*)reuseIdentifier\n\t{\n\n    \t\tself=[super initWithStyle:style\n                reuseIdentifier:reuseIdentifier];\n    if (self) {\n        //初始化代码\n        \n        //定义name Label\n        CGRect nameLabelRect=CGRectMake(0, 5, 70, 15);//x,y,width,height\n        UILabel *nameMarker=[[UILabel alloc]\n                             initWithFrame:nameLabelRect];\n        nameMarker.textAlignment=NSTextAlignmentRight;\n        nameMarker.text=@\"Name:\";\n        nameMarker.font=[UIFont boldSystemFontOfSize:12];\n        [self.contentView addSubview:nameMarker];\n        \n        //定义color Label\n        CGRect colorLabelRect=CGRectMake(0, 26, 70, 15);\n        UILabel *colorMarker=[[UILabel alloc]\n                             initWithFrame:colorLabelRect];\n        colorMarker.textAlignment=NSTextAlignmentRight;\n        colorMarker.text=@\"Color:\";\n        colorMarker.font=[UIFont boldSystemFontOfSize:12];\n        [self.contentView addSubview:colorMarker];\n        \n        \n        //name Label右边要显示的value Label\n        CGRect nameValueRect=CGRectMake(80, 5, 200, 15);\n        _nameLabel=[[UILabel alloc]\n                    initWithFrame:nameValueRect];\n        [self.contentView addSubview:_nameLabel];\n        \n        //color Label右边要显示的value Label\n        CGRect colorValueRect=CGRectMake(80, 25, 200, 15);\n        _colorLabel=[[UILabel alloc]\n                     initWithFrame:colorValueRect];\n        [self.contentView addSubview:_colorLabel];\n        \n        \n    }\n    \t\treturn self;\n\n\t}\n\n\t-(void)setName:(NSString *)n\n\t{\n    if(![n isEqualToString:_name]){//_name为h文件中定义的name\n        _name=[n copy];\n        self.nameLabel.text=_name;\n    }\n\t}\n\t-(void)setColor:(NSString *)c\n\t{\n    if (![c isEqualToString:_color]) {\n        _color=[c copy];\n        self.colorLabel.text=_color;\n    }\n\t}\n\t@end\n\t\n\t\n上面的代码，主要是在TestCell中，定义了四个要显示的Label.以及setName和setColor的方法用于设置两个label的text的值。\n\n## 编写控制器代码\n1.单击我们的ViewController.h文件。\n\n添加代码如下：\n\n\t#import <UIKit/UIKit.h>\n\n\t@interface ViewController : \t\t\t\n\tUIViewController<UITableViewDataSource,UITableViewDelegate>\n\t@end\n\t\n\t\n上面代码的作用，是让类遵循两个协议。即：UITableViewDataSource,UITableViewDelegate。类只用遵循这两个协议，才能成为table view的委托和数据源。\n\n2.单击ViewController.m文件。\n\n添加代码如下：\n\n\t#import \"ViewController.h\"\n\t#import \"TestCell.h\"\n\n\t static NSString *CellTabIdentifier=@\"CellTableIdentifier\";\n\t\n\t\n\t@interface ViewController ()\n\t\n\t@property (copy,nonatomic) NSArray *computers;\n\t\n\t@end\n\n\n\n\t@implementation ViewController\n\n\t- (void)viewDidLoad {\n       [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n    //视图加载完成之后，通常是从nib文件加载，做额外的设置\n    self.computers=@[@{@\"Name\":@\"Macbook\",@\"Color\":@\"Silver\"},@{@\"Name\":@\"Air\",@\"Color\":@\"Silver\"},@{@\"Name\":@\"Dellbook\",@\"Color\":@\"Silver\"},@{@\"Name\":@\"AirMini\",@\"Color\":@\"Black\"}];\n    \n    //storyboard中指定的tableview,vieWithTag=1\n       UITableView *tableView=(id)[self.view viewWithTag:1];\n    //注册表单元类，以供后期反复使用。\n      [tableView registerClass:[TestCell class] \n      \t\t\tforCellReuseIdentifier:CellTabIdentifier];\n    \n      UIEdgeInsets contentInset=tableView.contentInset;\n      contentInset.top=20;\n      [tableView setContentInset:contentInset];\n\t}\n\n\t- (void)didReceiveMemoryWarning {\n    \t\t[super didReceiveMemoryWarning];\n    \t\t// Dispose of any resources that can be recreated.\n\t}\n\n\n\t//返回的section\n\t-(NSInteger)tableView:(UITableView *)tableView \n\t  numberOfRowsInSection:(NSInteger)section\n\t{\n      return [self.computers count];\n\t}\n\n\n\t-(UITableViewCell *)tableView:(UITableView *)tableView \n\t cellForRowAtIndexPath:(NSIndexPath *)indexPath\n\t{\n    //定义cell\n   \n    TestCell *cell=[tableView dequeueReusableCellWithIdentifier:CellTabIdentifier\n                    forIndexPath:indexPath];\n    \n    \n    //使用indexPath参数，确定表正在请求单元的哪一行。然后用该行的值为请求的行获取相应的字典。\n      NSDictionary *rowData=self.computers[indexPath.row];\n    \n    //使用所选行中获取的数据来填充cell(单元)\n      cell.name=rowData[@\"Name\"];\n      cell.color=rowData[@\"Color\"];\n    \n    \n      return cell;\n\t\t}\n\t\t\n\t\t\n\t@end\n\n我们需要多加注意的是viewDidLoad方法，我们在里面注册了TableViewCell子类，即我们之前定义的TestCell.还有tableView:cellForRowAtIndexPath:方法中，我们在里面使用了TestCell，以及对cell中数据的设置。\n\n完成上述步骤之后。command+R运行一下，就可以看到我们要实现的效果了。\n\n本文参考资料：\n\n>《精通IOS开发（第六版）》人民邮电出版社","slug":"技术/2015-10-14-ios-TableView","published":1,"updated":"2016-04-10T11:47:32.000Z","comments":1,"photos":[],"link":"","_id":"cisw1ptqr0004yrnt60sqrxdy","content":"<h1 id=\"ios–自定义TableView\"><a href=\"#ios–自定义TableView\" class=\"headerlink\" title=\"ios–自定义TableView\"></a>ios–自定义TableView</h1><p>一般情况来说，我们要对TableView做自定义的话。可以采用两种基本方法：</p>\n<p>1.在创建TableViewCell时，通过程序，向UITableViewCell添加子视图。</p>\n<p>2.从nib文件中，加载一组子视图。</p>\n<p>简单的来说，就是分为代码自定义方式，和nib文件自定义方式。今天我所说的，是通过代码的方式来添加子视图，完成我们的自定义TableView.</p>\n<p>我们要自定义的tableview,效果如下图：</p>\n<p><img src=\"http://7xiym9.com1.z0.glb.clouddn.com/tableview.png\" alt=\"view\"></p>\n<h2 id=\"创建TableView\"><a href=\"#创建TableView\" class=\"headerlink\" title=\"创建TableView\"></a>创建TableView</h2><p>1.双击main.storyboard.向主视图中添加一个Table View.</p>\n<p>2.选中Table View,按下option+command+6打开关联检查器。<br>将dataSource和delegate旁边的小圆圈，拖动到View Controller的图标上。完成关联。</p>\n<p>3.保持table view的选中状态，按下option+command+4打开属性检查器。滚动到View分区中，在Tag文本框中输入“1”.</p>\n<p>如果我们为视图指定了唯一的标记值，在代码中获取视图时，可以使用到它。</p>\n<p>##创建UITableViewCell子类</p>\n<p>1.创建TestCell.h和TestCell.m文件</p>\n<p>2.选中TestCell.h</p>\n<p>添加代码如下：</p>\n<pre><code>#import &lt;Foundation/Foundation.h&gt;\n#import &lt;UIKit/UIKit.h&gt;\n\n//自定义Cell一定要记得，继承UITableViewCell\n//类TestCell的属性声明\n@interface TestCell : UITableViewCell\n@property (copy,nonatomic) NSString *name;\n@property (copy,nonatomic) NSString *color;\n@end\n</code></pre><p>正如注释所说，我们要创建一个新的UITableViewCell子类，那么就必须继承UITableViewCell。<br>而添加的两个属性，将在接下来用到。</p>\n<p>3.单击TestCell.m</p>\n<p>添加代码如下：</p>\n<pre><code>#import &lt;Foundation/Foundation.h&gt;\n#import &quot;TestCell.h&quot;\n\n//声明\n@interface TestCell()\n\n@property (strong,nonatomic) UILabel *nameLabel;\n@property (strong,nonatomic) UILabel *colorLabel;\n\n@end\n\n\n\n//类TestCell的实现\n@implementation TestCell\n\n\n//initWithStyle:reuseIdentifier:方法\n-(id)initWithStyle:(UITableViewCellStyle)style \nreuseIdentifier:(NSString     *)reuseIdentifier\n{\n\n        self=[super initWithStyle:style\n            reuseIdentifier:reuseIdentifier];\nif (self) {\n    //初始化代码\n\n    //定义name Label\n    CGRect nameLabelRect=CGRectMake(0, 5, 70, 15);//x,y,width,height\n    UILabel *nameMarker=[[UILabel alloc]\n                         initWithFrame:nameLabelRect];\n    nameMarker.textAlignment=NSTextAlignmentRight;\n    nameMarker.text=@&quot;Name:&quot;;\n    nameMarker.font=[UIFont boldSystemFontOfSize:12];\n    [self.contentView addSubview:nameMarker];\n\n    //定义color Label\n    CGRect colorLabelRect=CGRectMake(0, 26, 70, 15);\n    UILabel *colorMarker=[[UILabel alloc]\n                         initWithFrame:colorLabelRect];\n    colorMarker.textAlignment=NSTextAlignmentRight;\n    colorMarker.text=@&quot;Color:&quot;;\n    colorMarker.font=[UIFont boldSystemFontOfSize:12];\n    [self.contentView addSubview:colorMarker];\n\n\n    //name Label右边要显示的value Label\n    CGRect nameValueRect=CGRectMake(80, 5, 200, 15);\n    _nameLabel=[[UILabel alloc]\n                initWithFrame:nameValueRect];\n    [self.contentView addSubview:_nameLabel];\n\n    //color Label右边要显示的value Label\n    CGRect colorValueRect=CGRectMake(80, 25, 200, 15);\n    _colorLabel=[[UILabel alloc]\n                 initWithFrame:colorValueRect];\n    [self.contentView addSubview:_colorLabel];\n\n\n}\n        return self;\n\n}\n\n-(void)setName:(NSString *)n\n{\nif(![n isEqualToString:_name]){//_name为h文件中定义的name\n    _name=[n copy];\n    self.nameLabel.text=_name;\n}\n}\n-(void)setColor:(NSString *)c\n{\nif (![c isEqualToString:_color]) {\n    _color=[c copy];\n    self.colorLabel.text=_color;\n}\n}\n@end\n</code></pre><p>上面的代码，主要是在TestCell中，定义了四个要显示的Label.以及setName和setColor的方法用于设置两个label的text的值。</p>\n<h2 id=\"编写控制器代码\"><a href=\"#编写控制器代码\" class=\"headerlink\" title=\"编写控制器代码\"></a>编写控制器代码</h2><p>1.单击我们的ViewController.h文件。</p>\n<p>添加代码如下：</p>\n<pre><code>#import &lt;UIKit/UIKit.h&gt;\n\n@interface ViewController :             \nUIViewController&lt;UITableViewDataSource,UITableViewDelegate&gt;\n@end\n</code></pre><p>上面代码的作用，是让类遵循两个协议。即：UITableViewDataSource,UITableViewDelegate。类只用遵循这两个协议，才能成为table view的委托和数据源。</p>\n<p>2.单击ViewController.m文件。</p>\n<p>添加代码如下：</p>\n<pre><code>#import &quot;ViewController.h&quot;\n#import &quot;TestCell.h&quot;\n\n static NSString *CellTabIdentifier=@&quot;CellTableIdentifier&quot;;\n\n\n@interface ViewController ()\n\n@property (copy,nonatomic) NSArray *computers;\n\n@end\n\n\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n   [super viewDidLoad];\n// Do any additional setup after loading the view, typically from a nib.\n//视图加载完成之后，通常是从nib文件加载，做额外的设置\nself.computers=@[@{@&quot;Name&quot;:@&quot;Macbook&quot;,@&quot;Color&quot;:@&quot;Silver&quot;},@{@&quot;Name&quot;:@&quot;Air&quot;,@&quot;Color&quot;:@&quot;Silver&quot;},@{@&quot;Name&quot;:@&quot;Dellbook&quot;,@&quot;Color&quot;:@&quot;Silver&quot;},@{@&quot;Name&quot;:@&quot;AirMini&quot;,@&quot;Color&quot;:@&quot;Black&quot;}];\n\n//storyboard中指定的tableview,vieWithTag=1\n   UITableView *tableView=(id)[self.view viewWithTag:1];\n//注册表单元类，以供后期反复使用。\n  [tableView registerClass:[TestCell class] \n              forCellReuseIdentifier:CellTabIdentifier];\n\n  UIEdgeInsets contentInset=tableView.contentInset;\n  contentInset.top=20;\n  [tableView setContentInset:contentInset];\n}\n\n- (void)didReceiveMemoryWarning {\n        [super didReceiveMemoryWarning];\n        // Dispose of any resources that can be recreated.\n}\n\n\n//返回的section\n-(NSInteger)tableView:(UITableView *)tableView \n  numberOfRowsInSection:(NSInteger)section\n{\n  return [self.computers count];\n}\n\n\n-(UITableViewCell *)tableView:(UITableView *)tableView \n cellForRowAtIndexPath:(NSIndexPath *)indexPath\n{\n//定义cell\n\nTestCell *cell=[tableView dequeueReusableCellWithIdentifier:CellTabIdentifier\n                forIndexPath:indexPath];\n\n\n//使用indexPath参数，确定表正在请求单元的哪一行。然后用该行的值为请求的行获取相应的字典。\n  NSDictionary *rowData=self.computers[indexPath.row];\n\n//使用所选行中获取的数据来填充cell(单元)\n  cell.name=rowData[@&quot;Name&quot;];\n  cell.color=rowData[@&quot;Color&quot;];\n\n\n  return cell;\n    }\n\n\n@end\n</code></pre><p>我们需要多加注意的是viewDidLoad方法，我们在里面注册了TableViewCell子类，即我们之前定义的TestCell.还有tableView:cellForRowAtIndexPath:方法中，我们在里面使用了TestCell，以及对cell中数据的设置。</p>\n<p>完成上述步骤之后。command+R运行一下，就可以看到我们要实现的效果了。</p>\n<p>本文参考资料：</p>\n<blockquote>\n<p>《精通IOS开发（第六版）》人民邮电出版社</p>\n</blockquote>\n","excerpt":"","more":"<h1 id=\"ios–自定义TableView\"><a href=\"#ios–自定义TableView\" class=\"headerlink\" title=\"ios–自定义TableView\"></a>ios–自定义TableView</h1><p>一般情况来说，我们要对TableView做自定义的话。可以采用两种基本方法：</p>\n<p>1.在创建TableViewCell时，通过程序，向UITableViewCell添加子视图。</p>\n<p>2.从nib文件中，加载一组子视图。</p>\n<p>简单的来说，就是分为代码自定义方式，和nib文件自定义方式。今天我所说的，是通过代码的方式来添加子视图，完成我们的自定义TableView.</p>\n<p>我们要自定义的tableview,效果如下图：</p>\n<p><img src=\"http://7xiym9.com1.z0.glb.clouddn.com/tableview.png\" alt=\"view\"></p>\n<h2 id=\"创建TableView\"><a href=\"#创建TableView\" class=\"headerlink\" title=\"创建TableView\"></a>创建TableView</h2><p>1.双击main.storyboard.向主视图中添加一个Table View.</p>\n<p>2.选中Table View,按下option+command+6打开关联检查器。<br>将dataSource和delegate旁边的小圆圈，拖动到View Controller的图标上。完成关联。</p>\n<p>3.保持table view的选中状态，按下option+command+4打开属性检查器。滚动到View分区中，在Tag文本框中输入“1”.</p>\n<p>如果我们为视图指定了唯一的标记值，在代码中获取视图时，可以使用到它。</p>\n<p>##创建UITableViewCell子类</p>\n<p>1.创建TestCell.h和TestCell.m文件</p>\n<p>2.选中TestCell.h</p>\n<p>添加代码如下：</p>\n<pre><code>#import &lt;Foundation/Foundation.h&gt;\n#import &lt;UIKit/UIKit.h&gt;\n\n//自定义Cell一定要记得，继承UITableViewCell\n//类TestCell的属性声明\n@interface TestCell : UITableViewCell\n@property (copy,nonatomic) NSString *name;\n@property (copy,nonatomic) NSString *color;\n@end\n</code></pre><p>正如注释所说，我们要创建一个新的UITableViewCell子类，那么就必须继承UITableViewCell。<br>而添加的两个属性，将在接下来用到。</p>\n<p>3.单击TestCell.m</p>\n<p>添加代码如下：</p>\n<pre><code>#import &lt;Foundation/Foundation.h&gt;\n#import &quot;TestCell.h&quot;\n\n//声明\n@interface TestCell()\n\n@property (strong,nonatomic) UILabel *nameLabel;\n@property (strong,nonatomic) UILabel *colorLabel;\n\n@end\n\n\n\n//类TestCell的实现\n@implementation TestCell\n\n\n//initWithStyle:reuseIdentifier:方法\n-(id)initWithStyle:(UITableViewCellStyle)style \nreuseIdentifier:(NSString     *)reuseIdentifier\n{\n\n        self=[super initWithStyle:style\n            reuseIdentifier:reuseIdentifier];\nif (self) {\n    //初始化代码\n\n    //定义name Label\n    CGRect nameLabelRect=CGRectMake(0, 5, 70, 15);//x,y,width,height\n    UILabel *nameMarker=[[UILabel alloc]\n                         initWithFrame:nameLabelRect];\n    nameMarker.textAlignment=NSTextAlignmentRight;\n    nameMarker.text=@&quot;Name:&quot;;\n    nameMarker.font=[UIFont boldSystemFontOfSize:12];\n    [self.contentView addSubview:nameMarker];\n\n    //定义color Label\n    CGRect colorLabelRect=CGRectMake(0, 26, 70, 15);\n    UILabel *colorMarker=[[UILabel alloc]\n                         initWithFrame:colorLabelRect];\n    colorMarker.textAlignment=NSTextAlignmentRight;\n    colorMarker.text=@&quot;Color:&quot;;\n    colorMarker.font=[UIFont boldSystemFontOfSize:12];\n    [self.contentView addSubview:colorMarker];\n\n\n    //name Label右边要显示的value Label\n    CGRect nameValueRect=CGRectMake(80, 5, 200, 15);\n    _nameLabel=[[UILabel alloc]\n                initWithFrame:nameValueRect];\n    [self.contentView addSubview:_nameLabel];\n\n    //color Label右边要显示的value Label\n    CGRect colorValueRect=CGRectMake(80, 25, 200, 15);\n    _colorLabel=[[UILabel alloc]\n                 initWithFrame:colorValueRect];\n    [self.contentView addSubview:_colorLabel];\n\n\n}\n        return self;\n\n}\n\n-(void)setName:(NSString *)n\n{\nif(![n isEqualToString:_name]){//_name为h文件中定义的name\n    _name=[n copy];\n    self.nameLabel.text=_name;\n}\n}\n-(void)setColor:(NSString *)c\n{\nif (![c isEqualToString:_color]) {\n    _color=[c copy];\n    self.colorLabel.text=_color;\n}\n}\n@end\n</code></pre><p>上面的代码，主要是在TestCell中，定义了四个要显示的Label.以及setName和setColor的方法用于设置两个label的text的值。</p>\n<h2 id=\"编写控制器代码\"><a href=\"#编写控制器代码\" class=\"headerlink\" title=\"编写控制器代码\"></a>编写控制器代码</h2><p>1.单击我们的ViewController.h文件。</p>\n<p>添加代码如下：</p>\n<pre><code>#import &lt;UIKit/UIKit.h&gt;\n\n@interface ViewController :             \nUIViewController&lt;UITableViewDataSource,UITableViewDelegate&gt;\n@end\n</code></pre><p>上面代码的作用，是让类遵循两个协议。即：UITableViewDataSource,UITableViewDelegate。类只用遵循这两个协议，才能成为table view的委托和数据源。</p>\n<p>2.单击ViewController.m文件。</p>\n<p>添加代码如下：</p>\n<pre><code>#import &quot;ViewController.h&quot;\n#import &quot;TestCell.h&quot;\n\n static NSString *CellTabIdentifier=@&quot;CellTableIdentifier&quot;;\n\n\n@interface ViewController ()\n\n@property (copy,nonatomic) NSArray *computers;\n\n@end\n\n\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n   [super viewDidLoad];\n// Do any additional setup after loading the view, typically from a nib.\n//视图加载完成之后，通常是从nib文件加载，做额外的设置\nself.computers=@[@{@&quot;Name&quot;:@&quot;Macbook&quot;,@&quot;Color&quot;:@&quot;Silver&quot;},@{@&quot;Name&quot;:@&quot;Air&quot;,@&quot;Color&quot;:@&quot;Silver&quot;},@{@&quot;Name&quot;:@&quot;Dellbook&quot;,@&quot;Color&quot;:@&quot;Silver&quot;},@{@&quot;Name&quot;:@&quot;AirMini&quot;,@&quot;Color&quot;:@&quot;Black&quot;}];\n\n//storyboard中指定的tableview,vieWithTag=1\n   UITableView *tableView=(id)[self.view viewWithTag:1];\n//注册表单元类，以供后期反复使用。\n  [tableView registerClass:[TestCell class] \n              forCellReuseIdentifier:CellTabIdentifier];\n\n  UIEdgeInsets contentInset=tableView.contentInset;\n  contentInset.top=20;\n  [tableView setContentInset:contentInset];\n}\n\n- (void)didReceiveMemoryWarning {\n        [super didReceiveMemoryWarning];\n        // Dispose of any resources that can be recreated.\n}\n\n\n//返回的section\n-(NSInteger)tableView:(UITableView *)tableView \n  numberOfRowsInSection:(NSInteger)section\n{\n  return [self.computers count];\n}\n\n\n-(UITableViewCell *)tableView:(UITableView *)tableView \n cellForRowAtIndexPath:(NSIndexPath *)indexPath\n{\n//定义cell\n\nTestCell *cell=[tableView dequeueReusableCellWithIdentifier:CellTabIdentifier\n                forIndexPath:indexPath];\n\n\n//使用indexPath参数，确定表正在请求单元的哪一行。然后用该行的值为请求的行获取相应的字典。\n  NSDictionary *rowData=self.computers[indexPath.row];\n\n//使用所选行中获取的数据来填充cell(单元)\n  cell.name=rowData[@&quot;Name&quot;];\n  cell.color=rowData[@&quot;Color&quot;];\n\n\n  return cell;\n    }\n\n\n@end\n</code></pre><p>我们需要多加注意的是viewDidLoad方法，我们在里面注册了TableViewCell子类，即我们之前定义的TestCell.还有tableView:cellForRowAtIndexPath:方法中，我们在里面使用了TestCell，以及对cell中数据的设置。</p>\n<p>完成上述步骤之后。command+R运行一下，就可以看到我们要实现的效果了。</p>\n<p>本文参考资料：</p>\n<blockquote>\n<p>《精通IOS开发（第六版）》人民邮电出版社</p>\n</blockquote>\n"},{"layout":"post","title":"IOS工具--Reveal","date":"2015-11-10T16:00:00.000Z","keywords":"ios","description":"ios日常工具","_content":"#Reveal能做什么\nReveal是一个iOS程序界面调试工具。\n\n它的好处在于，Reveal类似Chrome的“审查元素”功能，对于我们手写ui的调试好处是显而易见的。\n\n通过使用它，我们可以方便的调试和修改应用界面。\n\n#下载Reveal\n我们可以直接通过Reveal官网来进行下载使用它，非常方便，下载后解压就可以得到。\n\n下面是官网链接：\n\n> [Reveal官网](http://revealapp.com)\n\n值得提醒的是我们解压后,reveal.app的位置和我们之后的配置有关。\n\n#配置Reveal\n在各种教程里，我推荐通过配置.lldbinit文件来使用Reveal.\n\n原因在于，它不用通过修改Xcode工程就可以加载和使用Reveal。\n\n一，进入当前用户目录,输入新建.lldbinit文件的命令:\n\n\ttouch ~/.lldbinit\n\t\n二，配置.lldbinit文件，内容如下:\n\n\t command alias reveal_load_sim expr (void*)dlopen(\"/Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/libReveal.dylib\", 0x2);\n\n\tcommand alias reveal_load_dev expr (void*)dlopen([(NSString*)[(NSBundle*)[NSBundle mainBundle] pathForResource:@\"libReveal\" ofType:@\"dylib\"] cStringUsingEncoding:0x4], 0x2);\n\n\tcommand alias reveal_start expr (void)[(NSNotificationCenter*)[NSNotificationCenter defaultCenter] postNotificationName:@\"IBARevealRequestStart\" object:nil];\n\n\tcommand alias reveal_stop expr (void)[(NSNotificationCenter*)[NSNotificationCenter defaultCenter] postNotificationName:@\"IBARevealRequestStop\" object:nil];\n\t\n以下是关于配置命令的解释：\n\t\n>reveal_load_sim 这个只在iOS模拟器上有效。它从Reveal的应用程序bundle中找到并加载libReveal.dylib（请确保你把Reveal安装到了系统的Application文件夹，如果你换地方了，你修改上述的文件）。\n\n>reveal_load_dev 这个命令在iOS设备和模拟器上都有效。不过，它需要你在Build Phase中的的Copy Bundle Resources中加上libReveal.dylib，请确保没有放到Link Binary With Libraries这个地方。\n\n>reveal_start 这个命令发出一个通知启动Reveal Server。\n\n>reveal_stop 这个命令发出一个通知停止Reveal Serve\n\n#在工程中调用Reveal\n打开我们的iOS工程,在AppDelegate.m中，找到didFinishLaunchingWithOptions方法。在其中设下一个断点。\n\n原因在于：\n\n>只有在iOS应用发出了UIApplicationDidFinishLaunchingNotification通知之后，比如应用的delegate已经处理过application::didFinishLaunchingWithOptions:之后。才能调用上面的reveal_ load_*命令，然后再调用reveal _start启动Reveal。\n\n1.增加断点，并右击给断点，选择\"Edit Brakpoint\":\n\n![](http://7xiym9.com1.z0.glb.clouddn.com/breakpoint.png)\n\n2.单击\"Action\"旁边的\"add Action\",输入\"reveal_loadsim\":\n\n![](http://7xiym9.com1.z0.glb.clouddn.com/debug.png)\n\n3.勾选“Options”上的\"Automatically continue after evaluating\"\n\n#运行Reval\n在做完以上的准备之后，只需要运行模拟器。打开Reveal，就可以使用了。\n\n如果配置成功我们会在Xcode的输出中看到类似这样的提示：\n\n![](http://7xiym9.com1.z0.glb.clouddn.com/line.png)\n\n然后在Reveal的左上角，看到启动的模拟器：\n\n![](http://7xiym9.com1.z0.glb.clouddn.com/Reveal-choose.png)\n\n选择就可以连接使用了。最后的效果如下图：\n\n![](http://7xiym9.com1.z0.glb.clouddn.com/reveal.png)\n\n\n\n\n\n\n","source":"_posts/技术/2015-11-11-Reveal.md","raw":"---\nlayout: post\ntitle: IOS工具--Reveal\ndate: 2015-11-11\ncategory: 技术\ntags: 实习工作\nkeywords: ios\ndescription: ios日常工具\n---\n#Reveal能做什么\nReveal是一个iOS程序界面调试工具。\n\n它的好处在于，Reveal类似Chrome的“审查元素”功能，对于我们手写ui的调试好处是显而易见的。\n\n通过使用它，我们可以方便的调试和修改应用界面。\n\n#下载Reveal\n我们可以直接通过Reveal官网来进行下载使用它，非常方便，下载后解压就可以得到。\n\n下面是官网链接：\n\n> [Reveal官网](http://revealapp.com)\n\n值得提醒的是我们解压后,reveal.app的位置和我们之后的配置有关。\n\n#配置Reveal\n在各种教程里，我推荐通过配置.lldbinit文件来使用Reveal.\n\n原因在于，它不用通过修改Xcode工程就可以加载和使用Reveal。\n\n一，进入当前用户目录,输入新建.lldbinit文件的命令:\n\n\ttouch ~/.lldbinit\n\t\n二，配置.lldbinit文件，内容如下:\n\n\t command alias reveal_load_sim expr (void*)dlopen(\"/Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/libReveal.dylib\", 0x2);\n\n\tcommand alias reveal_load_dev expr (void*)dlopen([(NSString*)[(NSBundle*)[NSBundle mainBundle] pathForResource:@\"libReveal\" ofType:@\"dylib\"] cStringUsingEncoding:0x4], 0x2);\n\n\tcommand alias reveal_start expr (void)[(NSNotificationCenter*)[NSNotificationCenter defaultCenter] postNotificationName:@\"IBARevealRequestStart\" object:nil];\n\n\tcommand alias reveal_stop expr (void)[(NSNotificationCenter*)[NSNotificationCenter defaultCenter] postNotificationName:@\"IBARevealRequestStop\" object:nil];\n\t\n以下是关于配置命令的解释：\n\t\n>reveal_load_sim 这个只在iOS模拟器上有效。它从Reveal的应用程序bundle中找到并加载libReveal.dylib（请确保你把Reveal安装到了系统的Application文件夹，如果你换地方了，你修改上述的文件）。\n\n>reveal_load_dev 这个命令在iOS设备和模拟器上都有效。不过，它需要你在Build Phase中的的Copy Bundle Resources中加上libReveal.dylib，请确保没有放到Link Binary With Libraries这个地方。\n\n>reveal_start 这个命令发出一个通知启动Reveal Server。\n\n>reveal_stop 这个命令发出一个通知停止Reveal Serve\n\n#在工程中调用Reveal\n打开我们的iOS工程,在AppDelegate.m中，找到didFinishLaunchingWithOptions方法。在其中设下一个断点。\n\n原因在于：\n\n>只有在iOS应用发出了UIApplicationDidFinishLaunchingNotification通知之后，比如应用的delegate已经处理过application::didFinishLaunchingWithOptions:之后。才能调用上面的reveal_ load_*命令，然后再调用reveal _start启动Reveal。\n\n1.增加断点，并右击给断点，选择\"Edit Brakpoint\":\n\n![](http://7xiym9.com1.z0.glb.clouddn.com/breakpoint.png)\n\n2.单击\"Action\"旁边的\"add Action\",输入\"reveal_loadsim\":\n\n![](http://7xiym9.com1.z0.glb.clouddn.com/debug.png)\n\n3.勾选“Options”上的\"Automatically continue after evaluating\"\n\n#运行Reval\n在做完以上的准备之后，只需要运行模拟器。打开Reveal，就可以使用了。\n\n如果配置成功我们会在Xcode的输出中看到类似这样的提示：\n\n![](http://7xiym9.com1.z0.glb.clouddn.com/line.png)\n\n然后在Reveal的左上角，看到启动的模拟器：\n\n![](http://7xiym9.com1.z0.glb.clouddn.com/Reveal-choose.png)\n\n选择就可以连接使用了。最后的效果如下图：\n\n![](http://7xiym9.com1.z0.glb.clouddn.com/reveal.png)\n\n\n\n\n\n\n","slug":"技术/2015-11-11-Reveal","published":1,"updated":"2016-04-10T11:46:26.000Z","comments":1,"photos":[],"link":"","_id":"cisw1ptqz0007yrntd5bvw8gn","content":"<p>#Reveal能做什么<br>Reveal是一个iOS程序界面调试工具。</p>\n<p>它的好处在于，Reveal类似Chrome的“审查元素”功能，对于我们手写ui的调试好处是显而易见的。</p>\n<p>通过使用它，我们可以方便的调试和修改应用界面。</p>\n<p>#下载Reveal<br>我们可以直接通过Reveal官网来进行下载使用它，非常方便，下载后解压就可以得到。</p>\n<p>下面是官网链接：</p>\n<blockquote>\n<p><a href=\"http://revealapp.com\" target=\"_blank\" rel=\"external\">Reveal官网</a></p>\n</blockquote>\n<p>值得提醒的是我们解压后,reveal.app的位置和我们之后的配置有关。</p>\n<p>#配置Reveal<br>在各种教程里，我推荐通过配置.lldbinit文件来使用Reveal.</p>\n<p>原因在于，它不用通过修改Xcode工程就可以加载和使用Reveal。</p>\n<p>一，进入当前用户目录,输入新建.lldbinit文件的命令:</p>\n<pre><code>touch ~/.lldbinit\n</code></pre><p>二，配置.lldbinit文件，内容如下:</p>\n<pre><code> command alias reveal_load_sim expr (void*)dlopen(&quot;/Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/libReveal.dylib&quot;, 0x2);\n\ncommand alias reveal_load_dev expr (void*)dlopen([(NSString*)[(NSBundle*)[NSBundle mainBundle] pathForResource:@&quot;libReveal&quot; ofType:@&quot;dylib&quot;] cStringUsingEncoding:0x4], 0x2);\n\ncommand alias reveal_start expr (void)[(NSNotificationCenter*)[NSNotificationCenter defaultCenter] postNotificationName:@&quot;IBARevealRequestStart&quot; object:nil];\n\ncommand alias reveal_stop expr (void)[(NSNotificationCenter*)[NSNotificationCenter defaultCenter] postNotificationName:@&quot;IBARevealRequestStop&quot; object:nil];\n</code></pre><p>以下是关于配置命令的解释：</p>\n<blockquote>\n<p>reveal_load_sim 这个只在iOS模拟器上有效。它从Reveal的应用程序bundle中找到并加载libReveal.dylib（请确保你把Reveal安装到了系统的Application文件夹，如果你换地方了，你修改上述的文件）。</p>\n<p>reveal_load_dev 这个命令在iOS设备和模拟器上都有效。不过，它需要你在Build Phase中的的Copy Bundle Resources中加上libReveal.dylib，请确保没有放到Link Binary With Libraries这个地方。</p>\n<p>reveal_start 这个命令发出一个通知启动Reveal Server。</p>\n<p>reveal_stop 这个命令发出一个通知停止Reveal Serve</p>\n</blockquote>\n<p>#在工程中调用Reveal<br>打开我们的iOS工程,在AppDelegate.m中，找到didFinishLaunchingWithOptions方法。在其中设下一个断点。</p>\n<p>原因在于：</p>\n<blockquote>\n<p>只有在iOS应用发出了UIApplicationDidFinishLaunchingNotification通知之后，比如应用的delegate已经处理过application::didFinishLaunchingWithOptions:之后。才能调用上面的reveal<em> load</em>*命令，然后再调用reveal _start启动Reveal。</p>\n</blockquote>\n<p>1.增加断点，并右击给断点，选择”Edit Brakpoint”:</p>\n<p><img src=\"http://7xiym9.com1.z0.glb.clouddn.com/breakpoint.png\" alt=\"\"></p>\n<p>2.单击”Action”旁边的”add Action”,输入”reveal_loadsim”:</p>\n<p><img src=\"http://7xiym9.com1.z0.glb.clouddn.com/debug.png\" alt=\"\"></p>\n<p>3.勾选“Options”上的”Automatically continue after evaluating”</p>\n<p>#运行Reval<br>在做完以上的准备之后，只需要运行模拟器。打开Reveal，就可以使用了。</p>\n<p>如果配置成功我们会在Xcode的输出中看到类似这样的提示：</p>\n<p><img src=\"http://7xiym9.com1.z0.glb.clouddn.com/line.png\" alt=\"\"></p>\n<p>然后在Reveal的左上角，看到启动的模拟器：</p>\n<p><img src=\"http://7xiym9.com1.z0.glb.clouddn.com/Reveal-choose.png\" alt=\"\"></p>\n<p>选择就可以连接使用了。最后的效果如下图：</p>\n<p><img src=\"http://7xiym9.com1.z0.glb.clouddn.com/reveal.png\" alt=\"\"></p>\n","excerpt":"","more":"<p>#Reveal能做什么<br>Reveal是一个iOS程序界面调试工具。</p>\n<p>它的好处在于，Reveal类似Chrome的“审查元素”功能，对于我们手写ui的调试好处是显而易见的。</p>\n<p>通过使用它，我们可以方便的调试和修改应用界面。</p>\n<p>#下载Reveal<br>我们可以直接通过Reveal官网来进行下载使用它，非常方便，下载后解压就可以得到。</p>\n<p>下面是官网链接：</p>\n<blockquote>\n<p><a href=\"http://revealapp.com\">Reveal官网</a></p>\n</blockquote>\n<p>值得提醒的是我们解压后,reveal.app的位置和我们之后的配置有关。</p>\n<p>#配置Reveal<br>在各种教程里，我推荐通过配置.lldbinit文件来使用Reveal.</p>\n<p>原因在于，它不用通过修改Xcode工程就可以加载和使用Reveal。</p>\n<p>一，进入当前用户目录,输入新建.lldbinit文件的命令:</p>\n<pre><code>touch ~/.lldbinit\n</code></pre><p>二，配置.lldbinit文件，内容如下:</p>\n<pre><code> command alias reveal_load_sim expr (void*)dlopen(&quot;/Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/libReveal.dylib&quot;, 0x2);\n\ncommand alias reveal_load_dev expr (void*)dlopen([(NSString*)[(NSBundle*)[NSBundle mainBundle] pathForResource:@&quot;libReveal&quot; ofType:@&quot;dylib&quot;] cStringUsingEncoding:0x4], 0x2);\n\ncommand alias reveal_start expr (void)[(NSNotificationCenter*)[NSNotificationCenter defaultCenter] postNotificationName:@&quot;IBARevealRequestStart&quot; object:nil];\n\ncommand alias reveal_stop expr (void)[(NSNotificationCenter*)[NSNotificationCenter defaultCenter] postNotificationName:@&quot;IBARevealRequestStop&quot; object:nil];\n</code></pre><p>以下是关于配置命令的解释：</p>\n<blockquote>\n<p>reveal_load_sim 这个只在iOS模拟器上有效。它从Reveal的应用程序bundle中找到并加载libReveal.dylib（请确保你把Reveal安装到了系统的Application文件夹，如果你换地方了，你修改上述的文件）。</p>\n<p>reveal_load_dev 这个命令在iOS设备和模拟器上都有效。不过，它需要你在Build Phase中的的Copy Bundle Resources中加上libReveal.dylib，请确保没有放到Link Binary With Libraries这个地方。</p>\n<p>reveal_start 这个命令发出一个通知启动Reveal Server。</p>\n<p>reveal_stop 这个命令发出一个通知停止Reveal Serve</p>\n</blockquote>\n<p>#在工程中调用Reveal<br>打开我们的iOS工程,在AppDelegate.m中，找到didFinishLaunchingWithOptions方法。在其中设下一个断点。</p>\n<p>原因在于：</p>\n<blockquote>\n<p>只有在iOS应用发出了UIApplicationDidFinishLaunchingNotification通知之后，比如应用的delegate已经处理过application::didFinishLaunchingWithOptions:之后。才能调用上面的reveal<em> load</em>*命令，然后再调用reveal _start启动Reveal。</p>\n</blockquote>\n<p>1.增加断点，并右击给断点，选择”Edit Brakpoint”:</p>\n<p><img src=\"http://7xiym9.com1.z0.glb.clouddn.com/breakpoint.png\" alt=\"\"></p>\n<p>2.单击”Action”旁边的”add Action”,输入”reveal_loadsim”:</p>\n<p><img src=\"http://7xiym9.com1.z0.glb.clouddn.com/debug.png\" alt=\"\"></p>\n<p>3.勾选“Options”上的”Automatically continue after evaluating”</p>\n<p>#运行Reval<br>在做完以上的准备之后，只需要运行模拟器。打开Reveal，就可以使用了。</p>\n<p>如果配置成功我们会在Xcode的输出中看到类似这样的提示：</p>\n<p><img src=\"http://7xiym9.com1.z0.glb.clouddn.com/line.png\" alt=\"\"></p>\n<p>然后在Reveal的左上角，看到启动的模拟器：</p>\n<p><img src=\"http://7xiym9.com1.z0.glb.clouddn.com/Reveal-choose.png\" alt=\"\"></p>\n<p>选择就可以连接使用了。最后的效果如下图：</p>\n<p><img src=\"http://7xiym9.com1.z0.glb.clouddn.com/reveal.png\" alt=\"\"></p>\n"},{"layout":"post","title":"IOS开发--自定义Debug文件","date":"2015-11-05T16:00:00.000Z","keywords":"ios","description":"ios日常工具","_content":"\n今天介绍一段代码，用于在执行程序的时候，显示控制器的名称。\n在我们debug的时候比较有用，尤其是项目文件比较多的时候。可以减少我们的功夫，直接的看出问题出在哪一个controller里。\n\n直接在对应的工程下，新建一个xxxDebug.m文件。\n\n文件代码如下：\n\n    #import <UIKit/UIKit.h>\n    #import <objc/runtime.h>\n\n    /**\n    *  这个类只做调试用\n    */\n    @implementation UIViewController (DFDebug)\n\n    - (void)zz_viewDidAppear:(BOOL)animated\n    {\n    [self zz_viewDidAppear:animated];\n    NSLog(@\"Debug by zzgo ==> %@\", NSStringFromClass([self class]));\n    }\n\n    + (void)load\n    {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n    Class class = [self class];\n\n    SEL originalSelector = @selector(viewDidAppear:);\n    SEL swizzledSelector = @selector(zz_viewDidAppear:);\n\n    Method originalMethod = class_getInstanceMethod(class, originalSelector);\n    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n\n    method_exchangeImplementations(originalMethod, swizzledMethod);\n    });\n    }\n\n    @end\n\n\n\n \n","source":"_posts/技术/2015-11-6-ViewControllerDebug.md","raw":"---\nlayout: post\ntitle: IOS开发--自定义Debug文件\ndate: 2015-11-06\ncategory: 技术\ntags: 实习工作\nkeywords: ios\ndescription: ios日常工具\n---\n\n今天介绍一段代码，用于在执行程序的时候，显示控制器的名称。\n在我们debug的时候比较有用，尤其是项目文件比较多的时候。可以减少我们的功夫，直接的看出问题出在哪一个controller里。\n\n直接在对应的工程下，新建一个xxxDebug.m文件。\n\n文件代码如下：\n\n    #import <UIKit/UIKit.h>\n    #import <objc/runtime.h>\n\n    /**\n    *  这个类只做调试用\n    */\n    @implementation UIViewController (DFDebug)\n\n    - (void)zz_viewDidAppear:(BOOL)animated\n    {\n    [self zz_viewDidAppear:animated];\n    NSLog(@\"Debug by zzgo ==> %@\", NSStringFromClass([self class]));\n    }\n\n    + (void)load\n    {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n    Class class = [self class];\n\n    SEL originalSelector = @selector(viewDidAppear:);\n    SEL swizzledSelector = @selector(zz_viewDidAppear:);\n\n    Method originalMethod = class_getInstanceMethod(class, originalSelector);\n    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n\n    method_exchangeImplementations(originalMethod, swizzledMethod);\n    });\n    }\n\n    @end\n\n\n\n \n","slug":"技术/2015-11-6-ViewControllerDebug","published":1,"updated":"2016-04-10T11:46:52.000Z","comments":1,"photos":[],"link":"","_id":"cisw1ptr20008yrnt1jx5hg5y","content":"<p>今天介绍一段代码，用于在执行程序的时候，显示控制器的名称。<br>在我们debug的时候比较有用，尤其是项目文件比较多的时候。可以减少我们的功夫，直接的看出问题出在哪一个controller里。</p>\n<p>直接在对应的工程下，新建一个xxxDebug.m文件。</p>\n<p>文件代码如下：</p>\n<pre><code>#import &lt;UIKit/UIKit.h&gt;\n#import &lt;objc/runtime.h&gt;\n\n/**\n*  这个类只做调试用\n*/\n@implementation UIViewController (DFDebug)\n\n- (void)zz_viewDidAppear:(BOOL)animated\n{\n[self zz_viewDidAppear:animated];\nNSLog(@&quot;Debug by zzgo ==&gt; %@&quot;, NSStringFromClass([self class]));\n}\n\n+ (void)load\n{\nstatic dispatch_once_t onceToken;\ndispatch_once(&amp;onceToken, ^{\nClass class = [self class];\n\nSEL originalSelector = @selector(viewDidAppear:);\nSEL swizzledSelector = @selector(zz_viewDidAppear:);\n\nMethod originalMethod = class_getInstanceMethod(class, originalSelector);\nMethod swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n\nmethod_exchangeImplementations(originalMethod, swizzledMethod);\n});\n}\n\n@end\n</code></pre>","excerpt":"","more":"<p>今天介绍一段代码，用于在执行程序的时候，显示控制器的名称。<br>在我们debug的时候比较有用，尤其是项目文件比较多的时候。可以减少我们的功夫，直接的看出问题出在哪一个controller里。</p>\n<p>直接在对应的工程下，新建一个xxxDebug.m文件。</p>\n<p>文件代码如下：</p>\n<pre><code>#import &lt;UIKit/UIKit.h&gt;\n#import &lt;objc/runtime.h&gt;\n\n/**\n*  这个类只做调试用\n*/\n@implementation UIViewController (DFDebug)\n\n- (void)zz_viewDidAppear:(BOOL)animated\n{\n[self zz_viewDidAppear:animated];\nNSLog(@&quot;Debug by zzgo ==&gt; %@&quot;, NSStringFromClass([self class]));\n}\n\n+ (void)load\n{\nstatic dispatch_once_t onceToken;\ndispatch_once(&amp;onceToken, ^{\nClass class = [self class];\n\nSEL originalSelector = @selector(viewDidAppear:);\nSEL swizzledSelector = @selector(zz_viewDidAppear:);\n\nMethod originalMethod = class_getInstanceMethod(class, originalSelector);\nMethod swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n\nmethod_exchangeImplementations(originalMethod, swizzledMethod);\n});\n}\n\n@end\n</code></pre>"},{"layout":"post","title":"Xcode插件","date":"2015-11-14T16:00:00.000Z","keywords":"ios","description":"ios日常工具","_content":"在日常开发中，使用合适的插件，可以提高开发的效率。让我们更集中精力在处理代码的逻辑上。\n\n#Alcatraz\n\nAlcatraz是用来管理Xcode插件，模板和颜色配置的工具。\n\n我们很容易就可以安装它。\n\n首先关闭Xcode.\n\n在命令行里使用如下代码：\n\n\tcurl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh\n\t\n如果不想使用了，可以用下面的命令删除：\n\n\trm -rf ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin\n\t\n最后出现\"xxxsuccessfu! \"的字样，就是安装成功了。\n\n重启Xcode.\n\n在Xcode的顶部菜单栏，找到Window选项，可以看到“PackageManager”的选项。\n\n单击它，就可以启动插件列表界面，搜索自己想要的插件下载。\n\n#常用插件介绍\n\n##KSImageNamed\n\n开发时，经常不得不频繁查看资源文件夹以查找合适的图片的名称。使用KSImageNamed插件后，会自动弹出图片名称的列表以供选择，而且还有缩略图，十分便捷。\n\n当你输入[UIImage imageNamed:]时，会自动弹出上下文菜单，供你选择你需要输入的图片资源名称。选择图片资源时，还能在左侧预览。\n\n##XVim\n这里要重点介绍一下XVim.\n\n它的功能是可以在Xcode的编辑窗口中开启vim模式。\n\nvim的最大好处，是可以全键盘操作，可以方便的移动光标，以及复制，粘贴代码。\n\n想一想，当我们可以去掉鼠标，全心放在代码输入上的时候该多舒服。而不是再用鼠标滑动一下，按一下，再放到键盘上去。\n\n每天我们这的重复操作耗去了很多时间。\n\n当我们学会用vim进行全键盘操作时，该是多么酷。\n\n同时也可以培养我们在最原始的情况下，进行程序编写的能力，让它成为自己短小锋利的编程武器。\n\n##FuzzyAutocompletePlugin\n\n它允许使用模糊的方式来进行代码的自动补全。\n\n相信很多人和我一样，在输入tableView的方法时很讨厌输入那么多才把方法打出来。\n\n使用它之后，我们只要依次输入方法的任意字母（不过一定要按单词出现顺序），即可匹配到对应的方法。\n\n例如要重载viewDidAppear:,只要输入“veapp”这样的单词就可以了\n\n##ColorSense\n\n它和KSImageNamed一样，也是一个输入辅助工具。不过是关于UIColor颜色的，在编写UIColor时，可以实时预览响应的颜色。\n\n##ClangFormat\n\n它是一个自动调整代码风格的工具。\n\nXcode本身的代码缩进自动调整功能比较弱，特别是对于JSON格式。\n\n它可以更好的排版，并且内置各种风格，也支持自定义风格。\n\n\n##XcodeBoost\n\nXcodeBoost包含多个辅助修改代码的小功能。\n\n通过配置，我们可以使用光标,或者不精确的选择就可以剪切或者拷贝代码行，可以在粘贴代码的时候不触发代码格式化，还可以通过在.m文件中拷贝方法，粘贴进.h文件的时候就可以得到自动格式成的方法声明，还有好些功能都可以实现。\n\n参考：\n\n>《iOS进阶》唐巧\n\n>[慕课网](http://www.imooc.com/article/2115)\n\n\n\n\n\n","source":"_posts/技术/2015-11-15-XcodePlugs.md","raw":"---\nlayout: post\ntitle: Xcode插件\ndate: 2015-11-15\ncategory: 技术\ntags: 实习工作\nkeywords: ios\ndescription: ios日常工具\n---\n在日常开发中，使用合适的插件，可以提高开发的效率。让我们更集中精力在处理代码的逻辑上。\n\n#Alcatraz\n\nAlcatraz是用来管理Xcode插件，模板和颜色配置的工具。\n\n我们很容易就可以安装它。\n\n首先关闭Xcode.\n\n在命令行里使用如下代码：\n\n\tcurl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh\n\t\n如果不想使用了，可以用下面的命令删除：\n\n\trm -rf ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin\n\t\n最后出现\"xxxsuccessfu! \"的字样，就是安装成功了。\n\n重启Xcode.\n\n在Xcode的顶部菜单栏，找到Window选项，可以看到“PackageManager”的选项。\n\n单击它，就可以启动插件列表界面，搜索自己想要的插件下载。\n\n#常用插件介绍\n\n##KSImageNamed\n\n开发时，经常不得不频繁查看资源文件夹以查找合适的图片的名称。使用KSImageNamed插件后，会自动弹出图片名称的列表以供选择，而且还有缩略图，十分便捷。\n\n当你输入[UIImage imageNamed:]时，会自动弹出上下文菜单，供你选择你需要输入的图片资源名称。选择图片资源时，还能在左侧预览。\n\n##XVim\n这里要重点介绍一下XVim.\n\n它的功能是可以在Xcode的编辑窗口中开启vim模式。\n\nvim的最大好处，是可以全键盘操作，可以方便的移动光标，以及复制，粘贴代码。\n\n想一想，当我们可以去掉鼠标，全心放在代码输入上的时候该多舒服。而不是再用鼠标滑动一下，按一下，再放到键盘上去。\n\n每天我们这的重复操作耗去了很多时间。\n\n当我们学会用vim进行全键盘操作时，该是多么酷。\n\n同时也可以培养我们在最原始的情况下，进行程序编写的能力，让它成为自己短小锋利的编程武器。\n\n##FuzzyAutocompletePlugin\n\n它允许使用模糊的方式来进行代码的自动补全。\n\n相信很多人和我一样，在输入tableView的方法时很讨厌输入那么多才把方法打出来。\n\n使用它之后，我们只要依次输入方法的任意字母（不过一定要按单词出现顺序），即可匹配到对应的方法。\n\n例如要重载viewDidAppear:,只要输入“veapp”这样的单词就可以了\n\n##ColorSense\n\n它和KSImageNamed一样，也是一个输入辅助工具。不过是关于UIColor颜色的，在编写UIColor时，可以实时预览响应的颜色。\n\n##ClangFormat\n\n它是一个自动调整代码风格的工具。\n\nXcode本身的代码缩进自动调整功能比较弱，特别是对于JSON格式。\n\n它可以更好的排版，并且内置各种风格，也支持自定义风格。\n\n\n##XcodeBoost\n\nXcodeBoost包含多个辅助修改代码的小功能。\n\n通过配置，我们可以使用光标,或者不精确的选择就可以剪切或者拷贝代码行，可以在粘贴代码的时候不触发代码格式化，还可以通过在.m文件中拷贝方法，粘贴进.h文件的时候就可以得到自动格式成的方法声明，还有好些功能都可以实现。\n\n参考：\n\n>《iOS进阶》唐巧\n\n>[慕课网](http://www.imooc.com/article/2115)\n\n\n\n\n\n","slug":"技术/2015-11-15-XcodePlugs","published":1,"updated":"2016-04-09T13:58:08.000Z","comments":1,"photos":[],"link":"","_id":"cisw1ptr4000ayrntdy2lujs4","content":"<p>在日常开发中，使用合适的插件，可以提高开发的效率。让我们更集中精力在处理代码的逻辑上。</p>\n<p>#Alcatraz</p>\n<p>Alcatraz是用来管理Xcode插件，模板和颜色配置的工具。</p>\n<p>我们很容易就可以安装它。</p>\n<p>首先关闭Xcode.</p>\n<p>在命令行里使用如下代码：</p>\n<pre><code>curl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh\n</code></pre><p>如果不想使用了，可以用下面的命令删除：</p>\n<pre><code>rm -rf ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin\n</code></pre><p>最后出现”xxxsuccessfu! “的字样，就是安装成功了。</p>\n<p>重启Xcode.</p>\n<p>在Xcode的顶部菜单栏，找到Window选项，可以看到“PackageManager”的选项。</p>\n<p>单击它，就可以启动插件列表界面，搜索自己想要的插件下载。</p>\n<p>#常用插件介绍</p>\n<p>##KSImageNamed</p>\n<p>开发时，经常不得不频繁查看资源文件夹以查找合适的图片的名称。使用KSImageNamed插件后，会自动弹出图片名称的列表以供选择，而且还有缩略图，十分便捷。</p>\n<p>当你输入[UIImage imageNamed:]时，会自动弹出上下文菜单，供你选择你需要输入的图片资源名称。选择图片资源时，还能在左侧预览。</p>\n<p>##XVim<br>这里要重点介绍一下XVim.</p>\n<p>它的功能是可以在Xcode的编辑窗口中开启vim模式。</p>\n<p>vim的最大好处，是可以全键盘操作，可以方便的移动光标，以及复制，粘贴代码。</p>\n<p>想一想，当我们可以去掉鼠标，全心放在代码输入上的时候该多舒服。而不是再用鼠标滑动一下，按一下，再放到键盘上去。</p>\n<p>每天我们这的重复操作耗去了很多时间。</p>\n<p>当我们学会用vim进行全键盘操作时，该是多么酷。</p>\n<p>同时也可以培养我们在最原始的情况下，进行程序编写的能力，让它成为自己短小锋利的编程武器。</p>\n<p>##FuzzyAutocompletePlugin</p>\n<p>它允许使用模糊的方式来进行代码的自动补全。</p>\n<p>相信很多人和我一样，在输入tableView的方法时很讨厌输入那么多才把方法打出来。</p>\n<p>使用它之后，我们只要依次输入方法的任意字母（不过一定要按单词出现顺序），即可匹配到对应的方法。</p>\n<p>例如要重载viewDidAppear:,只要输入“veapp”这样的单词就可以了</p>\n<p>##ColorSense</p>\n<p>它和KSImageNamed一样，也是一个输入辅助工具。不过是关于UIColor颜色的，在编写UIColor时，可以实时预览响应的颜色。</p>\n<p>##ClangFormat</p>\n<p>它是一个自动调整代码风格的工具。</p>\n<p>Xcode本身的代码缩进自动调整功能比较弱，特别是对于JSON格式。</p>\n<p>它可以更好的排版，并且内置各种风格，也支持自定义风格。</p>\n<p>##XcodeBoost</p>\n<p>XcodeBoost包含多个辅助修改代码的小功能。</p>\n<p>通过配置，我们可以使用光标,或者不精确的选择就可以剪切或者拷贝代码行，可以在粘贴代码的时候不触发代码格式化，还可以通过在.m文件中拷贝方法，粘贴进.h文件的时候就可以得到自动格式成的方法声明，还有好些功能都可以实现。</p>\n<p>参考：</p>\n<blockquote>\n<p>《iOS进阶》唐巧</p>\n<p><a href=\"http://www.imooc.com/article/2115\" target=\"_blank\" rel=\"external\">慕课网</a></p>\n</blockquote>\n","excerpt":"","more":"<p>在日常开发中，使用合适的插件，可以提高开发的效率。让我们更集中精力在处理代码的逻辑上。</p>\n<p>#Alcatraz</p>\n<p>Alcatraz是用来管理Xcode插件，模板和颜色配置的工具。</p>\n<p>我们很容易就可以安装它。</p>\n<p>首先关闭Xcode.</p>\n<p>在命令行里使用如下代码：</p>\n<pre><code>curl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh\n</code></pre><p>如果不想使用了，可以用下面的命令删除：</p>\n<pre><code>rm -rf ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin\n</code></pre><p>最后出现”xxxsuccessfu! “的字样，就是安装成功了。</p>\n<p>重启Xcode.</p>\n<p>在Xcode的顶部菜单栏，找到Window选项，可以看到“PackageManager”的选项。</p>\n<p>单击它，就可以启动插件列表界面，搜索自己想要的插件下载。</p>\n<p>#常用插件介绍</p>\n<p>##KSImageNamed</p>\n<p>开发时，经常不得不频繁查看资源文件夹以查找合适的图片的名称。使用KSImageNamed插件后，会自动弹出图片名称的列表以供选择，而且还有缩略图，十分便捷。</p>\n<p>当你输入[UIImage imageNamed:]时，会自动弹出上下文菜单，供你选择你需要输入的图片资源名称。选择图片资源时，还能在左侧预览。</p>\n<p>##XVim<br>这里要重点介绍一下XVim.</p>\n<p>它的功能是可以在Xcode的编辑窗口中开启vim模式。</p>\n<p>vim的最大好处，是可以全键盘操作，可以方便的移动光标，以及复制，粘贴代码。</p>\n<p>想一想，当我们可以去掉鼠标，全心放在代码输入上的时候该多舒服。而不是再用鼠标滑动一下，按一下，再放到键盘上去。</p>\n<p>每天我们这的重复操作耗去了很多时间。</p>\n<p>当我们学会用vim进行全键盘操作时，该是多么酷。</p>\n<p>同时也可以培养我们在最原始的情况下，进行程序编写的能力，让它成为自己短小锋利的编程武器。</p>\n<p>##FuzzyAutocompletePlugin</p>\n<p>它允许使用模糊的方式来进行代码的自动补全。</p>\n<p>相信很多人和我一样，在输入tableView的方法时很讨厌输入那么多才把方法打出来。</p>\n<p>使用它之后，我们只要依次输入方法的任意字母（不过一定要按单词出现顺序），即可匹配到对应的方法。</p>\n<p>例如要重载viewDidAppear:,只要输入“veapp”这样的单词就可以了</p>\n<p>##ColorSense</p>\n<p>它和KSImageNamed一样，也是一个输入辅助工具。不过是关于UIColor颜色的，在编写UIColor时，可以实时预览响应的颜色。</p>\n<p>##ClangFormat</p>\n<p>它是一个自动调整代码风格的工具。</p>\n<p>Xcode本身的代码缩进自动调整功能比较弱，特别是对于JSON格式。</p>\n<p>它可以更好的排版，并且内置各种风格，也支持自定义风格。</p>\n<p>##XcodeBoost</p>\n<p>XcodeBoost包含多个辅助修改代码的小功能。</p>\n<p>通过配置，我们可以使用光标,或者不精确的选择就可以剪切或者拷贝代码行，可以在粘贴代码的时候不触发代码格式化，还可以通过在.m文件中拷贝方法，粘贴进.h文件的时候就可以得到自动格式成的方法声明，还有好些功能都可以实现。</p>\n<p>参考：</p>\n<blockquote>\n<p>《iOS进阶》唐巧</p>\n<p><a href=\"http://www.imooc.com/article/2115\">慕课网</a></p>\n</blockquote>\n"},{"layout":"post","title":"iOS设计模式(一)","date":"2015-11-11T16:00:00.000Z","keywords":"ios,设计模式","description":"object-c,ios,设计模式","_content":"#为什么学习设计模式\n在明白为什么学习设计模式之前，这学期我第一次在学校上了软件工程这门课。\n\n课上老师有一个思想和说法，令我耳目一新，改变了我原有对于软件开发的认识，大概意思是:\n\n>与建筑工程这类看的见的实体工程一样，我们的软件开发也是一项真正的工程。我们需要结构的设计，来保证安全，美观，好用。也需要合理的分工，来达到最好的结果。\n\n从此，我对待软件开发的学习态度也大不一样，我知道自己开发的不是什么随随便便的小东西——而是运用真正的科学技术，去开发的软件工程。\n\n因此不应该盲目地copy，随便用廉价的代码去拼凑。那样出来的，只是豆腐渣工程。\n\n我苦于自己代码糟糕的结构，以及臃肿的controller。\n\n直到阅读到前辈们的博客，给了我指引。其中一个关键就是设计模式的运用。\n\n设计模式是有用的抽象化工具，相当于一个对象或类的设计模板，用来解决特定领域经常发生的问题。\n\n#设计模式的起源\nMVC模式，顾名思义，它是这样一种模式:\n\n>模型Model-视图View-控制器Controller\n\n听起来很简单。\n\n其实到今天，我才开始真正理解它。它本身其实并不是最基本的设计模式。\n\n它至少在Samlltalk诞生初期就已经出现。在mvc设计模式中，对象被分为模型，视图，控制器。它是Cocoa Touch中很多机制和技术的基础。\n\n##在模型对象中，封装数据和基本行为\n模型对象，用于维护应用程序的数据，并定义操作数据的特定逻辑。\n\n只要加载的是包含有应用程序永久信息的数据，就应该将其放入模型对象。\n\n如果是理想状态，模型对象与对其进行显示和编辑的用户界面，不应有任何的直接关联。\n\n##使用视图对象，向用户展示信息\n视图对象，可以响应用户的操作，并懂得如何将自己展现在屏幕上。\n\n视图对象通常从应用程序的模型对象获取数据，用于展示。\n\n值得注意的是，虽然视图对象与模型对象关系密切，但是在MVC应用程序中，它们之间没有耦合。\n\n##用控制器对象，联系起模型和视图\n\n控制器对象，就是是视图对象和模型对象的中间人。\n\n控制器对象就像一个厨师，模型对象是材料，视图对象是服务员，厨师烹饪对应的材料，然后交由我们的视图对象进行呈现。\n\n除了协调作用之外，控制器还可以执行其他的操作。\n\n##作为复合模式的MVC\n\nMVC模式包含了若干更加基本的设计模式。在Cocoa(Touch)的MVC有:\n\n>组合（Composite）\n>视图对象之间，以协作方式，构成一个视图层次结构体系。\n>其中既可以有复合视图，也可以有独立视图。\n>每个层次的每个视图节点，都可以响应用户的操作，并把自己绘制到屏幕上。\n\n>命令(Command）\n>这是一种“目标-动作”机制，视图对象可以推迟其他对象的执行。\n>让其他对象等到发生了某些事件后，再执行。\n\n>中介者(Mdediator)\n>控制器对象，采用了中介模式。构成了模型对象和视图对象之间传递数据的双向通道。\n>应用程序的控制器对象，将模型的变更，传达给视图对象。\n\n>策略(Strategy)\n>控制器对象，可以是视图对象的一个“策略”。\n\n>视图对象，将自身隔离，以期维持其作为数据展示器的唯一职责。而将一切应用程序特有的界面行为的决定，委派给它的“策略”对象。\n\n>观察者(Observer)\n>模型对象向它所关注的控制器对象，发出内部状态变化的通知。\n\n\n#针对接口编程，而不是针对实现编程\n\n作为一个软件开发人员，很多人甚至已经学习了多门面向对象的语言。对于类，对象，继承，多态，接口的概念相信都已经理解了。\n\n但是类继承与接口继承的区别在哪里？\n\n接口定义了类型，接口继承让我们可以用一个对象，代替另一个对象。\n\n类继承，是通过复用父类的功能或者只是简单的共享代码和表述，来定义对象的实现和类型的一种机制。\n\n##@protocal与抽象基类\n\n我们要针对接口编程，而在Object-C中，有一种称为协议的语言功能(语法为@protocal)。\n\n协议不定义任何实现，而只声明方法，以确定符合协议的类的行为。\n\n因此，协议是只定义抽象行为的\"接口\"。\n\n实现协议的类定义这些方法的实现，来执行真正的操作。\n\n另一种定义高度抽象类型的方法，是定义抽象基类。\n\n通过抽象基类，我们可以生成一些其他子类可以共享的默认行为。\n\n\n时间仓促，只学习了一些设计模式的概念。但是感觉受益不小。希望和我一样学习设计模式的同学可以多多交流，共同进步！\n\n参考:\n\n>《Object-C编程之道（iOS设计模式解析）》人民邮电出版社","source":"_posts/技术/2015-11-12-DesignPatterns.md","raw":"---\nlayout: post\ntitle: iOS设计模式(一)\ndate: 2015-11-12\ncategory: 技术\ntags: 实习工作\nkeywords: ios,设计模式\ndescription: object-c,ios,设计模式\n---\n#为什么学习设计模式\n在明白为什么学习设计模式之前，这学期我第一次在学校上了软件工程这门课。\n\n课上老师有一个思想和说法，令我耳目一新，改变了我原有对于软件开发的认识，大概意思是:\n\n>与建筑工程这类看的见的实体工程一样，我们的软件开发也是一项真正的工程。我们需要结构的设计，来保证安全，美观，好用。也需要合理的分工，来达到最好的结果。\n\n从此，我对待软件开发的学习态度也大不一样，我知道自己开发的不是什么随随便便的小东西——而是运用真正的科学技术，去开发的软件工程。\n\n因此不应该盲目地copy，随便用廉价的代码去拼凑。那样出来的，只是豆腐渣工程。\n\n我苦于自己代码糟糕的结构，以及臃肿的controller。\n\n直到阅读到前辈们的博客，给了我指引。其中一个关键就是设计模式的运用。\n\n设计模式是有用的抽象化工具，相当于一个对象或类的设计模板，用来解决特定领域经常发生的问题。\n\n#设计模式的起源\nMVC模式，顾名思义，它是这样一种模式:\n\n>模型Model-视图View-控制器Controller\n\n听起来很简单。\n\n其实到今天，我才开始真正理解它。它本身其实并不是最基本的设计模式。\n\n它至少在Samlltalk诞生初期就已经出现。在mvc设计模式中，对象被分为模型，视图，控制器。它是Cocoa Touch中很多机制和技术的基础。\n\n##在模型对象中，封装数据和基本行为\n模型对象，用于维护应用程序的数据，并定义操作数据的特定逻辑。\n\n只要加载的是包含有应用程序永久信息的数据，就应该将其放入模型对象。\n\n如果是理想状态，模型对象与对其进行显示和编辑的用户界面，不应有任何的直接关联。\n\n##使用视图对象，向用户展示信息\n视图对象，可以响应用户的操作，并懂得如何将自己展现在屏幕上。\n\n视图对象通常从应用程序的模型对象获取数据，用于展示。\n\n值得注意的是，虽然视图对象与模型对象关系密切，但是在MVC应用程序中，它们之间没有耦合。\n\n##用控制器对象，联系起模型和视图\n\n控制器对象，就是是视图对象和模型对象的中间人。\n\n控制器对象就像一个厨师，模型对象是材料，视图对象是服务员，厨师烹饪对应的材料，然后交由我们的视图对象进行呈现。\n\n除了协调作用之外，控制器还可以执行其他的操作。\n\n##作为复合模式的MVC\n\nMVC模式包含了若干更加基本的设计模式。在Cocoa(Touch)的MVC有:\n\n>组合（Composite）\n>视图对象之间，以协作方式，构成一个视图层次结构体系。\n>其中既可以有复合视图，也可以有独立视图。\n>每个层次的每个视图节点，都可以响应用户的操作，并把自己绘制到屏幕上。\n\n>命令(Command）\n>这是一种“目标-动作”机制，视图对象可以推迟其他对象的执行。\n>让其他对象等到发生了某些事件后，再执行。\n\n>中介者(Mdediator)\n>控制器对象，采用了中介模式。构成了模型对象和视图对象之间传递数据的双向通道。\n>应用程序的控制器对象，将模型的变更，传达给视图对象。\n\n>策略(Strategy)\n>控制器对象，可以是视图对象的一个“策略”。\n\n>视图对象，将自身隔离，以期维持其作为数据展示器的唯一职责。而将一切应用程序特有的界面行为的决定，委派给它的“策略”对象。\n\n>观察者(Observer)\n>模型对象向它所关注的控制器对象，发出内部状态变化的通知。\n\n\n#针对接口编程，而不是针对实现编程\n\n作为一个软件开发人员，很多人甚至已经学习了多门面向对象的语言。对于类，对象，继承，多态，接口的概念相信都已经理解了。\n\n但是类继承与接口继承的区别在哪里？\n\n接口定义了类型，接口继承让我们可以用一个对象，代替另一个对象。\n\n类继承，是通过复用父类的功能或者只是简单的共享代码和表述，来定义对象的实现和类型的一种机制。\n\n##@protocal与抽象基类\n\n我们要针对接口编程，而在Object-C中，有一种称为协议的语言功能(语法为@protocal)。\n\n协议不定义任何实现，而只声明方法，以确定符合协议的类的行为。\n\n因此，协议是只定义抽象行为的\"接口\"。\n\n实现协议的类定义这些方法的实现，来执行真正的操作。\n\n另一种定义高度抽象类型的方法，是定义抽象基类。\n\n通过抽象基类，我们可以生成一些其他子类可以共享的默认行为。\n\n\n时间仓促，只学习了一些设计模式的概念。但是感觉受益不小。希望和我一样学习设计模式的同学可以多多交流，共同进步！\n\n参考:\n\n>《Object-C编程之道（iOS设计模式解析）》人民邮电出版社","slug":"技术/2015-11-12-DesignPatterns","published":1,"updated":"2016-04-10T11:46:13.000Z","comments":1,"photos":[],"link":"","_id":"cisw1ptrc000dyrntoapx4pxv","content":"<p>#为什么学习设计模式<br>在明白为什么学习设计模式之前，这学期我第一次在学校上了软件工程这门课。</p>\n<p>课上老师有一个思想和说法，令我耳目一新，改变了我原有对于软件开发的认识，大概意思是:</p>\n<blockquote>\n<p>与建筑工程这类看的见的实体工程一样，我们的软件开发也是一项真正的工程。我们需要结构的设计，来保证安全，美观，好用。也需要合理的分工，来达到最好的结果。</p>\n</blockquote>\n<p>从此，我对待软件开发的学习态度也大不一样，我知道自己开发的不是什么随随便便的小东西——而是运用真正的科学技术，去开发的软件工程。</p>\n<p>因此不应该盲目地copy，随便用廉价的代码去拼凑。那样出来的，只是豆腐渣工程。</p>\n<p>我苦于自己代码糟糕的结构，以及臃肿的controller。</p>\n<p>直到阅读到前辈们的博客，给了我指引。其中一个关键就是设计模式的运用。</p>\n<p>设计模式是有用的抽象化工具，相当于一个对象或类的设计模板，用来解决特定领域经常发生的问题。</p>\n<p>#设计模式的起源<br>MVC模式，顾名思义，它是这样一种模式:</p>\n<blockquote>\n<p>模型Model-视图View-控制器Controller</p>\n</blockquote>\n<p>听起来很简单。</p>\n<p>其实到今天，我才开始真正理解它。它本身其实并不是最基本的设计模式。</p>\n<p>它至少在Samlltalk诞生初期就已经出现。在mvc设计模式中，对象被分为模型，视图，控制器。它是Cocoa Touch中很多机制和技术的基础。</p>\n<p>##在模型对象中，封装数据和基本行为<br>模型对象，用于维护应用程序的数据，并定义操作数据的特定逻辑。</p>\n<p>只要加载的是包含有应用程序永久信息的数据，就应该将其放入模型对象。</p>\n<p>如果是理想状态，模型对象与对其进行显示和编辑的用户界面，不应有任何的直接关联。</p>\n<p>##使用视图对象，向用户展示信息<br>视图对象，可以响应用户的操作，并懂得如何将自己展现在屏幕上。</p>\n<p>视图对象通常从应用程序的模型对象获取数据，用于展示。</p>\n<p>值得注意的是，虽然视图对象与模型对象关系密切，但是在MVC应用程序中，它们之间没有耦合。</p>\n<p>##用控制器对象，联系起模型和视图</p>\n<p>控制器对象，就是是视图对象和模型对象的中间人。</p>\n<p>控制器对象就像一个厨师，模型对象是材料，视图对象是服务员，厨师烹饪对应的材料，然后交由我们的视图对象进行呈现。</p>\n<p>除了协调作用之外，控制器还可以执行其他的操作。</p>\n<p>##作为复合模式的MVC</p>\n<p>MVC模式包含了若干更加基本的设计模式。在Cocoa(Touch)的MVC有:</p>\n<blockquote>\n<p>组合（Composite）<br>视图对象之间，以协作方式，构成一个视图层次结构体系。<br>其中既可以有复合视图，也可以有独立视图。<br>每个层次的每个视图节点，都可以响应用户的操作，并把自己绘制到屏幕上。</p>\n<p>命令(Command）<br>这是一种“目标-动作”机制，视图对象可以推迟其他对象的执行。<br>让其他对象等到发生了某些事件后，再执行。</p>\n<p>中介者(Mdediator)<br>控制器对象，采用了中介模式。构成了模型对象和视图对象之间传递数据的双向通道。<br>应用程序的控制器对象，将模型的变更，传达给视图对象。</p>\n<p>策略(Strategy)<br>控制器对象，可以是视图对象的一个“策略”。</p>\n<p>视图对象，将自身隔离，以期维持其作为数据展示器的唯一职责。而将一切应用程序特有的界面行为的决定，委派给它的“策略”对象。</p>\n<p>观察者(Observer)<br>模型对象向它所关注的控制器对象，发出内部状态变化的通知。</p>\n</blockquote>\n<p>#针对接口编程，而不是针对实现编程</p>\n<p>作为一个软件开发人员，很多人甚至已经学习了多门面向对象的语言。对于类，对象，继承，多态，接口的概念相信都已经理解了。</p>\n<p>但是类继承与接口继承的区别在哪里？</p>\n<p>接口定义了类型，接口继承让我们可以用一个对象，代替另一个对象。</p>\n<p>类继承，是通过复用父类的功能或者只是简单的共享代码和表述，来定义对象的实现和类型的一种机制。</p>\n<p>##@protocal与抽象基类</p>\n<p>我们要针对接口编程，而在Object-C中，有一种称为协议的语言功能(语法为@protocal)。</p>\n<p>协议不定义任何实现，而只声明方法，以确定符合协议的类的行为。</p>\n<p>因此，协议是只定义抽象行为的”接口”。</p>\n<p>实现协议的类定义这些方法的实现，来执行真正的操作。</p>\n<p>另一种定义高度抽象类型的方法，是定义抽象基类。</p>\n<p>通过抽象基类，我们可以生成一些其他子类可以共享的默认行为。</p>\n<p>时间仓促，只学习了一些设计模式的概念。但是感觉受益不小。希望和我一样学习设计模式的同学可以多多交流，共同进步！</p>\n<p>参考:</p>\n<blockquote>\n<p>《Object-C编程之道（iOS设计模式解析）》人民邮电出版社</p>\n</blockquote>\n","excerpt":"","more":"<p>#为什么学习设计模式<br>在明白为什么学习设计模式之前，这学期我第一次在学校上了软件工程这门课。</p>\n<p>课上老师有一个思想和说法，令我耳目一新，改变了我原有对于软件开发的认识，大概意思是:</p>\n<blockquote>\n<p>与建筑工程这类看的见的实体工程一样，我们的软件开发也是一项真正的工程。我们需要结构的设计，来保证安全，美观，好用。也需要合理的分工，来达到最好的结果。</p>\n</blockquote>\n<p>从此，我对待软件开发的学习态度也大不一样，我知道自己开发的不是什么随随便便的小东西——而是运用真正的科学技术，去开发的软件工程。</p>\n<p>因此不应该盲目地copy，随便用廉价的代码去拼凑。那样出来的，只是豆腐渣工程。</p>\n<p>我苦于自己代码糟糕的结构，以及臃肿的controller。</p>\n<p>直到阅读到前辈们的博客，给了我指引。其中一个关键就是设计模式的运用。</p>\n<p>设计模式是有用的抽象化工具，相当于一个对象或类的设计模板，用来解决特定领域经常发生的问题。</p>\n<p>#设计模式的起源<br>MVC模式，顾名思义，它是这样一种模式:</p>\n<blockquote>\n<p>模型Model-视图View-控制器Controller</p>\n</blockquote>\n<p>听起来很简单。</p>\n<p>其实到今天，我才开始真正理解它。它本身其实并不是最基本的设计模式。</p>\n<p>它至少在Samlltalk诞生初期就已经出现。在mvc设计模式中，对象被分为模型，视图，控制器。它是Cocoa Touch中很多机制和技术的基础。</p>\n<p>##在模型对象中，封装数据和基本行为<br>模型对象，用于维护应用程序的数据，并定义操作数据的特定逻辑。</p>\n<p>只要加载的是包含有应用程序永久信息的数据，就应该将其放入模型对象。</p>\n<p>如果是理想状态，模型对象与对其进行显示和编辑的用户界面，不应有任何的直接关联。</p>\n<p>##使用视图对象，向用户展示信息<br>视图对象，可以响应用户的操作，并懂得如何将自己展现在屏幕上。</p>\n<p>视图对象通常从应用程序的模型对象获取数据，用于展示。</p>\n<p>值得注意的是，虽然视图对象与模型对象关系密切，但是在MVC应用程序中，它们之间没有耦合。</p>\n<p>##用控制器对象，联系起模型和视图</p>\n<p>控制器对象，就是是视图对象和模型对象的中间人。</p>\n<p>控制器对象就像一个厨师，模型对象是材料，视图对象是服务员，厨师烹饪对应的材料，然后交由我们的视图对象进行呈现。</p>\n<p>除了协调作用之外，控制器还可以执行其他的操作。</p>\n<p>##作为复合模式的MVC</p>\n<p>MVC模式包含了若干更加基本的设计模式。在Cocoa(Touch)的MVC有:</p>\n<blockquote>\n<p>组合（Composite）<br>视图对象之间，以协作方式，构成一个视图层次结构体系。<br>其中既可以有复合视图，也可以有独立视图。<br>每个层次的每个视图节点，都可以响应用户的操作，并把自己绘制到屏幕上。</p>\n<p>命令(Command）<br>这是一种“目标-动作”机制，视图对象可以推迟其他对象的执行。<br>让其他对象等到发生了某些事件后，再执行。</p>\n<p>中介者(Mdediator)<br>控制器对象，采用了中介模式。构成了模型对象和视图对象之间传递数据的双向通道。<br>应用程序的控制器对象，将模型的变更，传达给视图对象。</p>\n<p>策略(Strategy)<br>控制器对象，可以是视图对象的一个“策略”。</p>\n<p>视图对象，将自身隔离，以期维持其作为数据展示器的唯一职责。而将一切应用程序特有的界面行为的决定，委派给它的“策略”对象。</p>\n<p>观察者(Observer)<br>模型对象向它所关注的控制器对象，发出内部状态变化的通知。</p>\n</blockquote>\n<p>#针对接口编程，而不是针对实现编程</p>\n<p>作为一个软件开发人员，很多人甚至已经学习了多门面向对象的语言。对于类，对象，继承，多态，接口的概念相信都已经理解了。</p>\n<p>但是类继承与接口继承的区别在哪里？</p>\n<p>接口定义了类型，接口继承让我们可以用一个对象，代替另一个对象。</p>\n<p>类继承，是通过复用父类的功能或者只是简单的共享代码和表述，来定义对象的实现和类型的一种机制。</p>\n<p>##@protocal与抽象基类</p>\n<p>我们要针对接口编程，而在Object-C中，有一种称为协议的语言功能(语法为@protocal)。</p>\n<p>协议不定义任何实现，而只声明方法，以确定符合协议的类的行为。</p>\n<p>因此，协议是只定义抽象行为的”接口”。</p>\n<p>实现协议的类定义这些方法的实现，来执行真正的操作。</p>\n<p>另一种定义高度抽象类型的方法，是定义抽象基类。</p>\n<p>通过抽象基类，我们可以生成一些其他子类可以共享的默认行为。</p>\n<p>时间仓促，只学习了一些设计模式的概念。但是感觉受益不小。希望和我一样学习设计模式的同学可以多多交流，共同进步！</p>\n<p>参考:</p>\n<blockquote>\n<p>《Object-C编程之道（iOS设计模式解析）》人民邮电出版社</p>\n</blockquote>\n"},{"layout":"post","title":"python urllib2使用（用于解决web跨域访问）","date":"2015-09-23T16:00:00.000Z","keywords":null,"description":"在实习时用python做内部使用的小工具，碰到的问题","_content":"\n\n\n## urllib2模块的介绍\n\n### 简介：\n\nurllib2是python的一个获取url（Uniform Resource Locators，统一资源定址器）的模块。它用urlopen函数的形式提供了一个非常简洁的接口。这使得用各种各样的协议获取url成为可能。它同时也提供了一个稍微复杂的接口，来处理常见的状况-如基本的认证，cookies，代理，等等。\n\n这些都是由叫做opener和handler的对象来处理的。\n\n### urlib和urllib2\n\n两者都是接受URL请求的相关模块，但是提供了不同的功能.\n\n\n\n>区别：\n>\n>urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。\n>\n>这意味着，你不可以伪装你的User Agent字符串等。\n>\n>urllib提供**urlencode**方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。\n\n\n\n## urllib2的使用\n\n### 基本的用法\n\n在我们的使用中，只需要import,就可以把urllib2给引入。\n\n就像下面这么简单：\n\n\n\n\n\timport urllib2\n\n\tresponse = urllib2.urlopen('http://python.org/')\n\n\thtml = response.read()\n\n\n\n通过**urlopen**的方法，向对应的url访问，也就是**http://python.org/**。\n\n这上面的response对象，类似file，\n\n我们通过**read()**函数来读取请求后，得到的信息。\n\n\n\n\n\n>在真正的应用中，我们往往还需要携带数据，来作出请求，比如提交表单信息等。接下来，分别来看看如何用***post***和***get***方法来发送我们的请求\n\n\n\n### post和get请求方式的介绍和区别\n\n\n\nHTTP定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。\n\n这里只介绍post,get：\n\nGET一般用于<mark>获取/查询</mark>资源信息，根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。\n\nPOST一般用于<mark>更新</mark>资源信息。根据HTTP规范，POST表示可能修改变服务器上的资源的请求。\n\n\n\n而最明显看出来的区别，就是在我们传输数据的提交形式\n\n>GET请求的数据会附在URL之后,用<mark>\"?\"</mark>号来分隔。例如：http://xxxx.com?name=hyddd&password=E4%BD%A0%E5%A5%BD\n>\n>POST提交的数据，则是放置在HTTP包的包体中。一般都要用到form表单进行提交\n\n\n\nPOST的安全性要比GET的安全性高：\n\n>注意：这里所说的安全性, 和上面GET提到的“安全”不是同个概念。\n>\n>上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上。因为：\n>(1)登录页面有可能被浏览器缓存\n>(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了\n>除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。\n\n\n\n### Urllib2发送POST请求\n\n\n\n\timport urllib\n\n\timport urllib2\n\n\n\n\turl = 'http://www.someserver.com/register.cgi'\n\n\tvalues = {'name' : 'Michael Foord','language' : 'Python' }\n\n\n\n\tdata = urllib.urlencode(values)\n\n\treq = urllib2.Request(url, data)\n\n\n\n\tresponse = urllib2.urlopen(req)\n\n\tthe_page = response.read()\n\n\n\n\n\n\n\n你肯定注意到了，我们在这里不仅使用了urllib2模块,还用到了之前所说的**urllib**模块。\n\n原因在于，这些数据需要被以标准的方式encode，而encode需要在urllib中完成。\n\n在values(要提交的数据)encode完成后，data（encode后的数据）才作为一个数据参数传送给Request对象。\n\n\n\n完成这一系列的操作，我们才使用**urlopen**函数来获得了我们请求后的数据。\n\n再使用read()函数读取。\n\n\n\n### Urllib2发送GET请求\n\n\n\timport urllib2\n\n\timport urllib\n\n\tvalues['name'] = 'Somebody Here'\n\tvalues['language'] = 'Python'\n\n\n\tdata = urllib.urlencode(values)\n\t url = 'http://www.example.com/example.cgi'\n\n\n\tfull_url = url + '?' + data\n\n\n\tresponse = urllib2.open(full_url)\n\tthe_page = response.read()\n\n\n在GET方式里，我们不需要像POST方式使用到Request函数。\n\n在values经过encdoe后，直接把full_url按照GET请求的格式，拼凑好，就可以放在**open**函数里去使用了。\n\n非常方便。\n\n\n\n\n\n参考链接：\n\n\n[urlib2模块使用介绍](http://mxdxm.iteye.com/blog/512728/)\n\n[post,get介绍](http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html)\n\n","source":"_posts/技术/2015-9-24-python-urllib2.md","raw":"---\nlayout: post\ntitle: python urllib2使用（用于解决web跨域访问）\ndate: 2015-09-24\ncategory: 技术\ntags: 实习工作\nkeywords:\ndescription: 在实习时用python做内部使用的小工具，碰到的问题\n---\n\n\n\n## urllib2模块的介绍\n\n### 简介：\n\nurllib2是python的一个获取url（Uniform Resource Locators，统一资源定址器）的模块。它用urlopen函数的形式提供了一个非常简洁的接口。这使得用各种各样的协议获取url成为可能。它同时也提供了一个稍微复杂的接口，来处理常见的状况-如基本的认证，cookies，代理，等等。\n\n这些都是由叫做opener和handler的对象来处理的。\n\n### urlib和urllib2\n\n两者都是接受URL请求的相关模块，但是提供了不同的功能.\n\n\n\n>区别：\n>\n>urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。\n>\n>这意味着，你不可以伪装你的User Agent字符串等。\n>\n>urllib提供**urlencode**方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。\n\n\n\n## urllib2的使用\n\n### 基本的用法\n\n在我们的使用中，只需要import,就可以把urllib2给引入。\n\n就像下面这么简单：\n\n\n\n\n\timport urllib2\n\n\tresponse = urllib2.urlopen('http://python.org/')\n\n\thtml = response.read()\n\n\n\n通过**urlopen**的方法，向对应的url访问，也就是**http://python.org/**。\n\n这上面的response对象，类似file，\n\n我们通过**read()**函数来读取请求后，得到的信息。\n\n\n\n\n\n>在真正的应用中，我们往往还需要携带数据，来作出请求，比如提交表单信息等。接下来，分别来看看如何用***post***和***get***方法来发送我们的请求\n\n\n\n### post和get请求方式的介绍和区别\n\n\n\nHTTP定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。\n\n这里只介绍post,get：\n\nGET一般用于<mark>获取/查询</mark>资源信息，根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。\n\nPOST一般用于<mark>更新</mark>资源信息。根据HTTP规范，POST表示可能修改变服务器上的资源的请求。\n\n\n\n而最明显看出来的区别，就是在我们传输数据的提交形式\n\n>GET请求的数据会附在URL之后,用<mark>\"?\"</mark>号来分隔。例如：http://xxxx.com?name=hyddd&password=E4%BD%A0%E5%A5%BD\n>\n>POST提交的数据，则是放置在HTTP包的包体中。一般都要用到form表单进行提交\n\n\n\nPOST的安全性要比GET的安全性高：\n\n>注意：这里所说的安全性, 和上面GET提到的“安全”不是同个概念。\n>\n>上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上。因为：\n>(1)登录页面有可能被浏览器缓存\n>(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了\n>除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。\n\n\n\n### Urllib2发送POST请求\n\n\n\n\timport urllib\n\n\timport urllib2\n\n\n\n\turl = 'http://www.someserver.com/register.cgi'\n\n\tvalues = {'name' : 'Michael Foord','language' : 'Python' }\n\n\n\n\tdata = urllib.urlencode(values)\n\n\treq = urllib2.Request(url, data)\n\n\n\n\tresponse = urllib2.urlopen(req)\n\n\tthe_page = response.read()\n\n\n\n\n\n\n\n你肯定注意到了，我们在这里不仅使用了urllib2模块,还用到了之前所说的**urllib**模块。\n\n原因在于，这些数据需要被以标准的方式encode，而encode需要在urllib中完成。\n\n在values(要提交的数据)encode完成后，data（encode后的数据）才作为一个数据参数传送给Request对象。\n\n\n\n完成这一系列的操作，我们才使用**urlopen**函数来获得了我们请求后的数据。\n\n再使用read()函数读取。\n\n\n\n### Urllib2发送GET请求\n\n\n\timport urllib2\n\n\timport urllib\n\n\tvalues['name'] = 'Somebody Here'\n\tvalues['language'] = 'Python'\n\n\n\tdata = urllib.urlencode(values)\n\t url = 'http://www.example.com/example.cgi'\n\n\n\tfull_url = url + '?' + data\n\n\n\tresponse = urllib2.open(full_url)\n\tthe_page = response.read()\n\n\n在GET方式里，我们不需要像POST方式使用到Request函数。\n\n在values经过encdoe后，直接把full_url按照GET请求的格式，拼凑好，就可以放在**open**函数里去使用了。\n\n非常方便。\n\n\n\n\n\n参考链接：\n\n\n[urlib2模块使用介绍](http://mxdxm.iteye.com/blog/512728/)\n\n[post,get介绍](http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html)\n\n","slug":"技术/2015-9-24-python-urllib2","published":1,"updated":"2016-09-06T17:26:34.000Z","comments":1,"photos":[],"link":"","_id":"cisw1ptrk000hyrntui3jrka6","content":"<h2 id=\"urllib2模块的介绍\"><a href=\"#urllib2模块的介绍\" class=\"headerlink\" title=\"urllib2模块的介绍\"></a>urllib2模块的介绍</h2><h3 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h3><p>urllib2是python的一个获取url（Uniform Resource Locators，统一资源定址器）的模块。它用urlopen函数的形式提供了一个非常简洁的接口。这使得用各种各样的协议获取url成为可能。它同时也提供了一个稍微复杂的接口，来处理常见的状况-如基本的认证，cookies，代理，等等。</p>\n<p>这些都是由叫做opener和handler的对象来处理的。</p>\n<h3 id=\"urlib和urllib2\"><a href=\"#urlib和urllib2\" class=\"headerlink\" title=\"urlib和urllib2\"></a>urlib和urllib2</h3><p>两者都是接受URL请求的相关模块，但是提供了不同的功能.</p>\n<blockquote>\n<p>区别：</p>\n<p>urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。</p>\n<p>这意味着，你不可以伪装你的User Agent字符串等。</p>\n<p>urllib提供<strong>urlencode</strong>方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。</p>\n</blockquote>\n<h2 id=\"urllib2的使用\"><a href=\"#urllib2的使用\" class=\"headerlink\" title=\"urllib2的使用\"></a>urllib2的使用</h2><h3 id=\"基本的用法\"><a href=\"#基本的用法\" class=\"headerlink\" title=\"基本的用法\"></a>基本的用法</h3><p>在我们的使用中，只需要import,就可以把urllib2给引入。</p>\n<p>就像下面这么简单：</p>\n<pre><code>import urllib2\n\nresponse = urllib2.urlopen(&apos;http://python.org/&apos;)\n\nhtml = response.read()\n</code></pre><p>通过<strong>urlopen</strong>的方法，向对应的url访问，也就是<strong><a href=\"http://python.org/\" target=\"_blank\" rel=\"external\">http://python.org/</a></strong>。</p>\n<p>这上面的response对象，类似file，</p>\n<p>我们通过<strong>read()</strong>函数来读取请求后，得到的信息。</p>\n<blockquote>\n<p>在真正的应用中，我们往往还需要携带数据，来作出请求，比如提交表单信息等。接下来，分别来看看如何用<strong><em>post</em></strong>和<strong><em>get</em></strong>方法来发送我们的请求</p>\n</blockquote>\n<h3 id=\"post和get请求方式的介绍和区别\"><a href=\"#post和get请求方式的介绍和区别\" class=\"headerlink\" title=\"post和get请求方式的介绍和区别\"></a>post和get请求方式的介绍和区别</h3><p>HTTP定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。</p>\n<p>这里只介绍post,get：</p>\n<p>GET一般用于<mark>获取/查询</mark>资源信息，根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。</p>\n<p>POST一般用于<mark>更新</mark>资源信息。根据HTTP规范，POST表示可能修改变服务器上的资源的请求。</p>\n<p>而最明显看出来的区别，就是在我们传输数据的提交形式</p>\n<blockquote>\n<p>GET请求的数据会附在URL之后,用<mark>“?”</mark>号来分隔。例如：<a href=\"http://xxxx.com?name=hyddd&amp;password=E4%BD%A0%E5%A5%BD\" target=\"_blank\" rel=\"external\">http://xxxx.com?name=hyddd&amp;password=E4%BD%A0%E5%A5%BD</a></p>\n<p>POST提交的数据，则是放置在HTTP包的包体中。一般都要用到form表单进行提交</p>\n</blockquote>\n<p>POST的安全性要比GET的安全性高：</p>\n<blockquote>\n<p>注意：这里所说的安全性, 和上面GET提到的“安全”不是同个概念。</p>\n<p>上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上。因为：<br>(1)登录页面有可能被浏览器缓存<br>(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了<br>除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。</p>\n</blockquote>\n<h3 id=\"Urllib2发送POST请求\"><a href=\"#Urllib2发送POST请求\" class=\"headerlink\" title=\"Urllib2发送POST请求\"></a>Urllib2发送POST请求</h3><pre><code>import urllib\n\nimport urllib2\n\n\n\nurl = &apos;http://www.someserver.com/register.cgi&apos;\n\nvalues = {&apos;name&apos; : &apos;Michael Foord&apos;,&apos;language&apos; : &apos;Python&apos; }\n\n\n\ndata = urllib.urlencode(values)\n\nreq = urllib2.Request(url, data)\n\n\n\nresponse = urllib2.urlopen(req)\n\nthe_page = response.read()\n</code></pre><p>你肯定注意到了，我们在这里不仅使用了urllib2模块,还用到了之前所说的<strong>urllib</strong>模块。</p>\n<p>原因在于，这些数据需要被以标准的方式encode，而encode需要在urllib中完成。</p>\n<p>在values(要提交的数据)encode完成后，data（encode后的数据）才作为一个数据参数传送给Request对象。</p>\n<p>完成这一系列的操作，我们才使用<strong>urlopen</strong>函数来获得了我们请求后的数据。</p>\n<p>再使用read()函数读取。</p>\n<h3 id=\"Urllib2发送GET请求\"><a href=\"#Urllib2发送GET请求\" class=\"headerlink\" title=\"Urllib2发送GET请求\"></a>Urllib2发送GET请求</h3><pre><code>import urllib2\n\nimport urllib\n\nvalues[&apos;name&apos;] = &apos;Somebody Here&apos;\nvalues[&apos;language&apos;] = &apos;Python&apos;\n\n\ndata = urllib.urlencode(values)\n url = &apos;http://www.example.com/example.cgi&apos;\n\n\nfull_url = url + &apos;?&apos; + data\n\n\nresponse = urllib2.open(full_url)\nthe_page = response.read()\n</code></pre><p>在GET方式里，我们不需要像POST方式使用到Request函数。</p>\n<p>在values经过encdoe后，直接把full_url按照GET请求的格式，拼凑好，就可以放在<strong>open</strong>函数里去使用了。</p>\n<p>非常方便。</p>\n<p>参考链接：</p>\n<p><a href=\"http://mxdxm.iteye.com/blog/512728/\" target=\"_blank\" rel=\"external\">urlib2模块使用介绍</a></p>\n<p><a href=\"http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html\" target=\"_blank\" rel=\"external\">post,get介绍</a></p>\n","excerpt":"","more":"<h2 id=\"urllib2模块的介绍\"><a href=\"#urllib2模块的介绍\" class=\"headerlink\" title=\"urllib2模块的介绍\"></a>urllib2模块的介绍</h2><h3 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h3><p>urllib2是python的一个获取url（Uniform Resource Locators，统一资源定址器）的模块。它用urlopen函数的形式提供了一个非常简洁的接口。这使得用各种各样的协议获取url成为可能。它同时也提供了一个稍微复杂的接口，来处理常见的状况-如基本的认证，cookies，代理，等等。</p>\n<p>这些都是由叫做opener和handler的对象来处理的。</p>\n<h3 id=\"urlib和urllib2\"><a href=\"#urlib和urllib2\" class=\"headerlink\" title=\"urlib和urllib2\"></a>urlib和urllib2</h3><p>两者都是接受URL请求的相关模块，但是提供了不同的功能.</p>\n<blockquote>\n<p>区别：</p>\n<p>urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。</p>\n<p>这意味着，你不可以伪装你的User Agent字符串等。</p>\n<p>urllib提供<strong>urlencode</strong>方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。</p>\n</blockquote>\n<h2 id=\"urllib2的使用\"><a href=\"#urllib2的使用\" class=\"headerlink\" title=\"urllib2的使用\"></a>urllib2的使用</h2><h3 id=\"基本的用法\"><a href=\"#基本的用法\" class=\"headerlink\" title=\"基本的用法\"></a>基本的用法</h3><p>在我们的使用中，只需要import,就可以把urllib2给引入。</p>\n<p>就像下面这么简单：</p>\n<pre><code>import urllib2\n\nresponse = urllib2.urlopen(&apos;http://python.org/&apos;)\n\nhtml = response.read()\n</code></pre><p>通过<strong>urlopen</strong>的方法，向对应的url访问，也就是<strong><a href=\"http://python.org/\">http://python.org/</a></strong>。</p>\n<p>这上面的response对象，类似file，</p>\n<p>我们通过<strong>read()</strong>函数来读取请求后，得到的信息。</p>\n<blockquote>\n<p>在真正的应用中，我们往往还需要携带数据，来作出请求，比如提交表单信息等。接下来，分别来看看如何用<strong><em>post</em></strong>和<strong><em>get</em></strong>方法来发送我们的请求</p>\n</blockquote>\n<h3 id=\"post和get请求方式的介绍和区别\"><a href=\"#post和get请求方式的介绍和区别\" class=\"headerlink\" title=\"post和get请求方式的介绍和区别\"></a>post和get请求方式的介绍和区别</h3><p>HTTP定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。</p>\n<p>这里只介绍post,get：</p>\n<p>GET一般用于<mark>获取/查询</mark>资源信息，根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。</p>\n<p>POST一般用于<mark>更新</mark>资源信息。根据HTTP规范，POST表示可能修改变服务器上的资源的请求。</p>\n<p>而最明显看出来的区别，就是在我们传输数据的提交形式</p>\n<blockquote>\n<p>GET请求的数据会附在URL之后,用<mark>“?”</mark>号来分隔。例如：<a href=\"http://xxxx.com?name=hyddd&amp;password=E4%BD%A0%E5%A5%BD\">http://xxxx.com?name=hyddd&amp;password=E4%BD%A0%E5%A5%BD</a></p>\n<p>POST提交的数据，则是放置在HTTP包的包体中。一般都要用到form表单进行提交</p>\n</blockquote>\n<p>POST的安全性要比GET的安全性高：</p>\n<blockquote>\n<p>注意：这里所说的安全性, 和上面GET提到的“安全”不是同个概念。</p>\n<p>上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上。因为：<br>(1)登录页面有可能被浏览器缓存<br>(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了<br>除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。</p>\n</blockquote>\n<h3 id=\"Urllib2发送POST请求\"><a href=\"#Urllib2发送POST请求\" class=\"headerlink\" title=\"Urllib2发送POST请求\"></a>Urllib2发送POST请求</h3><pre><code>import urllib\n\nimport urllib2\n\n\n\nurl = &apos;http://www.someserver.com/register.cgi&apos;\n\nvalues = {&apos;name&apos; : &apos;Michael Foord&apos;,&apos;language&apos; : &apos;Python&apos; }\n\n\n\ndata = urllib.urlencode(values)\n\nreq = urllib2.Request(url, data)\n\n\n\nresponse = urllib2.urlopen(req)\n\nthe_page = response.read()\n</code></pre><p>你肯定注意到了，我们在这里不仅使用了urllib2模块,还用到了之前所说的<strong>urllib</strong>模块。</p>\n<p>原因在于，这些数据需要被以标准的方式encode，而encode需要在urllib中完成。</p>\n<p>在values(要提交的数据)encode完成后，data（encode后的数据）才作为一个数据参数传送给Request对象。</p>\n<p>完成这一系列的操作，我们才使用<strong>urlopen</strong>函数来获得了我们请求后的数据。</p>\n<p>再使用read()函数读取。</p>\n<h3 id=\"Urllib2发送GET请求\"><a href=\"#Urllib2发送GET请求\" class=\"headerlink\" title=\"Urllib2发送GET请求\"></a>Urllib2发送GET请求</h3><pre><code>import urllib2\n\nimport urllib\n\nvalues[&apos;name&apos;] = &apos;Somebody Here&apos;\nvalues[&apos;language&apos;] = &apos;Python&apos;\n\n\ndata = urllib.urlencode(values)\n url = &apos;http://www.example.com/example.cgi&apos;\n\n\nfull_url = url + &apos;?&apos; + data\n\n\nresponse = urllib2.open(full_url)\nthe_page = response.read()\n</code></pre><p>在GET方式里，我们不需要像POST方式使用到Request函数。</p>\n<p>在values经过encdoe后，直接把full_url按照GET请求的格式，拼凑好，就可以放在<strong>open</strong>函数里去使用了。</p>\n<p>非常方便。</p>\n<p>参考链接：</p>\n<p><a href=\"http://mxdxm.iteye.com/blog/512728/\">urlib2模块使用介绍</a></p>\n<p><a href=\"http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html\">post,get介绍</a></p>\n"},{"layout":"post","title":"iOS开发资源整理","date":"2016-01-30T16:00:00.000Z","keywords":"iOS","description":"iOS资料整理","_content":"因为自己经常收藏很多资源，Chrome的收藏栏很乱。所以专门整理到一个文章中，以备需要时查看。\n\n#搜索姿势\n\n[如何搜寻iOS第三方资源库](http://zhangbuhuai.com/2015/07/18/how-to-search-3rd-ios-resources/)\n\n[github oc star>1](https://github.com/search?l=Objective-C&o=desc&q=stars%3A%3E1&s=stars&type=Repositories)\n\n#资源\n[高人气UI套件FlatUIKIt](https://github.com/Grouper/FlatUIKit)\n\n[oc框架排名列表](https://github.com/XCGit/awesome-objc-frameworks)\n\n[iOS,mac开源项目及库](https://github.com/XCGit/awesome-objc-frameworks)\n\n[iOS及mac开源项目和学习资料（很全面）](http://www.kancloud.cn/digest/ios-mac-study/84557)\n\n[为iOS应用添加夜间模式DKNightVersion](https://github.com/Draveness/DKNightVersion)\n\n[ibireme整理资源](http://github.ibireme.com/github/list/ios/)\n\n[折线图,环形统计图 PNChart](https://github.com/kevinzhow/PNChart)\n\n[actilces of iOS](https://github.com/JanzTam/iOS-blog-acticle/blob/master/acticles.md)\n\n[iOS开发常用细节](http://segmentfault.com/a/1190000003722059)\n\n[ibireme的iOS备忘](http://github.ibireme.com/github/list/ios/)\n\n[XcodePlugin开发探讨](https://github.com/MakeZL/CocoaPods-ToGithub-List)\n\n[SYNX:命令行工具，重组文件结构](https://github.com/venmo/synx?plg_nld=1&plg_uin=1&plg_auth=1&plg_nld=1&plg_usr=1&plg_vkey=1&plg_dev=1)\n\n[2016中国swift开发者大会](https://github.com/atConf/atswift-2016-resources)\n\n[17个提升iOS开发效率的必备工具\n](http://blog.fir.im/fir_im_weekly151119/?utm_source=weibo&utm_medium=link&utm_content=fir_im_weekly151119)\n","source":"_posts/技术/2016-1-31-SourceOfiOS.md","raw":"---\nlayout: post\ntitle: iOS开发资源整理\ndate: 2016-1-31\ncategory: 技术\ntags: 资料\nkeywords: iOS\ndescription: iOS资料整理\n---\n因为自己经常收藏很多资源，Chrome的收藏栏很乱。所以专门整理到一个文章中，以备需要时查看。\n\n#搜索姿势\n\n[如何搜寻iOS第三方资源库](http://zhangbuhuai.com/2015/07/18/how-to-search-3rd-ios-resources/)\n\n[github oc star>1](https://github.com/search?l=Objective-C&o=desc&q=stars%3A%3E1&s=stars&type=Repositories)\n\n#资源\n[高人气UI套件FlatUIKIt](https://github.com/Grouper/FlatUIKit)\n\n[oc框架排名列表](https://github.com/XCGit/awesome-objc-frameworks)\n\n[iOS,mac开源项目及库](https://github.com/XCGit/awesome-objc-frameworks)\n\n[iOS及mac开源项目和学习资料（很全面）](http://www.kancloud.cn/digest/ios-mac-study/84557)\n\n[为iOS应用添加夜间模式DKNightVersion](https://github.com/Draveness/DKNightVersion)\n\n[ibireme整理资源](http://github.ibireme.com/github/list/ios/)\n\n[折线图,环形统计图 PNChart](https://github.com/kevinzhow/PNChart)\n\n[actilces of iOS](https://github.com/JanzTam/iOS-blog-acticle/blob/master/acticles.md)\n\n[iOS开发常用细节](http://segmentfault.com/a/1190000003722059)\n\n[ibireme的iOS备忘](http://github.ibireme.com/github/list/ios/)\n\n[XcodePlugin开发探讨](https://github.com/MakeZL/CocoaPods-ToGithub-List)\n\n[SYNX:命令行工具，重组文件结构](https://github.com/venmo/synx?plg_nld=1&plg_uin=1&plg_auth=1&plg_nld=1&plg_usr=1&plg_vkey=1&plg_dev=1)\n\n[2016中国swift开发者大会](https://github.com/atConf/atswift-2016-resources)\n\n[17个提升iOS开发效率的必备工具\n](http://blog.fir.im/fir_im_weekly151119/?utm_source=weibo&utm_medium=link&utm_content=fir_im_weekly151119)\n","slug":"技术/2016-1-31-SourceOfiOS","published":1,"updated":"2016-04-18T15:47:54.000Z","comments":1,"photos":[],"link":"","_id":"cisw1ptrq000lyrntjfcvm3pp","content":"<p>因为自己经常收藏很多资源，Chrome的收藏栏很乱。所以专门整理到一个文章中，以备需要时查看。</p>\n<p>#搜索姿势</p>\n<p><a href=\"http://zhangbuhuai.com/2015/07/18/how-to-search-3rd-ios-resources/\" target=\"_blank\" rel=\"external\">如何搜寻iOS第三方资源库</a></p>\n<p><a href=\"https://github.com/search?l=Objective-C&amp;o=desc&amp;q=stars%3A%3E1&amp;s=stars&amp;type=Repositories\" target=\"_blank\" rel=\"external\">github oc star&gt;1</a></p>\n<p>#资源<br><a href=\"https://github.com/Grouper/FlatUIKit\" target=\"_blank\" rel=\"external\">高人气UI套件FlatUIKIt</a></p>\n<p><a href=\"https://github.com/XCGit/awesome-objc-frameworks\" target=\"_blank\" rel=\"external\">oc框架排名列表</a></p>\n<p><a href=\"https://github.com/XCGit/awesome-objc-frameworks\" target=\"_blank\" rel=\"external\">iOS,mac开源项目及库</a></p>\n<p><a href=\"http://www.kancloud.cn/digest/ios-mac-study/84557\" target=\"_blank\" rel=\"external\">iOS及mac开源项目和学习资料（很全面）</a></p>\n<p><a href=\"https://github.com/Draveness/DKNightVersion\" target=\"_blank\" rel=\"external\">为iOS应用添加夜间模式DKNightVersion</a></p>\n<p><a href=\"http://github.ibireme.com/github/list/ios/\" target=\"_blank\" rel=\"external\">ibireme整理资源</a></p>\n<p><a href=\"https://github.com/kevinzhow/PNChart\" target=\"_blank\" rel=\"external\">折线图,环形统计图 PNChart</a></p>\n<p><a href=\"https://github.com/JanzTam/iOS-blog-acticle/blob/master/acticles.md\" target=\"_blank\" rel=\"external\">actilces of iOS</a></p>\n<p><a href=\"http://segmentfault.com/a/1190000003722059\" target=\"_blank\" rel=\"external\">iOS开发常用细节</a></p>\n<p><a href=\"http://github.ibireme.com/github/list/ios/\" target=\"_blank\" rel=\"external\">ibireme的iOS备忘</a></p>\n<p><a href=\"https://github.com/MakeZL/CocoaPods-ToGithub-List\" target=\"_blank\" rel=\"external\">XcodePlugin开发探讨</a></p>\n<p><a href=\"https://github.com/venmo/synx?plg_nld=1&amp;plg_uin=1&amp;plg_auth=1&amp;plg_nld=1&amp;plg_usr=1&amp;plg_vkey=1&amp;plg_dev=1\" target=\"_blank\" rel=\"external\">SYNX:命令行工具，重组文件结构</a></p>\n<p><a href=\"https://github.com/atConf/atswift-2016-resources\" target=\"_blank\" rel=\"external\">2016中国swift开发者大会</a></p>\n<p><a href=\"http://blog.fir.im/fir_im_weekly151119/?utm_source=weibo&amp;utm_medium=link&amp;utm_content=fir_im_weekly151119\" target=\"_blank\" rel=\"external\">17个提升iOS开发效率的必备工具\n</a></p>\n","excerpt":"","more":"<p>因为自己经常收藏很多资源，Chrome的收藏栏很乱。所以专门整理到一个文章中，以备需要时查看。</p>\n<p>#搜索姿势</p>\n<p><a href=\"http://zhangbuhuai.com/2015/07/18/how-to-search-3rd-ios-resources/\">如何搜寻iOS第三方资源库</a></p>\n<p><a href=\"https://github.com/search?l=Objective-C&amp;o=desc&amp;q=stars%3A%3E1&amp;s=stars&amp;type=Repositories\">github oc star&gt;1</a></p>\n<p>#资源<br><a href=\"https://github.com/Grouper/FlatUIKit\">高人气UI套件FlatUIKIt</a></p>\n<p><a href=\"https://github.com/XCGit/awesome-objc-frameworks\">oc框架排名列表</a></p>\n<p><a href=\"https://github.com/XCGit/awesome-objc-frameworks\">iOS,mac开源项目及库</a></p>\n<p><a href=\"http://www.kancloud.cn/digest/ios-mac-study/84557\">iOS及mac开源项目和学习资料（很全面）</a></p>\n<p><a href=\"https://github.com/Draveness/DKNightVersion\">为iOS应用添加夜间模式DKNightVersion</a></p>\n<p><a href=\"http://github.ibireme.com/github/list/ios/\">ibireme整理资源</a></p>\n<p><a href=\"https://github.com/kevinzhow/PNChart\">折线图,环形统计图 PNChart</a></p>\n<p><a href=\"https://github.com/JanzTam/iOS-blog-acticle/blob/master/acticles.md\">actilces of iOS</a></p>\n<p><a href=\"http://segmentfault.com/a/1190000003722059\">iOS开发常用细节</a></p>\n<p><a href=\"http://github.ibireme.com/github/list/ios/\">ibireme的iOS备忘</a></p>\n<p><a href=\"https://github.com/MakeZL/CocoaPods-ToGithub-List\">XcodePlugin开发探讨</a></p>\n<p><a href=\"https://github.com/venmo/synx?plg_nld=1&amp;plg_uin=1&amp;plg_auth=1&amp;plg_nld=1&amp;plg_usr=1&amp;plg_vkey=1&amp;plg_dev=1\">SYNX:命令行工具，重组文件结构</a></p>\n<p><a href=\"https://github.com/atConf/atswift-2016-resources\">2016中国swift开发者大会</a></p>\n<p><a href=\"http://blog.fir.im/fir_im_weekly151119/?utm_source=weibo&amp;utm_medium=link&amp;utm_content=fir_im_weekly151119\">17个提升iOS开发效率的必备工具\n</a></p>\n"},{"layout":"post","date":"2016-07-10T15:33:46.000Z","title":"优趣工作室招聘","description":"招聘","excerpt":"","_content":"[English click](#QuseitLab)\n\n## 关于我们\n\n我们，是一家来自北京的创业公司。\n\n我们，有日语N1又会金融最后变成了设计师的妹子，也有未出校门就已经独挡一面的小鲜肉。\n\n我们，既有腼腆的技术宅，也有爱运动的肌肉男。\n\n我们，每天都有夏日午后的茶歇水果，冰棍饮料任君挑选。\n\n我们，有样样精通，又热情幽默的80后老板。这里没有领导与下属之分，只有兄弟姐妹。\n\n我们，有弹性的上班时间，够硬的工资水准。\n\n我们，致力于用互联网技术创造价值，实现价值。我们的愿景是为全球手机用户提供有趣和易用的手机应用。\n\n## 关于你\n\n我们希望你：\n\n- 有良好的自学习惯\n\n- 平时能善用搜索引擎\n\n- 踏实勤奋，乐于分享\n\n\n## 地址\n\n>明秀路122号，城市碧园3栋303\n\n了解我们的产品，请进下方主页：\n\n[优趣工作室](http://quseit.com/cn/index.html)\n\n# QuseitLab\n\n## About Mine\n\n## About You","source":"_posts/技术/2016-7-9-Recruitment.markdown","raw":"---\nlayout: post\ndate: 2016-07-10 23:33:46\ntitle: 优趣工作室招聘\ncategory: 技术\ndescription: 招聘\nexcerpt:  优趣天下信息技术有限公司南宁分公司招聘\n---\n[English click](#QuseitLab)\n\n## 关于我们\n\n我们，是一家来自北京的创业公司。\n\n我们，有日语N1又会金融最后变成了设计师的妹子，也有未出校门就已经独挡一面的小鲜肉。\n\n我们，既有腼腆的技术宅，也有爱运动的肌肉男。\n\n我们，每天都有夏日午后的茶歇水果，冰棍饮料任君挑选。\n\n我们，有样样精通，又热情幽默的80后老板。这里没有领导与下属之分，只有兄弟姐妹。\n\n我们，有弹性的上班时间，够硬的工资水准。\n\n我们，致力于用互联网技术创造价值，实现价值。我们的愿景是为全球手机用户提供有趣和易用的手机应用。\n\n## 关于你\n\n我们希望你：\n\n- 有良好的自学习惯\n\n- 平时能善用搜索引擎\n\n- 踏实勤奋，乐于分享\n\n\n## 地址\n\n>明秀路122号，城市碧园3栋303\n\n了解我们的产品，请进下方主页：\n\n[优趣工作室](http://quseit.com/cn/index.html)\n\n# QuseitLab\n\n## About Mine\n\n## About You","slug":"技术/2016-7-9-Recruitment","published":1,"updated":"2016-07-10T16:10:57.000Z","comments":1,"photos":[],"link":"","_id":"cisw1ptrt000oyrntg0o9225u","content":"<p><a href=\"#QuseitLab\">English click</a></p>\n<h2 id=\"关于我们\"><a href=\"#关于我们\" class=\"headerlink\" title=\"关于我们\"></a>关于我们</h2><p>我们，是一家来自北京的创业公司。</p>\n<p>我们，有日语N1又会金融最后变成了设计师的妹子，也有未出校门就已经独挡一面的小鲜肉。</p>\n<p>我们，既有腼腆的技术宅，也有爱运动的肌肉男。</p>\n<p>我们，每天都有夏日午后的茶歇水果，冰棍饮料任君挑选。</p>\n<p>我们，有样样精通，又热情幽默的80后老板。这里没有领导与下属之分，只有兄弟姐妹。</p>\n<p>我们，有弹性的上班时间，够硬的工资水准。</p>\n<p>我们，致力于用互联网技术创造价值，实现价值。我们的愿景是为全球手机用户提供有趣和易用的手机应用。</p>\n<h2 id=\"关于你\"><a href=\"#关于你\" class=\"headerlink\" title=\"关于你\"></a>关于你</h2><p>我们希望你：</p>\n<ul>\n<li><p>有良好的自学习惯</p>\n</li>\n<li><p>平时能善用搜索引擎</p>\n</li>\n<li><p>踏实勤奋，乐于分享</p>\n</li>\n</ul>\n<h2 id=\"地址\"><a href=\"#地址\" class=\"headerlink\" title=\"地址\"></a>地址</h2><blockquote>\n<p>明秀路122号，城市碧园3栋303</p>\n</blockquote>\n<p>了解我们的产品，请进下方主页：</p>\n<p><a href=\"http://quseit.com/cn/index.html\" target=\"_blank\" rel=\"external\">优趣工作室</a></p>\n<h1 id=\"QuseitLab\"><a href=\"#QuseitLab\" class=\"headerlink\" title=\"QuseitLab\"></a>QuseitLab</h1><h2 id=\"About-Mine\"><a href=\"#About-Mine\" class=\"headerlink\" title=\"About Mine\"></a>About Mine</h2><h2 id=\"About-You\"><a href=\"#About-You\" class=\"headerlink\" title=\"About You\"></a>About You</h2>","more":"<p><a href=\"#QuseitLab\">English click</a></p>\n<h2 id=\"关于我们\"><a href=\"#关于我们\" class=\"headerlink\" title=\"关于我们\"></a>关于我们</h2><p>我们，是一家来自北京的创业公司。</p>\n<p>我们，有日语N1又会金融最后变成了设计师的妹子，也有未出校门就已经独挡一面的小鲜肉。</p>\n<p>我们，既有腼腆的技术宅，也有爱运动的肌肉男。</p>\n<p>我们，每天都有夏日午后的茶歇水果，冰棍饮料任君挑选。</p>\n<p>我们，有样样精通，又热情幽默的80后老板。这里没有领导与下属之分，只有兄弟姐妹。</p>\n<p>我们，有弹性的上班时间，够硬的工资水准。</p>\n<p>我们，致力于用互联网技术创造价值，实现价值。我们的愿景是为全球手机用户提供有趣和易用的手机应用。</p>\n<h2 id=\"关于你\"><a href=\"#关于你\" class=\"headerlink\" title=\"关于你\"></a>关于你</h2><p>我们希望你：</p>\n<ul>\n<li><p>有良好的自学习惯</p>\n</li>\n<li><p>平时能善用搜索引擎</p>\n</li>\n<li><p>踏实勤奋，乐于分享</p>\n</li>\n</ul>\n<h2 id=\"地址\"><a href=\"#地址\" class=\"headerlink\" title=\"地址\"></a>地址</h2><blockquote>\n<p>明秀路122号，城市碧园3栋303</p>\n</blockquote>\n<p>了解我们的产品，请进下方主页：</p>\n<p><a href=\"http://quseit.com/cn/index.html\">优趣工作室</a></p>\n<h1 id=\"QuseitLab\"><a href=\"#QuseitLab\" class=\"headerlink\" title=\"QuseitLab\"></a>QuseitLab</h1><h2 id=\"About-Mine\"><a href=\"#About-Mine\" class=\"headerlink\" title=\"About Mine\"></a>About Mine</h2><h2 id=\"About-You\"><a href=\"#About-You\" class=\"headerlink\" title=\"About You\"></a>About You</h2>"},{"layout":"post","title":"照片框架ALAssetsLibrary","date":"2016-03-22T16:00:00.000Z","keywords":"iOS","description":"通过ALAssetsLibrary获取系统相片和视频","excerpt":"","_content":"\n# ALAssetsLibrary介绍\n\n在iOS中，照片库并不只是照片的集合，同时也包含了视频。\n\n在 AssetsLibrary 中两者都有相同类型的对象去描述，只是类型不同而已。\n\n这里稍微介绍一下概念：\n\n- AssetsLibrary: 代表整个设备中的资源库（照片库），通过 AssetsLibrary 可以获取设备中的照片和视频\n- ALAssetsGroup: 映射照片库中的一个相册，通过 ALAssetsGroup 可以获取某个相册的信息，相册下的资源，同时也可以对某个相册添加资源。\n- ALAsset: 映射照片库中的一个照片或视频，通过 ALAsset 可以获取某个照片或视频的详细信息，或者保存照片和视频。\n- ALAssetRepresentation: ALAssetRepresentation可以更方便地获取 ALAsset 中的资源信息，每个 ALAsset 都有至少有一个 ALAssetRepresentation 对象，可以通过 defaultRepresentation 获取。\n\n# 坑\n\n注意！注意！先说说坑，否则直接上手你会和我一样悲剧的。\n\n当然你也可以跳过去不看 : )\n\n## 异步\n\n我在开发过程中，是这样的思路：\n\n遍历相册->遍历时添加相册到数组->遍历完成，取数组，填入照片浏览器\n\n这样一看好像没啥错，但是由于它的异步处理，意味着“遍历时添加相册到数组”，”遍历完成，取数组填入照片浏览器“不是顺序执行。\n\n它们将同时开始，相当于没等到添加完，就已经开始填入照片了。这样的话，数组永远都是空的。\n\n由于整个 AssetsLibrary 中对相册、资源的获取和保存都是使用异步处理（Asynchronous），这是考虑到资源文件体积相当比较大（还可能很大）。\n\n例如遍历相册操作，相册的结果使用 block 输出，如果相册遍历完毕，则最后一次输出的 block 中的 group 参数值为 nil。\n\n我们可以通过判断group是否为nil来知道是否遍历完成。\n\n## AssetsLibrary实例需要强引用\n\n在通过AsssetsLibrary，获取到照片和视频时。以为万事大吉。\n\n但是当我把对应的asset放进照片浏览器时，却一直没有图片。\n\n经过一番调试，发现存储asset对象的数组，里面的对象都已经为空了。\n\n原因在于：\n\n>当我们把这些获取到的相册和资源储存到数组时，实际上只是在数组中储存了这些相册和资源在 AssetsLibrary 中的引用（指针）。\n>因而无论把相册和资源储存数组后如何利用这些数据，都首先需要确保 AssetsLibrary 没有被 ARC 释放。\n>否则把数据从数组中取出来时，会发现对应的引用数据已经丢失。这一点较为容易被忽略。\n\n因此建议在使用 AssetsLibrary 的 viewController 中，把 AssetsLibrary 作为一个强持有的 property 或私有变量，避免在枚举出 AssetsLibrary 中所需要的数据后，AssetsLibrary 就被 ARC 释放了。\n\n\n# 使用\n\n## 获取所有相册\n\n通过ALAssetsLibrary的实例方法，得到ALAssetsGroup类数组。\n\n\tALAssetsLibrary *assetsLibrary;\n\tNSMutableArray *groupArray;\n \tassetsLibrary = [[ALAssetsLibrary alloc] init];\n   \tgroupArray=[[NSMutableArray alloc] initWithCapacity:1];\n  \t[assetsLibrary enumerateGroupsWithTypes:ALAssetsGroupAll usingBlock:^(ALAssetsGroup *group, BOOL *stop) {\n      \tif (group!=nil) {\n          \t\t  [groupArray addObject:group];\n           \t\t //            通过这个可以知道相册的名字，从而也可以知道安装的部分应用\n          \t\t //例如 Name:柚子相机, Type:Album, Assets count:1\n           \t\t NSLog(@\"%@\",group);\n        \t\t}else{\n        \t\t\tif ([_albumsArray count] > 0) {\n           \t\t\t // 把所有的相册储存完毕，可以展示相册列表\n        \t\t\t} else {\n           \t\t\t // 没有任何有资源的相册，输出提示\n        \t\t\t}\n        \t\t}\n    \t} failureBlock:^(NSError *error) {\n      \t\t\t  NSLog(@\"Group not found!\\n\");\n    }];\n\n## 获取相册下的照片\n\n使用类型为ALAssetsGroup的group对象，获取ALAsset，来得到图片资源\n\n\t[_group enumerateAssetsUsingBlock:^(ALAsset *result, NSUInteger index, BOOL *stop) {\n        if (result) {\n           \n            NSLog(@\"%@\",result);\n             image=[UIImage imageWithCGImage: result.thumbnail];\n\n        }else{\n        \t// result 为 nil，即遍历相片或视频完毕，可以展示资源列表\n    }\n    }];\n\n\n\n\n>参考文章\n\n[ALAsset,ALAssetsLibrary,ALAssetsgroup常见属性及用法](http://blog.csdn.net/shenjx1225/article/details/9293269)\n\n[iOS 开发之照片框架详解](http://kayosite.com/ios-development-and-detail-of-photo-framework.html)\n\n[iOS的AssetsLibrary框架访问所有相片](http://www.mincoder.com/article/2473.shtml)","source":"_posts/技术/2016-3-23-ALAsset.md","raw":"---\nlayout: post\ntitle: 照片框架ALAssetsLibrary\ndate: 2016-3-23\ncategory: 技术\ntags: 资料\nkeywords: iOS\ndescription: 通过ALAssetsLibrary获取系统相片和视频\nexcerpt: 今天做iOS图片选择器，中间碰到一些坑，记录下来。这里只介绍ALAssetLibrary，PhotoKit之后有机会补上。\n---\n\n# ALAssetsLibrary介绍\n\n在iOS中，照片库并不只是照片的集合，同时也包含了视频。\n\n在 AssetsLibrary 中两者都有相同类型的对象去描述，只是类型不同而已。\n\n这里稍微介绍一下概念：\n\n- AssetsLibrary: 代表整个设备中的资源库（照片库），通过 AssetsLibrary 可以获取设备中的照片和视频\n- ALAssetsGroup: 映射照片库中的一个相册，通过 ALAssetsGroup 可以获取某个相册的信息，相册下的资源，同时也可以对某个相册添加资源。\n- ALAsset: 映射照片库中的一个照片或视频，通过 ALAsset 可以获取某个照片或视频的详细信息，或者保存照片和视频。\n- ALAssetRepresentation: ALAssetRepresentation可以更方便地获取 ALAsset 中的资源信息，每个 ALAsset 都有至少有一个 ALAssetRepresentation 对象，可以通过 defaultRepresentation 获取。\n\n# 坑\n\n注意！注意！先说说坑，否则直接上手你会和我一样悲剧的。\n\n当然你也可以跳过去不看 : )\n\n## 异步\n\n我在开发过程中，是这样的思路：\n\n遍历相册->遍历时添加相册到数组->遍历完成，取数组，填入照片浏览器\n\n这样一看好像没啥错，但是由于它的异步处理，意味着“遍历时添加相册到数组”，”遍历完成，取数组填入照片浏览器“不是顺序执行。\n\n它们将同时开始，相当于没等到添加完，就已经开始填入照片了。这样的话，数组永远都是空的。\n\n由于整个 AssetsLibrary 中对相册、资源的获取和保存都是使用异步处理（Asynchronous），这是考虑到资源文件体积相当比较大（还可能很大）。\n\n例如遍历相册操作，相册的结果使用 block 输出，如果相册遍历完毕，则最后一次输出的 block 中的 group 参数值为 nil。\n\n我们可以通过判断group是否为nil来知道是否遍历完成。\n\n## AssetsLibrary实例需要强引用\n\n在通过AsssetsLibrary，获取到照片和视频时。以为万事大吉。\n\n但是当我把对应的asset放进照片浏览器时，却一直没有图片。\n\n经过一番调试，发现存储asset对象的数组，里面的对象都已经为空了。\n\n原因在于：\n\n>当我们把这些获取到的相册和资源储存到数组时，实际上只是在数组中储存了这些相册和资源在 AssetsLibrary 中的引用（指针）。\n>因而无论把相册和资源储存数组后如何利用这些数据，都首先需要确保 AssetsLibrary 没有被 ARC 释放。\n>否则把数据从数组中取出来时，会发现对应的引用数据已经丢失。这一点较为容易被忽略。\n\n因此建议在使用 AssetsLibrary 的 viewController 中，把 AssetsLibrary 作为一个强持有的 property 或私有变量，避免在枚举出 AssetsLibrary 中所需要的数据后，AssetsLibrary 就被 ARC 释放了。\n\n\n# 使用\n\n## 获取所有相册\n\n通过ALAssetsLibrary的实例方法，得到ALAssetsGroup类数组。\n\n\tALAssetsLibrary *assetsLibrary;\n\tNSMutableArray *groupArray;\n \tassetsLibrary = [[ALAssetsLibrary alloc] init];\n   \tgroupArray=[[NSMutableArray alloc] initWithCapacity:1];\n  \t[assetsLibrary enumerateGroupsWithTypes:ALAssetsGroupAll usingBlock:^(ALAssetsGroup *group, BOOL *stop) {\n      \tif (group!=nil) {\n          \t\t  [groupArray addObject:group];\n           \t\t //            通过这个可以知道相册的名字，从而也可以知道安装的部分应用\n          \t\t //例如 Name:柚子相机, Type:Album, Assets count:1\n           \t\t NSLog(@\"%@\",group);\n        \t\t}else{\n        \t\t\tif ([_albumsArray count] > 0) {\n           \t\t\t // 把所有的相册储存完毕，可以展示相册列表\n        \t\t\t} else {\n           \t\t\t // 没有任何有资源的相册，输出提示\n        \t\t\t}\n        \t\t}\n    \t} failureBlock:^(NSError *error) {\n      \t\t\t  NSLog(@\"Group not found!\\n\");\n    }];\n\n## 获取相册下的照片\n\n使用类型为ALAssetsGroup的group对象，获取ALAsset，来得到图片资源\n\n\t[_group enumerateAssetsUsingBlock:^(ALAsset *result, NSUInteger index, BOOL *stop) {\n        if (result) {\n           \n            NSLog(@\"%@\",result);\n             image=[UIImage imageWithCGImage: result.thumbnail];\n\n        }else{\n        \t// result 为 nil，即遍历相片或视频完毕，可以展示资源列表\n    }\n    }];\n\n\n\n\n>参考文章\n\n[ALAsset,ALAssetsLibrary,ALAssetsgroup常见属性及用法](http://blog.csdn.net/shenjx1225/article/details/9293269)\n\n[iOS 开发之照片框架详解](http://kayosite.com/ios-development-and-detail-of-photo-framework.html)\n\n[iOS的AssetsLibrary框架访问所有相片](http://www.mincoder.com/article/2473.shtml)","slug":"技术/2016-3-23-ALAsset","published":1,"updated":"2016-04-09T13:56:12.000Z","comments":1,"photos":[],"link":"","_id":"cisw1ptrw000syrntt268cr42","content":"<h1 id=\"ALAssetsLibrary介绍\"><a href=\"#ALAssetsLibrary介绍\" class=\"headerlink\" title=\"ALAssetsLibrary介绍\"></a>ALAssetsLibrary介绍</h1><p>在iOS中，照片库并不只是照片的集合，同时也包含了视频。</p>\n<p>在 AssetsLibrary 中两者都有相同类型的对象去描述，只是类型不同而已。</p>\n<p>这里稍微介绍一下概念：</p>\n<ul>\n<li>AssetsLibrary: 代表整个设备中的资源库（照片库），通过 AssetsLibrary 可以获取设备中的照片和视频</li>\n<li>ALAssetsGroup: 映射照片库中的一个相册，通过 ALAssetsGroup 可以获取某个相册的信息，相册下的资源，同时也可以对某个相册添加资源。</li>\n<li>ALAsset: 映射照片库中的一个照片或视频，通过 ALAsset 可以获取某个照片或视频的详细信息，或者保存照片和视频。</li>\n<li>ALAssetRepresentation: ALAssetRepresentation可以更方便地获取 ALAsset 中的资源信息，每个 ALAsset 都有至少有一个 ALAssetRepresentation 对象，可以通过 defaultRepresentation 获取。</li>\n</ul>\n<h1 id=\"坑\"><a href=\"#坑\" class=\"headerlink\" title=\"坑\"></a>坑</h1><p>注意！注意！先说说坑，否则直接上手你会和我一样悲剧的。</p>\n<p>当然你也可以跳过去不看 : )</p>\n<h2 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h2><p>我在开发过程中，是这样的思路：</p>\n<p>遍历相册-&gt;遍历时添加相册到数组-&gt;遍历完成，取数组，填入照片浏览器</p>\n<p>这样一看好像没啥错，但是由于它的异步处理，意味着“遍历时添加相册到数组”，”遍历完成，取数组填入照片浏览器“不是顺序执行。</p>\n<p>它们将同时开始，相当于没等到添加完，就已经开始填入照片了。这样的话，数组永远都是空的。</p>\n<p>由于整个 AssetsLibrary 中对相册、资源的获取和保存都是使用异步处理（Asynchronous），这是考虑到资源文件体积相当比较大（还可能很大）。</p>\n<p>例如遍历相册操作，相册的结果使用 block 输出，如果相册遍历完毕，则最后一次输出的 block 中的 group 参数值为 nil。</p>\n<p>我们可以通过判断group是否为nil来知道是否遍历完成。</p>\n<h2 id=\"AssetsLibrary实例需要强引用\"><a href=\"#AssetsLibrary实例需要强引用\" class=\"headerlink\" title=\"AssetsLibrary实例需要强引用\"></a>AssetsLibrary实例需要强引用</h2><p>在通过AsssetsLibrary，获取到照片和视频时。以为万事大吉。</p>\n<p>但是当我把对应的asset放进照片浏览器时，却一直没有图片。</p>\n<p>经过一番调试，发现存储asset对象的数组，里面的对象都已经为空了。</p>\n<p>原因在于：</p>\n<blockquote>\n<p>当我们把这些获取到的相册和资源储存到数组时，实际上只是在数组中储存了这些相册和资源在 AssetsLibrary 中的引用（指针）。<br>因而无论把相册和资源储存数组后如何利用这些数据，都首先需要确保 AssetsLibrary 没有被 ARC 释放。<br>否则把数据从数组中取出来时，会发现对应的引用数据已经丢失。这一点较为容易被忽略。</p>\n</blockquote>\n<p>因此建议在使用 AssetsLibrary 的 viewController 中，把 AssetsLibrary 作为一个强持有的 property 或私有变量，避免在枚举出 AssetsLibrary 中所需要的数据后，AssetsLibrary 就被 ARC 释放了。</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><h2 id=\"获取所有相册\"><a href=\"#获取所有相册\" class=\"headerlink\" title=\"获取所有相册\"></a>获取所有相册</h2><p>通过ALAssetsLibrary的实例方法，得到ALAssetsGroup类数组。</p>\n<pre><code>ALAssetsLibrary *assetsLibrary;\nNSMutableArray *groupArray;\n assetsLibrary = [[ALAssetsLibrary alloc] init];\n   groupArray=[[NSMutableArray alloc] initWithCapacity:1];\n  [assetsLibrary enumerateGroupsWithTypes:ALAssetsGroupAll usingBlock:^(ALAssetsGroup *group, BOOL *stop) {\n      if (group!=nil) {\n                [groupArray addObject:group];\n                //            通过这个可以知道相册的名字，从而也可以知道安装的部分应用\n               //例如 Name:柚子相机, Type:Album, Assets count:1\n                NSLog(@&quot;%@&quot;,group);\n            }else{\n                if ([_albumsArray count] &gt; 0) {\n                    // 把所有的相册储存完毕，可以展示相册列表\n                } else {\n                    // 没有任何有资源的相册，输出提示\n                }\n            }\n    } failureBlock:^(NSError *error) {\n                NSLog(@&quot;Group not found!\\n&quot;);\n}];\n</code></pre><h2 id=\"获取相册下的照片\"><a href=\"#获取相册下的照片\" class=\"headerlink\" title=\"获取相册下的照片\"></a>获取相册下的照片</h2><p>使用类型为ALAssetsGroup的group对象，获取ALAsset，来得到图片资源</p>\n<pre><code>[_group enumerateAssetsUsingBlock:^(ALAsset *result, NSUInteger index, BOOL *stop) {\n    if (result) {\n\n        NSLog(@&quot;%@&quot;,result);\n         image=[UIImage imageWithCGImage: result.thumbnail];\n\n    }else{\n        // result 为 nil，即遍历相片或视频完毕，可以展示资源列表\n}\n}];\n</code></pre><blockquote>\n<p>参考文章</p>\n</blockquote>\n<p><a href=\"http://blog.csdn.net/shenjx1225/article/details/9293269\" target=\"_blank\" rel=\"external\">ALAsset,ALAssetsLibrary,ALAssetsgroup常见属性及用法</a></p>\n<p><a href=\"http://kayosite.com/ios-development-and-detail-of-photo-framework.html\" target=\"_blank\" rel=\"external\">iOS 开发之照片框架详解</a></p>\n<p><a href=\"http://www.mincoder.com/article/2473.shtml\" target=\"_blank\" rel=\"external\">iOS的AssetsLibrary框架访问所有相片</a></p>\n","more":"<h1 id=\"ALAssetsLibrary介绍\"><a href=\"#ALAssetsLibrary介绍\" class=\"headerlink\" title=\"ALAssetsLibrary介绍\"></a>ALAssetsLibrary介绍</h1><p>在iOS中，照片库并不只是照片的集合，同时也包含了视频。</p>\n<p>在 AssetsLibrary 中两者都有相同类型的对象去描述，只是类型不同而已。</p>\n<p>这里稍微介绍一下概念：</p>\n<ul>\n<li>AssetsLibrary: 代表整个设备中的资源库（照片库），通过 AssetsLibrary 可以获取设备中的照片和视频</li>\n<li>ALAssetsGroup: 映射照片库中的一个相册，通过 ALAssetsGroup 可以获取某个相册的信息，相册下的资源，同时也可以对某个相册添加资源。</li>\n<li>ALAsset: 映射照片库中的一个照片或视频，通过 ALAsset 可以获取某个照片或视频的详细信息，或者保存照片和视频。</li>\n<li>ALAssetRepresentation: ALAssetRepresentation可以更方便地获取 ALAsset 中的资源信息，每个 ALAsset 都有至少有一个 ALAssetRepresentation 对象，可以通过 defaultRepresentation 获取。</li>\n</ul>\n<h1 id=\"坑\"><a href=\"#坑\" class=\"headerlink\" title=\"坑\"></a>坑</h1><p>注意！注意！先说说坑，否则直接上手你会和我一样悲剧的。</p>\n<p>当然你也可以跳过去不看 : )</p>\n<h2 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h2><p>我在开发过程中，是这样的思路：</p>\n<p>遍历相册-&gt;遍历时添加相册到数组-&gt;遍历完成，取数组，填入照片浏览器</p>\n<p>这样一看好像没啥错，但是由于它的异步处理，意味着“遍历时添加相册到数组”，”遍历完成，取数组填入照片浏览器“不是顺序执行。</p>\n<p>它们将同时开始，相当于没等到添加完，就已经开始填入照片了。这样的话，数组永远都是空的。</p>\n<p>由于整个 AssetsLibrary 中对相册、资源的获取和保存都是使用异步处理（Asynchronous），这是考虑到资源文件体积相当比较大（还可能很大）。</p>\n<p>例如遍历相册操作，相册的结果使用 block 输出，如果相册遍历完毕，则最后一次输出的 block 中的 group 参数值为 nil。</p>\n<p>我们可以通过判断group是否为nil来知道是否遍历完成。</p>\n<h2 id=\"AssetsLibrary实例需要强引用\"><a href=\"#AssetsLibrary实例需要强引用\" class=\"headerlink\" title=\"AssetsLibrary实例需要强引用\"></a>AssetsLibrary实例需要强引用</h2><p>在通过AsssetsLibrary，获取到照片和视频时。以为万事大吉。</p>\n<p>但是当我把对应的asset放进照片浏览器时，却一直没有图片。</p>\n<p>经过一番调试，发现存储asset对象的数组，里面的对象都已经为空了。</p>\n<p>原因在于：</p>\n<blockquote>\n<p>当我们把这些获取到的相册和资源储存到数组时，实际上只是在数组中储存了这些相册和资源在 AssetsLibrary 中的引用（指针）。<br>因而无论把相册和资源储存数组后如何利用这些数据，都首先需要确保 AssetsLibrary 没有被 ARC 释放。<br>否则把数据从数组中取出来时，会发现对应的引用数据已经丢失。这一点较为容易被忽略。</p>\n</blockquote>\n<p>因此建议在使用 AssetsLibrary 的 viewController 中，把 AssetsLibrary 作为一个强持有的 property 或私有变量，避免在枚举出 AssetsLibrary 中所需要的数据后，AssetsLibrary 就被 ARC 释放了。</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><h2 id=\"获取所有相册\"><a href=\"#获取所有相册\" class=\"headerlink\" title=\"获取所有相册\"></a>获取所有相册</h2><p>通过ALAssetsLibrary的实例方法，得到ALAssetsGroup类数组。</p>\n<pre><code>ALAssetsLibrary *assetsLibrary;\nNSMutableArray *groupArray;\n assetsLibrary = [[ALAssetsLibrary alloc] init];\n   groupArray=[[NSMutableArray alloc] initWithCapacity:1];\n  [assetsLibrary enumerateGroupsWithTypes:ALAssetsGroupAll usingBlock:^(ALAssetsGroup *group, BOOL *stop) {\n      if (group!=nil) {\n                [groupArray addObject:group];\n                //            通过这个可以知道相册的名字，从而也可以知道安装的部分应用\n               //例如 Name:柚子相机, Type:Album, Assets count:1\n                NSLog(@&quot;%@&quot;,group);\n            }else{\n                if ([_albumsArray count] &gt; 0) {\n                    // 把所有的相册储存完毕，可以展示相册列表\n                } else {\n                    // 没有任何有资源的相册，输出提示\n                }\n            }\n    } failureBlock:^(NSError *error) {\n                NSLog(@&quot;Group not found!\\n&quot;);\n}];\n</code></pre><h2 id=\"获取相册下的照片\"><a href=\"#获取相册下的照片\" class=\"headerlink\" title=\"获取相册下的照片\"></a>获取相册下的照片</h2><p>使用类型为ALAssetsGroup的group对象，获取ALAsset，来得到图片资源</p>\n<pre><code>[_group enumerateAssetsUsingBlock:^(ALAsset *result, NSUInteger index, BOOL *stop) {\n    if (result) {\n\n        NSLog(@&quot;%@&quot;,result);\n         image=[UIImage imageWithCGImage: result.thumbnail];\n\n    }else{\n        // result 为 nil，即遍历相片或视频完毕，可以展示资源列表\n}\n}];\n</code></pre><blockquote>\n<p>参考文章</p>\n</blockquote>\n<p><a href=\"http://blog.csdn.net/shenjx1225/article/details/9293269\">ALAsset,ALAssetsLibrary,ALAssetsgroup常见属性及用法</a></p>\n<p><a href=\"http://kayosite.com/ios-development-and-detail-of-photo-framework.html\">iOS 开发之照片框架详解</a></p>\n<p><a href=\"http://www.mincoder.com/article/2473.shtml\">iOS的AssetsLibrary框架访问所有相片</a></p>\n"},{"layout":"post","title":"reviewcode.cn平台部分案例整理","date":"2016-02-28T16:00:00.000Z","keywords":"iOS","description":"iOS资料整理","excerpt":"","_content":"\n>原文来自简书：[reviewcode.cn 平台部分案例整理](http://www.jianshu.com/p/ae1090183fa8?utm_campaign=maleskine&utm_content=note&utm_medium=writer_share&utm_source=weibo)\n\n我是大神们的搬运工\n\n## 彦祖大神的codeReview平台\n@叶孤城___ 大神搞了一个提供邀请业内大神付费为你的项目进行CodeReview的平台，产出一份高质量的review报告。[www.reviewcode.cn](www.reviewcode.cn)\n\n## 平台案例整理\n\n可能不见得每个人都要把自己所有的项目，扔到平台上让大神们review，但是我们可以进行归纳总结，在那些大神们的`高质量review报告`中，归纳和总结我们自己需要的，汲取养分。\n\n更何况这些总结，每一个都包含着真实的代码案例，优化方案，以及原因详解，比我们每天看设计模式那些抽象的理念，名词，要接地气的多\n\n我不是大神，我只是大神的搬运工\n\n(农夫山泉的广告词...咳...装X了...跑题了...)\n\n目前CodeReview平台上已经有了超级详尽的10篇review报告，每一个都是实打实的干活，所以我就搬运一下，把他们case by case 的review报告，梳理归类一下，换个形式进行总结和学习\n\n### 为什么要做CodeReview？\n引用大神在网站中的一句话\n\n>因为 Code Review 是一种最快捷有效的方式让你清楚地知道“好的代码是怎样写出的”。不知道你们有没有这样的经历。\n\n>知道如何完成一个功能，或者完成一个组件。但是碰到稍微复杂的逻辑和业务，就会很容易的让代码变得一团糟。书中常常提及的解耦、分拆复杂逻辑都似乎变成了纸上谈兵，无从下手。又或者，总觉得自己的代码哪里不对劲，和高手们写的简洁、易懂、风格优雅的代码总是有似乎逾越不了的鸿沟。\n\n\n我个人是觉得，代码能力的培养，代码质量的提升，不仅仅是我又学到了什么新技术，掌握了什么nb的黑科技。\n\n更离不开对自己写出的每一句代码的反复challenge，小到命名规范，数字常量，大到模块设计，项目结构，无处不存在着可以不断优化和提升的细节。\n\n看看行业的高手大神们是怎么思考和写码的，看看他们在跟你思考一模一样的问题的时候，他们视野他们的角度，学习，汲取，不断地提升自己\n\n>观一叶而知秋，道不远人即为此\n\n代码的`道`，其实就在这些点点滴滴的细节所汇聚而成的`艺术品`里（咳...装X了...跑题了...）\n\n\n### 一. 命名规范\n\n在10篇review报告中有3篇提到了命名规范这个事情\n\n- [一些代码建议](http://www.reviewcode.cn/article.html?reviewId=8)\n- [要你命三千：老代码中的那些坑](http://www.reviewcode.cn/article.html?reviewId=3)\n- [命名的艺术](http://www.reviewcode.cn/article.html?reviewId=2)\n\n其实关于命名规范，有很多现成的方法论和规范了，各种语言，对于类，函数，变量，等等，一查都能查到很多。我觉得这里面最重要的意义是让你写出的东西别人好读，好认，不要靠猜。\n\n大神们给出了很多建议\n\n- 前缀：建议所有类名、enum 定义、typedef 类型定义，都加上前缀（prefix）\n- 拼写错误：不用多说了\n- 命名规范：建议尽可能统一，就算多人团队合作，在开发中统一一下习惯总是好的。\n \t- 比如到底是_分割还是驼峰大小写分割单词？（建议驼峰）\n \t- 是否对返回值的类型描述写入函数名，方法名里面？（建议写像苹果系统Api）\n\n\n[命名的艺术](http://www.reviewcode.cn/article.html?reviewId=2)这篇报告更是着重的对命名规范从四个方向进行了很深入的剖析\n\n- 变量的命名\n- 代理的命名\n- 图片资源的命名\n- 方法的命名\n\n### 二.编码细节\n写代码的时候，有时候很细微的一行代码，稍加变化，稍加处理，可能就会有很多性能，可读性，扩展性等得提升，在10篇review报告中，有太多这样高质量的编码细节干活。\n\n#### 1）数字与常量\n\n- [要你命三千：老代码中的那些坑](http://www.reviewcode.cn/article.html?reviewId=3)\n- [关于性能的一些问题](http://www.reviewcode.cn/article.html?reviewId=7)\n- [好的代码习惯](http://www.reviewcode.cn/article.html?reviewId=10)\n- [一些优化代码结构的方法](http://www.reviewcode.cn/article.html?reviewId=4)\n\n都提到了`数字`，比如\n\n# \n\n\tUILabel *infoLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 241, 320, 28)];\n\t\n这个还算好的，再看看这个\n\n\tCGRect rect = CGRectMake(12.2+(page-1)*320+42.5*(i%7),((totalRows-1)%3)*55+2,42.5,42.5);\n\t\n\t\n大神们建议这么使用\n\n\tstatic const CGFloat kTagHeight = 30.0f;\n\tstatic const CGFloat kTagLabelWidthInset = 16.0f;\n\n\n另外，不建议用宏，具体有兴趣大家可以看简书的这个帖子 ，[iOS中关于宏定义与常量的使用](http://www.jianshu.com/p/c941e37a8a1d)，简单的说就是宏会增加编译速度\n\n同理一些字符串`常量`等，都建议使用 这样的定义\n\n\tstatic NSString *const kcircleModelDataCategoryName = @\"categoryName\";\n\n#### 2）监听通知的位置\n\n[一些优化代码结构的方法](http://www.reviewcode.cn/article.html?reviewId=4)\n\n>有人在willAppear和Disappear中添加通知，这样极容易出现问题。因为willAppear和Disappear出现的顺序并不一定是一对一的。所以有可能造成多次添加，多次移除通知。\n\n大神们建议这么使用\n>建议在viewDidLoad里添加通知。在dealloc里移除通知。\n\n#### 3） 私有成员 or Property\n\n[话谈 iOS 目录结构的划分](http://www.reviewcode.cn/article.html?reviewId=9)中提到的一个问题\n\n\t@interface PartyViewController ()\n\n\t@property (weak, nonatomic) IBOutlet UITableView *partyTableView;\n\t@property (strong,nonatomic) NSMutableArray *partys;\n\t@end\n\t\n\t@implementation PartyViewController{\n\t\n\t    NSMutableArray *lodedIndex;\n\t}\n\t\n到底该用哪一个？\n\n大婶们的建议是\n>无论如何，应该一致，应该统一风格。建议这里用 property 。因为 @IBOutlet ，从 IB 拖出来的属性用的就是 property ，所以统一用 property 较好。\n\t\n关于这个，其实在开发中有一定的争议的，有兴趣的可以看一下唐巧老师的这篇文章，[开发中得争议](http://blog.devtang.com/2015/03/15/ios-dev-controversy-1/)\n\n#### 4） typedef block\n[话谈 iOS 目录结构的划分](http://www.reviewcode.cn/article.html?reviewId=9) 提到代码中多次使用的block，诸如`(void (^)(NSError *error))`等，可以统一进行声明，不要每次都手打完整block定义\n\n好处是\n\n>还可以用上 Xcode 的自动补全功能，当你输入 Fa 的时候， FailureBlock 的提示就出来了。用 (void (^)(NSError *error)) 就没有自动补全了，每次都要手工输入一遍，很麻烦\n\n#### 5） 数字类型\n\n[话谈 iOS 目录结构的划分](http://www.reviewcode.cn/article.html?reviewId=9)中提到了3个问题\n\n- 用 int 还是 NSInteger\n- 尺寸变量统一用 CGFloat\n- 选用正确的类型，让编译器能静态检查\n\n\n第一个问题\n\n>可以注意到 apple 的 UIKit 等代码一般都是用的 NSInteger。NSInteger 在 32位系统是 int ，64位系统是 long 。Apple 把它用在函数的参数处，和返回的地方。为什么？因为函数是需要跟其它代码或其它平台的代码交流互动的，所以是 int 还是 long 很重要。系统的代码用的是 NSInteger 的话，你的用了 int 的话，可能不够大而造成崩溃。\n\n还是建议NSInteger\n\n第二个问题 \n> 一开始看到 `int padding = 1` 后，不知道它是干嘛的。因为附近没有它的代码，看到后面才知道的。所以声明类型为 CGFloat ，更容易知道它是来定义尺寸距离的。\n\n为什么建议这样，CG开头是CoreGraphic的简写，我们开发也会发现CGFloat 是需要 import `UIKit`的，从名字定义上，他是与现实UI有关的\n\n第三个问题\n\n具体可以看链接里的案例\n\n简单的说就是，很多NSInterger等数值属性，不要把他定义成NSNumber，因为编译器在发现你对integer变量赋值float变量的时候会自动报错，是一个自动纠错的功能，如果定义成了NSNumber，用语法糖@（float）去转换，就不能自动纠错了\n\n#### 6）属性修饰符建议\n[好的代码习惯](http://www.reviewcode.cn/article.html?reviewId=10)\n\n>在arc中，弱引用最好使用weak，来避免野指针的出现，weak可以在指向的对象dealloc的时候自动置为nil。\n\n>在arc中强引用尽量使用strong，当然这里strong和retain的作用是一样的，但是为了保持代码的一致性，这里推荐使用strong。\n\n具体可以看链接中得案例\n\n#### 7） 字面量语法\n\n[好的代码习惯](http://www.reviewcode.cn/article.html?reviewId=10)\n\n\t_comps.items = [NSArray arrayWithObjects:_photoBarButton, _mediaBarButton, _alarmBarButton, _brushBarButton, _voiceBarButton, _doneBarButton, nil];\n\n字面量语法\n\n\t_comps.items = @[_photoBarButton, _mediaBarButton, _alarmBarButton, _brushBarButton, _voiceBarButton, _doneBarButton];\n\t\n>这种做法不仅简单，还更加安全。假如当中的_alarmBarButton为nil，那么通过第一种写法，数组还是会创建出来，只不过数组内只有2个对象，原因在于，“arrayWithObjects:”方法会依次处理各个参数，直到发现nil为止，而第二种写法会在插入nil指针的时候抛出异常，令程序终止运行，这比创建好数组后才发现数组内的元素个数少了要好很多。异常往往能更快地发现错误。\n\n### 三.设计思路\n#### 1）公有私有混乱\n[要你命三千：老代码中的那些坑](http://www.reviewcode.cn/article.html?reviewId=3)\n\n具体案例可以看Link中得细节，大致思路是尽可能的减少接口在头文件中所暴露出来的属性和方法，头文件要尽可能的简洁\n\n如果有可能也尽量避免，一个头文件中出现多个类声明\n\n>头文件里地方小，塞到一处并不好。 外部对象都知道，安全问题可不小\n\n#### 2）消息通知满天飞\n[要你命三千：老代码中的那些坑](http://www.reviewcode.cn/article.html?reviewId=3)\n\n通知虽好，但也不要贪杯啊。\n\n>看起来轻松，只是 post 了一下就搞定了，但是在 Debug 的时候有点麻烦。尤其是如果有多个 Observer ，改动的时候牵一发而动全身。如果真的是有这样使用的必要倒也罢了，但是本来一个 block 或者 delegate 就能简单清晰的解决，现在却被搞得这么繁重，实在是没有必要。\n\n我觉得明确使用通知的场景，在不需要一对多的情况下，路径不算远的2个模块，完全可以通过delegate，或者block解决\n\n#### 3）单个对象多职责\n[要你命三千：老代码中的那些坑](http://www.reviewcode.cn/article.html?reviewId=3)\n\n同一个一个模块\n\n- 上能和服务器聊天，上传聊天消息同步聊天记录\n- 下能做本地缓存管理，增删改查样样精通\n- 弹窗提醒，上传进度，完成提示，亦是轻松拿下。\n- 以至于你改着改着不知不觉都会走到这里，因为它处理了太多太多的业务逻辑，每次 DEBUG 追杀断点回到这里，都像是一场久别重逢时的相遇，似曾相识\n\n>一人做事一人当，切忌都往类里装。 开发人员干的爽，维护人员很受伤。\n\n#### 4）盲目新增功能\n[要你命三千：老代码中的那些坑](http://www.reviewcode.cn/article.html?reviewId=3)\n\n具体案例可以看Link中的细节，简单描述下就是，随着项目的迭代，一个小功能点，多一个标记位，再来一个小功能点，又多一个标记位，随着业务迭代下去，标记位越来越多，如果这里面涉及到逻辑上的关联，一单有个标记位得特殊处理一下，那N个`if`嵌套的场景，简直是`画美不看`\n\n新增的业务需求，还是要经常和老功能进行梳理和总结，该合并该梳理的都要重新和老代码里一起整合，切记直接拍脑袋上手直接添加功能\n\n#### 5）滥用委托\n[要你命三千：老代码中的那些坑](http://www.reviewcode.cn/article.html?reviewId=3)\n\n[封装一个UI控件的范例](http://www.reviewcode.cn/article.html?reviewId=5)\n\n都提到了在处理回调的时候，委托或者block的2个方式的对比\n\n>所谓悲哀就是，当程序员发现一个 delegate 就能访问上级的对象，于是便把各种需要通知上级的事情都放在了委托方法里，尽管这些事情与委托本身无关，但是为了实现功能已经不在意这些所谓的设计与美观\n\n>可以考虑用block来传递数据源和响应事件，这样封装的view在代码的连贯性上更好一些\n\n简单的说结合具体案例，恰当的采用委托或者block来实现\n\n#### 6）静态DataSource\n[一些优化代码结构的方法](http://www.reviewcode.cn/article.html?reviewId=4)\n\n开发中难免会遇到很多静态的几乎很少变化的tableView界面\n\n图省事的人直接在代码里 switchCase  一行行的硬编码，写死了整个tableview的界面\n\n还是推荐使用plist，用代码从数据源中读取数据，从而进行展示\n\n>这样，后续迭代版本的内容只需要修改plist文件的内容就可以了。而不需要在代码中修改逻辑。\n\n#### 7）使用orm\n[一些优化代码结构的方法](http://www.reviewcode.cn/article.html?reviewId=4)\n\n很多人都是这么做的\n\n不要在解析网络等数据的时候，手写解析过程，采用`mantle`or`JsonModel`等框架来做这些事情\n\n#### 8）构建易于测试的模块\n[一些优化代码结构的方法](http://www.reviewcode.cn/article.html?reviewId=4)\n[如何打造令人愉悦的开发环境](http://www.reviewcode.cn/article.html?reviewId=1)\n\n都提到了，尽量在开发中设计易于测试的模块。\n众多功能杂糅在一个类里面是不利于测试的，写一个超大函数，干了很多功能也是不利于编写自动化测试的\n后面还会提到，随着项目的逐渐扩大，保持至健壮的自动化测试+持续集成，才是一个健康的项目结构\n\n#### 9）不要想当然的使用tableView\n\n[不要想当然的使用tableView](http://www.reviewcode.cn/article.html?reviewId=6)\n\n- 不要试图过分的复用一个TableViewController\n- 一定要复用的场景\n\t- 用switch来区分场景，用不同的tableview进行处理\n\t- 将数据源的判断逻辑，不同的tableview类给自己处理自己的`delegate` or `datasource`\n\t- 这样多路复用的选择其实就发生在了返回tableView的操作里，可以避免在控制器中出现臃肿的代码\n- 不要试图滥用Cell的重用机制\n\n#### 10）圆角\n[关于性能的一些问题](http://www.reviewcode.cn/article.html?reviewId=7)\n\n详细可以看关于离屏渲染的Link中的介绍，\n也可以看另一位大神ibireme对渲染流畅的文章，[iOS 保持界面流畅的技巧](http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)\n\n简单的说就是`CALayer`的`圆角`和`阴影`，当出现在大量的cell之中，会进项很多的离屏渲染，这样就会大幅度拖慢FPS\n\n如何解决？\n>圆角使用UIImageView来处理。\n简单来说，底层铺一个UIImageView,然后用GraphicsContext生成一张带圆角的图。\n\n#### 11) App沙盒数据存储目录\n\n[一些代码建议](http://www.reviewcode.cn/article.html?reviewId=8)\n\n>数据存储应该再谨慎一些，至少用户数据可以放在 Documents 文件夹下某个子目录里，而不应该直接丢到 Documents 文件夹下，清空时也不应该清空整个 Documents 文件夹。\n\nPS:顺带我想说，如果app配置了itunes查看Documents的功能，apple审核的时候会查看documents目录，一些非用户可感知的数据，程序生成的数据，存放在Doc目录下，可能会被苹果拒审\n\n#### 12） 即时抽取函数\n\n[话谈 iOS 目录结构的划分](http://www.reviewcode.cn/article.html?reviewId=9)\n\n可以细看Link中的案例\n\n简单描述就是，随着业务的不断增长，有时候会出现超长的函数，有时候会有相似代码，被写出来，适当的即时抽取函数，减少超长代码，减少近似冗余代码\n\n#### 13） 使用懒加载\n[好的代码习惯](http://www.reviewcode.cn/article.html?reviewId=10)\n\n \t[self initComps];\n    [self initToolbar];\n    [self initVertical];\n    [self initImageView];\n    [self initMediaPick];\n    [self setupSpeechRecognizer];\n    [self initAttributedString];\n    [self initTextView];\n\n这样的代码，推荐使用懒加载\n\n>懒加载带来的收益：我们不再需要显式的生成和调用initAttributedString方法，只需要在使用的时候调用属性self.attrString，对象的实例化全部放在getter中，可以有效降低代码的耦合度;在使用属性之前，属性并不会提前生成，减少内存占用。\n\n#### 13）delegate校验参数\n[好的代码习惯](http://www.reviewcode.cn/article.html?reviewId=10)\n\n\t- (void)textViewDidEndEditing:(YYTextView *)textView {\n\t    if (textView == self.textView) {\n\t        self.navigationItem.rightBarButtonItem = nil;\n\t    }\n\t}\n\t\n>如果你的delegate方法，只作为一个textView的委托回调，这种写法没有任何。但是如果你想扩展你的界面，在将来的界面中很可能出现另一个textView，这时你就必须区分这两个textView是谁回调了这个代理方法\n\n### 四. 项目配置\n\n#### 1）目录结构\n[话谈iOS目录结构的划分](http://www.reviewcode.cn/article.html?reviewId=9)\n\n提到了MVC结构，以及MVC结构下如何划分目录结构\n\n>往往业界有两种做法：\n\n>先按业务划分，再按照 MVC 来划分\n\n>先按 MVC 划分，再按照业务划分\n\n>第一种的好处是把相应业务的代码放在一起，找特别好找，相应的 xib、model 和 ViewController 全在一个地方。在这些代码之间跳转特别方便。Telegram 非常大的代码量，也是这么组织的。个人觉得如果代码量特别大，这种划分方式其实更好，先按照业务划分了，更容易分工合作。\n\n>第二种似乎更多人用。Yep 也是按照这样的方式组织。\n\n>其实我觉得都可以，看个人习惯。\n\nPS:我表示，我可能更习惯`先按业务模块划分，再MVC`\n\n#### 2）合理高效的开发环境\n[如何打造令人愉悦的开发环境](http://www.reviewcode.cn/article.html?reviewId=1)\n\n这个案例里面详尽探讨了一个观点 `一个合理高效的开发环境应该是依托于自动化之上的.`\n\n自动化应当包含以下几个方面:\n- 代码风格检查\n- 自动化测试\n- 持续集成\n- 常用库的封装和打包\n\n#### 3）第三方库管理\n[如何打造令人愉悦的开发环境](http://www.reviewcode.cn/article.html?reviewId=1)\n[要你命三千：老代码中的那些坑](http://www.reviewcode.cn/article.html?reviewId=3)\n\n- 各种第三方库推荐使用cocoapods管理，提高效率\n- 项目勤用三方库，随意穿插改无数。 即使类库有更新，试问代码谁维护\n\n#### 4) 自动打包配置\n[iOS下如何自动化打包App](http://www.reviewcode.cn/article.html?reviewId=11)\n\n- 自动化的全面配置打包平台的一个方案\n\n\n\n### 持续更新\ncodeReview应该持续进行下去，这个总结也应该持续进行。\n\n扔到Git上吧，[iOSCodeReviewTipsCollection](https://github.com/Awhisper/iOSCodeReviewTipsCollection)，（╮(╯_╰)╭ 又TM是广告)","source":"_posts/技术/2016-2-29-reviewcode.md","raw":"---\nlayout: post\ntitle: reviewcode.cn平台部分案例整理\ndate: 2016-2-29\ncategory: 技术\ntags: 资料\nkeywords: iOS\ndescription: iOS资料整理\nexcerpt: 分享一篇干货！转载自网络，已得到作者同意\n---\n\n>原文来自简书：[reviewcode.cn 平台部分案例整理](http://www.jianshu.com/p/ae1090183fa8?utm_campaign=maleskine&utm_content=note&utm_medium=writer_share&utm_source=weibo)\n\n我是大神们的搬运工\n\n## 彦祖大神的codeReview平台\n@叶孤城___ 大神搞了一个提供邀请业内大神付费为你的项目进行CodeReview的平台，产出一份高质量的review报告。[www.reviewcode.cn](www.reviewcode.cn)\n\n## 平台案例整理\n\n可能不见得每个人都要把自己所有的项目，扔到平台上让大神们review，但是我们可以进行归纳总结，在那些大神们的`高质量review报告`中，归纳和总结我们自己需要的，汲取养分。\n\n更何况这些总结，每一个都包含着真实的代码案例，优化方案，以及原因详解，比我们每天看设计模式那些抽象的理念，名词，要接地气的多\n\n我不是大神，我只是大神的搬运工\n\n(农夫山泉的广告词...咳...装X了...跑题了...)\n\n目前CodeReview平台上已经有了超级详尽的10篇review报告，每一个都是实打实的干活，所以我就搬运一下，把他们case by case 的review报告，梳理归类一下，换个形式进行总结和学习\n\n### 为什么要做CodeReview？\n引用大神在网站中的一句话\n\n>因为 Code Review 是一种最快捷有效的方式让你清楚地知道“好的代码是怎样写出的”。不知道你们有没有这样的经历。\n\n>知道如何完成一个功能，或者完成一个组件。但是碰到稍微复杂的逻辑和业务，就会很容易的让代码变得一团糟。书中常常提及的解耦、分拆复杂逻辑都似乎变成了纸上谈兵，无从下手。又或者，总觉得自己的代码哪里不对劲，和高手们写的简洁、易懂、风格优雅的代码总是有似乎逾越不了的鸿沟。\n\n\n我个人是觉得，代码能力的培养，代码质量的提升，不仅仅是我又学到了什么新技术，掌握了什么nb的黑科技。\n\n更离不开对自己写出的每一句代码的反复challenge，小到命名规范，数字常量，大到模块设计，项目结构，无处不存在着可以不断优化和提升的细节。\n\n看看行业的高手大神们是怎么思考和写码的，看看他们在跟你思考一模一样的问题的时候，他们视野他们的角度，学习，汲取，不断地提升自己\n\n>观一叶而知秋，道不远人即为此\n\n代码的`道`，其实就在这些点点滴滴的细节所汇聚而成的`艺术品`里（咳...装X了...跑题了...）\n\n\n### 一. 命名规范\n\n在10篇review报告中有3篇提到了命名规范这个事情\n\n- [一些代码建议](http://www.reviewcode.cn/article.html?reviewId=8)\n- [要你命三千：老代码中的那些坑](http://www.reviewcode.cn/article.html?reviewId=3)\n- [命名的艺术](http://www.reviewcode.cn/article.html?reviewId=2)\n\n其实关于命名规范，有很多现成的方法论和规范了，各种语言，对于类，函数，变量，等等，一查都能查到很多。我觉得这里面最重要的意义是让你写出的东西别人好读，好认，不要靠猜。\n\n大神们给出了很多建议\n\n- 前缀：建议所有类名、enum 定义、typedef 类型定义，都加上前缀（prefix）\n- 拼写错误：不用多说了\n- 命名规范：建议尽可能统一，就算多人团队合作，在开发中统一一下习惯总是好的。\n \t- 比如到底是_分割还是驼峰大小写分割单词？（建议驼峰）\n \t- 是否对返回值的类型描述写入函数名，方法名里面？（建议写像苹果系统Api）\n\n\n[命名的艺术](http://www.reviewcode.cn/article.html?reviewId=2)这篇报告更是着重的对命名规范从四个方向进行了很深入的剖析\n\n- 变量的命名\n- 代理的命名\n- 图片资源的命名\n- 方法的命名\n\n### 二.编码细节\n写代码的时候，有时候很细微的一行代码，稍加变化，稍加处理，可能就会有很多性能，可读性，扩展性等得提升，在10篇review报告中，有太多这样高质量的编码细节干活。\n\n#### 1）数字与常量\n\n- [要你命三千：老代码中的那些坑](http://www.reviewcode.cn/article.html?reviewId=3)\n- [关于性能的一些问题](http://www.reviewcode.cn/article.html?reviewId=7)\n- [好的代码习惯](http://www.reviewcode.cn/article.html?reviewId=10)\n- [一些优化代码结构的方法](http://www.reviewcode.cn/article.html?reviewId=4)\n\n都提到了`数字`，比如\n\n# \n\n\tUILabel *infoLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 241, 320, 28)];\n\t\n这个还算好的，再看看这个\n\n\tCGRect rect = CGRectMake(12.2+(page-1)*320+42.5*(i%7),((totalRows-1)%3)*55+2,42.5,42.5);\n\t\n\t\n大神们建议这么使用\n\n\tstatic const CGFloat kTagHeight = 30.0f;\n\tstatic const CGFloat kTagLabelWidthInset = 16.0f;\n\n\n另外，不建议用宏，具体有兴趣大家可以看简书的这个帖子 ，[iOS中关于宏定义与常量的使用](http://www.jianshu.com/p/c941e37a8a1d)，简单的说就是宏会增加编译速度\n\n同理一些字符串`常量`等，都建议使用 这样的定义\n\n\tstatic NSString *const kcircleModelDataCategoryName = @\"categoryName\";\n\n#### 2）监听通知的位置\n\n[一些优化代码结构的方法](http://www.reviewcode.cn/article.html?reviewId=4)\n\n>有人在willAppear和Disappear中添加通知，这样极容易出现问题。因为willAppear和Disappear出现的顺序并不一定是一对一的。所以有可能造成多次添加，多次移除通知。\n\n大神们建议这么使用\n>建议在viewDidLoad里添加通知。在dealloc里移除通知。\n\n#### 3） 私有成员 or Property\n\n[话谈 iOS 目录结构的划分](http://www.reviewcode.cn/article.html?reviewId=9)中提到的一个问题\n\n\t@interface PartyViewController ()\n\n\t@property (weak, nonatomic) IBOutlet UITableView *partyTableView;\n\t@property (strong,nonatomic) NSMutableArray *partys;\n\t@end\n\t\n\t@implementation PartyViewController{\n\t\n\t    NSMutableArray *lodedIndex;\n\t}\n\t\n到底该用哪一个？\n\n大婶们的建议是\n>无论如何，应该一致，应该统一风格。建议这里用 property 。因为 @IBOutlet ，从 IB 拖出来的属性用的就是 property ，所以统一用 property 较好。\n\t\n关于这个，其实在开发中有一定的争议的，有兴趣的可以看一下唐巧老师的这篇文章，[开发中得争议](http://blog.devtang.com/2015/03/15/ios-dev-controversy-1/)\n\n#### 4） typedef block\n[话谈 iOS 目录结构的划分](http://www.reviewcode.cn/article.html?reviewId=9) 提到代码中多次使用的block，诸如`(void (^)(NSError *error))`等，可以统一进行声明，不要每次都手打完整block定义\n\n好处是\n\n>还可以用上 Xcode 的自动补全功能，当你输入 Fa 的时候， FailureBlock 的提示就出来了。用 (void (^)(NSError *error)) 就没有自动补全了，每次都要手工输入一遍，很麻烦\n\n#### 5） 数字类型\n\n[话谈 iOS 目录结构的划分](http://www.reviewcode.cn/article.html?reviewId=9)中提到了3个问题\n\n- 用 int 还是 NSInteger\n- 尺寸变量统一用 CGFloat\n- 选用正确的类型，让编译器能静态检查\n\n\n第一个问题\n\n>可以注意到 apple 的 UIKit 等代码一般都是用的 NSInteger。NSInteger 在 32位系统是 int ，64位系统是 long 。Apple 把它用在函数的参数处，和返回的地方。为什么？因为函数是需要跟其它代码或其它平台的代码交流互动的，所以是 int 还是 long 很重要。系统的代码用的是 NSInteger 的话，你的用了 int 的话，可能不够大而造成崩溃。\n\n还是建议NSInteger\n\n第二个问题 \n> 一开始看到 `int padding = 1` 后，不知道它是干嘛的。因为附近没有它的代码，看到后面才知道的。所以声明类型为 CGFloat ，更容易知道它是来定义尺寸距离的。\n\n为什么建议这样，CG开头是CoreGraphic的简写，我们开发也会发现CGFloat 是需要 import `UIKit`的，从名字定义上，他是与现实UI有关的\n\n第三个问题\n\n具体可以看链接里的案例\n\n简单的说就是，很多NSInterger等数值属性，不要把他定义成NSNumber，因为编译器在发现你对integer变量赋值float变量的时候会自动报错，是一个自动纠错的功能，如果定义成了NSNumber，用语法糖@（float）去转换，就不能自动纠错了\n\n#### 6）属性修饰符建议\n[好的代码习惯](http://www.reviewcode.cn/article.html?reviewId=10)\n\n>在arc中，弱引用最好使用weak，来避免野指针的出现，weak可以在指向的对象dealloc的时候自动置为nil。\n\n>在arc中强引用尽量使用strong，当然这里strong和retain的作用是一样的，但是为了保持代码的一致性，这里推荐使用strong。\n\n具体可以看链接中得案例\n\n#### 7） 字面量语法\n\n[好的代码习惯](http://www.reviewcode.cn/article.html?reviewId=10)\n\n\t_comps.items = [NSArray arrayWithObjects:_photoBarButton, _mediaBarButton, _alarmBarButton, _brushBarButton, _voiceBarButton, _doneBarButton, nil];\n\n字面量语法\n\n\t_comps.items = @[_photoBarButton, _mediaBarButton, _alarmBarButton, _brushBarButton, _voiceBarButton, _doneBarButton];\n\t\n>这种做法不仅简单，还更加安全。假如当中的_alarmBarButton为nil，那么通过第一种写法，数组还是会创建出来，只不过数组内只有2个对象，原因在于，“arrayWithObjects:”方法会依次处理各个参数，直到发现nil为止，而第二种写法会在插入nil指针的时候抛出异常，令程序终止运行，这比创建好数组后才发现数组内的元素个数少了要好很多。异常往往能更快地发现错误。\n\n### 三.设计思路\n#### 1）公有私有混乱\n[要你命三千：老代码中的那些坑](http://www.reviewcode.cn/article.html?reviewId=3)\n\n具体案例可以看Link中得细节，大致思路是尽可能的减少接口在头文件中所暴露出来的属性和方法，头文件要尽可能的简洁\n\n如果有可能也尽量避免，一个头文件中出现多个类声明\n\n>头文件里地方小，塞到一处并不好。 外部对象都知道，安全问题可不小\n\n#### 2）消息通知满天飞\n[要你命三千：老代码中的那些坑](http://www.reviewcode.cn/article.html?reviewId=3)\n\n通知虽好，但也不要贪杯啊。\n\n>看起来轻松，只是 post 了一下就搞定了，但是在 Debug 的时候有点麻烦。尤其是如果有多个 Observer ，改动的时候牵一发而动全身。如果真的是有这样使用的必要倒也罢了，但是本来一个 block 或者 delegate 就能简单清晰的解决，现在却被搞得这么繁重，实在是没有必要。\n\n我觉得明确使用通知的场景，在不需要一对多的情况下，路径不算远的2个模块，完全可以通过delegate，或者block解决\n\n#### 3）单个对象多职责\n[要你命三千：老代码中的那些坑](http://www.reviewcode.cn/article.html?reviewId=3)\n\n同一个一个模块\n\n- 上能和服务器聊天，上传聊天消息同步聊天记录\n- 下能做本地缓存管理，增删改查样样精通\n- 弹窗提醒，上传进度，完成提示，亦是轻松拿下。\n- 以至于你改着改着不知不觉都会走到这里，因为它处理了太多太多的业务逻辑，每次 DEBUG 追杀断点回到这里，都像是一场久别重逢时的相遇，似曾相识\n\n>一人做事一人当，切忌都往类里装。 开发人员干的爽，维护人员很受伤。\n\n#### 4）盲目新增功能\n[要你命三千：老代码中的那些坑](http://www.reviewcode.cn/article.html?reviewId=3)\n\n具体案例可以看Link中的细节，简单描述下就是，随着项目的迭代，一个小功能点，多一个标记位，再来一个小功能点，又多一个标记位，随着业务迭代下去，标记位越来越多，如果这里面涉及到逻辑上的关联，一单有个标记位得特殊处理一下，那N个`if`嵌套的场景，简直是`画美不看`\n\n新增的业务需求，还是要经常和老功能进行梳理和总结，该合并该梳理的都要重新和老代码里一起整合，切记直接拍脑袋上手直接添加功能\n\n#### 5）滥用委托\n[要你命三千：老代码中的那些坑](http://www.reviewcode.cn/article.html?reviewId=3)\n\n[封装一个UI控件的范例](http://www.reviewcode.cn/article.html?reviewId=5)\n\n都提到了在处理回调的时候，委托或者block的2个方式的对比\n\n>所谓悲哀就是，当程序员发现一个 delegate 就能访问上级的对象，于是便把各种需要通知上级的事情都放在了委托方法里，尽管这些事情与委托本身无关，但是为了实现功能已经不在意这些所谓的设计与美观\n\n>可以考虑用block来传递数据源和响应事件，这样封装的view在代码的连贯性上更好一些\n\n简单的说结合具体案例，恰当的采用委托或者block来实现\n\n#### 6）静态DataSource\n[一些优化代码结构的方法](http://www.reviewcode.cn/article.html?reviewId=4)\n\n开发中难免会遇到很多静态的几乎很少变化的tableView界面\n\n图省事的人直接在代码里 switchCase  一行行的硬编码，写死了整个tableview的界面\n\n还是推荐使用plist，用代码从数据源中读取数据，从而进行展示\n\n>这样，后续迭代版本的内容只需要修改plist文件的内容就可以了。而不需要在代码中修改逻辑。\n\n#### 7）使用orm\n[一些优化代码结构的方法](http://www.reviewcode.cn/article.html?reviewId=4)\n\n很多人都是这么做的\n\n不要在解析网络等数据的时候，手写解析过程，采用`mantle`or`JsonModel`等框架来做这些事情\n\n#### 8）构建易于测试的模块\n[一些优化代码结构的方法](http://www.reviewcode.cn/article.html?reviewId=4)\n[如何打造令人愉悦的开发环境](http://www.reviewcode.cn/article.html?reviewId=1)\n\n都提到了，尽量在开发中设计易于测试的模块。\n众多功能杂糅在一个类里面是不利于测试的，写一个超大函数，干了很多功能也是不利于编写自动化测试的\n后面还会提到，随着项目的逐渐扩大，保持至健壮的自动化测试+持续集成，才是一个健康的项目结构\n\n#### 9）不要想当然的使用tableView\n\n[不要想当然的使用tableView](http://www.reviewcode.cn/article.html?reviewId=6)\n\n- 不要试图过分的复用一个TableViewController\n- 一定要复用的场景\n\t- 用switch来区分场景，用不同的tableview进行处理\n\t- 将数据源的判断逻辑，不同的tableview类给自己处理自己的`delegate` or `datasource`\n\t- 这样多路复用的选择其实就发生在了返回tableView的操作里，可以避免在控制器中出现臃肿的代码\n- 不要试图滥用Cell的重用机制\n\n#### 10）圆角\n[关于性能的一些问题](http://www.reviewcode.cn/article.html?reviewId=7)\n\n详细可以看关于离屏渲染的Link中的介绍，\n也可以看另一位大神ibireme对渲染流畅的文章，[iOS 保持界面流畅的技巧](http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)\n\n简单的说就是`CALayer`的`圆角`和`阴影`，当出现在大量的cell之中，会进项很多的离屏渲染，这样就会大幅度拖慢FPS\n\n如何解决？\n>圆角使用UIImageView来处理。\n简单来说，底层铺一个UIImageView,然后用GraphicsContext生成一张带圆角的图。\n\n#### 11) App沙盒数据存储目录\n\n[一些代码建议](http://www.reviewcode.cn/article.html?reviewId=8)\n\n>数据存储应该再谨慎一些，至少用户数据可以放在 Documents 文件夹下某个子目录里，而不应该直接丢到 Documents 文件夹下，清空时也不应该清空整个 Documents 文件夹。\n\nPS:顺带我想说，如果app配置了itunes查看Documents的功能，apple审核的时候会查看documents目录，一些非用户可感知的数据，程序生成的数据，存放在Doc目录下，可能会被苹果拒审\n\n#### 12） 即时抽取函数\n\n[话谈 iOS 目录结构的划分](http://www.reviewcode.cn/article.html?reviewId=9)\n\n可以细看Link中的案例\n\n简单描述就是，随着业务的不断增长，有时候会出现超长的函数，有时候会有相似代码，被写出来，适当的即时抽取函数，减少超长代码，减少近似冗余代码\n\n#### 13） 使用懒加载\n[好的代码习惯](http://www.reviewcode.cn/article.html?reviewId=10)\n\n \t[self initComps];\n    [self initToolbar];\n    [self initVertical];\n    [self initImageView];\n    [self initMediaPick];\n    [self setupSpeechRecognizer];\n    [self initAttributedString];\n    [self initTextView];\n\n这样的代码，推荐使用懒加载\n\n>懒加载带来的收益：我们不再需要显式的生成和调用initAttributedString方法，只需要在使用的时候调用属性self.attrString，对象的实例化全部放在getter中，可以有效降低代码的耦合度;在使用属性之前，属性并不会提前生成，减少内存占用。\n\n#### 13）delegate校验参数\n[好的代码习惯](http://www.reviewcode.cn/article.html?reviewId=10)\n\n\t- (void)textViewDidEndEditing:(YYTextView *)textView {\n\t    if (textView == self.textView) {\n\t        self.navigationItem.rightBarButtonItem = nil;\n\t    }\n\t}\n\t\n>如果你的delegate方法，只作为一个textView的委托回调，这种写法没有任何。但是如果你想扩展你的界面，在将来的界面中很可能出现另一个textView，这时你就必须区分这两个textView是谁回调了这个代理方法\n\n### 四. 项目配置\n\n#### 1）目录结构\n[话谈iOS目录结构的划分](http://www.reviewcode.cn/article.html?reviewId=9)\n\n提到了MVC结构，以及MVC结构下如何划分目录结构\n\n>往往业界有两种做法：\n\n>先按业务划分，再按照 MVC 来划分\n\n>先按 MVC 划分，再按照业务划分\n\n>第一种的好处是把相应业务的代码放在一起，找特别好找，相应的 xib、model 和 ViewController 全在一个地方。在这些代码之间跳转特别方便。Telegram 非常大的代码量，也是这么组织的。个人觉得如果代码量特别大，这种划分方式其实更好，先按照业务划分了，更容易分工合作。\n\n>第二种似乎更多人用。Yep 也是按照这样的方式组织。\n\n>其实我觉得都可以，看个人习惯。\n\nPS:我表示，我可能更习惯`先按业务模块划分，再MVC`\n\n#### 2）合理高效的开发环境\n[如何打造令人愉悦的开发环境](http://www.reviewcode.cn/article.html?reviewId=1)\n\n这个案例里面详尽探讨了一个观点 `一个合理高效的开发环境应该是依托于自动化之上的.`\n\n自动化应当包含以下几个方面:\n- 代码风格检查\n- 自动化测试\n- 持续集成\n- 常用库的封装和打包\n\n#### 3）第三方库管理\n[如何打造令人愉悦的开发环境](http://www.reviewcode.cn/article.html?reviewId=1)\n[要你命三千：老代码中的那些坑](http://www.reviewcode.cn/article.html?reviewId=3)\n\n- 各种第三方库推荐使用cocoapods管理，提高效率\n- 项目勤用三方库，随意穿插改无数。 即使类库有更新，试问代码谁维护\n\n#### 4) 自动打包配置\n[iOS下如何自动化打包App](http://www.reviewcode.cn/article.html?reviewId=11)\n\n- 自动化的全面配置打包平台的一个方案\n\n\n\n### 持续更新\ncodeReview应该持续进行下去，这个总结也应该持续进行。\n\n扔到Git上吧，[iOSCodeReviewTipsCollection](https://github.com/Awhisper/iOSCodeReviewTipsCollection)，（╮(╯_╰)╭ 又TM是广告)","slug":"技术/2016-2-29-reviewcode","published":1,"updated":"2016-04-09T13:57:16.000Z","comments":1,"photos":[],"link":"","_id":"cisw1ptry000vyrnt4dlp7wwg","content":"<blockquote>\n<p>原文来自简书：<a href=\"http://www.jianshu.com/p/ae1090183fa8?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=writer_share&amp;utm_source=weibo\" target=\"_blank\" rel=\"external\">reviewcode.cn 平台部分案例整理</a></p>\n</blockquote>\n<p>我是大神们的搬运工</p>\n<h2 id=\"彦祖大神的codeReview平台\"><a href=\"#彦祖大神的codeReview平台\" class=\"headerlink\" title=\"彦祖大神的codeReview平台\"></a>彦祖大神的codeReview平台</h2><p>@叶孤城___ 大神搞了一个提供邀请业内大神付费为你的项目进行CodeReview的平台，产出一份高质量的review报告。<a href=\"www.reviewcode.cn\">www.reviewcode.cn</a></p>\n<h2 id=\"平台案例整理\"><a href=\"#平台案例整理\" class=\"headerlink\" title=\"平台案例整理\"></a>平台案例整理</h2><p>可能不见得每个人都要把自己所有的项目，扔到平台上让大神们review，但是我们可以进行归纳总结，在那些大神们的<code>高质量review报告</code>中，归纳和总结我们自己需要的，汲取养分。</p>\n<p>更何况这些总结，每一个都包含着真实的代码案例，优化方案，以及原因详解，比我们每天看设计模式那些抽象的理念，名词，要接地气的多</p>\n<p>我不是大神，我只是大神的搬运工</p>\n<p>(农夫山泉的广告词…咳…装X了…跑题了…)</p>\n<p>目前CodeReview平台上已经有了超级详尽的10篇review报告，每一个都是实打实的干活，所以我就搬运一下，把他们case by case 的review报告，梳理归类一下，换个形式进行总结和学习</p>\n<h3 id=\"为什么要做CodeReview？\"><a href=\"#为什么要做CodeReview？\" class=\"headerlink\" title=\"为什么要做CodeReview？\"></a>为什么要做CodeReview？</h3><p>引用大神在网站中的一句话</p>\n<blockquote>\n<p>因为 Code Review 是一种最快捷有效的方式让你清楚地知道“好的代码是怎样写出的”。不知道你们有没有这样的经历。</p>\n<p>知道如何完成一个功能，或者完成一个组件。但是碰到稍微复杂的逻辑和业务，就会很容易的让代码变得一团糟。书中常常提及的解耦、分拆复杂逻辑都似乎变成了纸上谈兵，无从下手。又或者，总觉得自己的代码哪里不对劲，和高手们写的简洁、易懂、风格优雅的代码总是有似乎逾越不了的鸿沟。</p>\n</blockquote>\n<p>我个人是觉得，代码能力的培养，代码质量的提升，不仅仅是我又学到了什么新技术，掌握了什么nb的黑科技。</p>\n<p>更离不开对自己写出的每一句代码的反复challenge，小到命名规范，数字常量，大到模块设计，项目结构，无处不存在着可以不断优化和提升的细节。</p>\n<p>看看行业的高手大神们是怎么思考和写码的，看看他们在跟你思考一模一样的问题的时候，他们视野他们的角度，学习，汲取，不断地提升自己</p>\n<blockquote>\n<p>观一叶而知秋，道不远人即为此</p>\n</blockquote>\n<p>代码的<code>道</code>，其实就在这些点点滴滴的细节所汇聚而成的<code>艺术品</code>里（咳…装X了…跑题了…）</p>\n<h3 id=\"一-命名规范\"><a href=\"#一-命名规范\" class=\"headerlink\" title=\"一. 命名规范\"></a>一. 命名规范</h3><p>在10篇review报告中有3篇提到了命名规范这个事情</p>\n<ul>\n<li><a href=\"http://www.reviewcode.cn/article.html?reviewId=8\" target=\"_blank\" rel=\"external\">一些代码建议</a></li>\n<li><a href=\"http://www.reviewcode.cn/article.html?reviewId=3\" target=\"_blank\" rel=\"external\">要你命三千：老代码中的那些坑</a></li>\n<li><a href=\"http://www.reviewcode.cn/article.html?reviewId=2\" target=\"_blank\" rel=\"external\">命名的艺术</a></li>\n</ul>\n<p>其实关于命名规范，有很多现成的方法论和规范了，各种语言，对于类，函数，变量，等等，一查都能查到很多。我觉得这里面最重要的意义是让你写出的东西别人好读，好认，不要靠猜。</p>\n<p>大神们给出了很多建议</p>\n<ul>\n<li>前缀：建议所有类名、enum 定义、typedef 类型定义，都加上前缀（prefix）</li>\n<li>拼写错误：不用多说了</li>\n<li>命名规范：建议尽可能统一，就算多人团队合作，在开发中统一一下习惯总是好的。<ul>\n<li>比如到底是_分割还是驼峰大小写分割单词？（建议驼峰）</li>\n<li>是否对返回值的类型描述写入函数名，方法名里面？（建议写像苹果系统Api）</li>\n</ul>\n</li>\n</ul>\n<p><a href=\"http://www.reviewcode.cn/article.html?reviewId=2\" target=\"_blank\" rel=\"external\">命名的艺术</a>这篇报告更是着重的对命名规范从四个方向进行了很深入的剖析</p>\n<ul>\n<li>变量的命名</li>\n<li>代理的命名</li>\n<li>图片资源的命名</li>\n<li>方法的命名</li>\n</ul>\n<h3 id=\"二-编码细节\"><a href=\"#二-编码细节\" class=\"headerlink\" title=\"二.编码细节\"></a>二.编码细节</h3><p>写代码的时候，有时候很细微的一行代码，稍加变化，稍加处理，可能就会有很多性能，可读性，扩展性等得提升，在10篇review报告中，有太多这样高质量的编码细节干活。</p>\n<h4 id=\"1）数字与常量\"><a href=\"#1）数字与常量\" class=\"headerlink\" title=\"1）数字与常量\"></a>1）数字与常量</h4><ul>\n<li><a href=\"http://www.reviewcode.cn/article.html?reviewId=3\" target=\"_blank\" rel=\"external\">要你命三千：老代码中的那些坑</a></li>\n<li><a href=\"http://www.reviewcode.cn/article.html?reviewId=7\" target=\"_blank\" rel=\"external\">关于性能的一些问题</a></li>\n<li><a href=\"http://www.reviewcode.cn/article.html?reviewId=10\" target=\"_blank\" rel=\"external\">好的代码习惯</a></li>\n<li><a href=\"http://www.reviewcode.cn/article.html?reviewId=4\" target=\"_blank\" rel=\"external\">一些优化代码结构的方法</a></li>\n</ul>\n<p>都提到了<code>数字</code>，比如</p>\n<p># </p>\n<pre><code>UILabel *infoLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 241, 320, 28)];\n</code></pre><p>这个还算好的，再看看这个</p>\n<pre><code>CGRect rect = CGRectMake(12.2+(page-1)*320+42.5*(i%7),((totalRows-1)%3)*55+2,42.5,42.5);\n</code></pre><p>大神们建议这么使用</p>\n<pre><code>static const CGFloat kTagHeight = 30.0f;\nstatic const CGFloat kTagLabelWidthInset = 16.0f;\n</code></pre><p>另外，不建议用宏，具体有兴趣大家可以看简书的这个帖子 ，<a href=\"http://www.jianshu.com/p/c941e37a8a1d\" target=\"_blank\" rel=\"external\">iOS中关于宏定义与常量的使用</a>，简单的说就是宏会增加编译速度</p>\n<p>同理一些字符串<code>常量</code>等，都建议使用 这样的定义</p>\n<pre><code>static NSString *const kcircleModelDataCategoryName = @&quot;categoryName&quot;;\n</code></pre><h4 id=\"2）监听通知的位置\"><a href=\"#2）监听通知的位置\" class=\"headerlink\" title=\"2）监听通知的位置\"></a>2）监听通知的位置</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=4\" target=\"_blank\" rel=\"external\">一些优化代码结构的方法</a></p>\n<blockquote>\n<p>有人在willAppear和Disappear中添加通知，这样极容易出现问题。因为willAppear和Disappear出现的顺序并不一定是一对一的。所以有可能造成多次添加，多次移除通知。</p>\n</blockquote>\n<p>大神们建议这么使用</p>\n<blockquote>\n<p>建议在viewDidLoad里添加通知。在dealloc里移除通知。</p>\n</blockquote>\n<h4 id=\"3）-私有成员-or-Property\"><a href=\"#3）-私有成员-or-Property\" class=\"headerlink\" title=\"3） 私有成员 or Property\"></a>3） 私有成员 or Property</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=9\" target=\"_blank\" rel=\"external\">话谈 iOS 目录结构的划分</a>中提到的一个问题</p>\n<pre><code>@interface PartyViewController ()\n\n@property (weak, nonatomic) IBOutlet UITableView *partyTableView;\n@property (strong,nonatomic) NSMutableArray *partys;\n@end\n\n@implementation PartyViewController{\n\n    NSMutableArray *lodedIndex;\n}\n</code></pre><p>到底该用哪一个？</p>\n<p>大婶们的建议是</p>\n<blockquote>\n<p>无论如何，应该一致，应该统一风格。建议这里用 property 。因为 @IBOutlet ，从 IB 拖出来的属性用的就是 property ，所以统一用 property 较好。</p>\n</blockquote>\n<p>关于这个，其实在开发中有一定的争议的，有兴趣的可以看一下唐巧老师的这篇文章，<a href=\"http://blog.devtang.com/2015/03/15/ios-dev-controversy-1/\" target=\"_blank\" rel=\"external\">开发中得争议</a></p>\n<h4 id=\"4）-typedef-block\"><a href=\"#4）-typedef-block\" class=\"headerlink\" title=\"4） typedef block\"></a>4） typedef block</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=9\" target=\"_blank\" rel=\"external\">话谈 iOS 目录结构的划分</a> 提到代码中多次使用的block，诸如<code>(void (^)(NSError *error))</code>等，可以统一进行声明，不要每次都手打完整block定义</p>\n<p>好处是</p>\n<blockquote>\n<p>还可以用上 Xcode 的自动补全功能，当你输入 Fa 的时候， FailureBlock 的提示就出来了。用 (void (^)(NSError *error)) 就没有自动补全了，每次都要手工输入一遍，很麻烦</p>\n</blockquote>\n<h4 id=\"5）-数字类型\"><a href=\"#5）-数字类型\" class=\"headerlink\" title=\"5） 数字类型\"></a>5） 数字类型</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=9\" target=\"_blank\" rel=\"external\">话谈 iOS 目录结构的划分</a>中提到了3个问题</p>\n<ul>\n<li>用 int 还是 NSInteger</li>\n<li>尺寸变量统一用 CGFloat</li>\n<li>选用正确的类型，让编译器能静态检查</li>\n</ul>\n<p>第一个问题</p>\n<blockquote>\n<p>可以注意到 apple 的 UIKit 等代码一般都是用的 NSInteger。NSInteger 在 32位系统是 int ，64位系统是 long 。Apple 把它用在函数的参数处，和返回的地方。为什么？因为函数是需要跟其它代码或其它平台的代码交流互动的，所以是 int 还是 long 很重要。系统的代码用的是 NSInteger 的话，你的用了 int 的话，可能不够大而造成崩溃。</p>\n</blockquote>\n<p>还是建议NSInteger</p>\n<p>第二个问题 </p>\n<blockquote>\n<p>一开始看到 <code>int padding = 1</code> 后，不知道它是干嘛的。因为附近没有它的代码，看到后面才知道的。所以声明类型为 CGFloat ，更容易知道它是来定义尺寸距离的。</p>\n</blockquote>\n<p>为什么建议这样，CG开头是CoreGraphic的简写，我们开发也会发现CGFloat 是需要 import <code>UIKit</code>的，从名字定义上，他是与现实UI有关的</p>\n<p>第三个问题</p>\n<p>具体可以看链接里的案例</p>\n<p>简单的说就是，很多NSInterger等数值属性，不要把他定义成NSNumber，因为编译器在发现你对integer变量赋值float变量的时候会自动报错，是一个自动纠错的功能，如果定义成了NSNumber，用语法糖@（float）去转换，就不能自动纠错了</p>\n<h4 id=\"6）属性修饰符建议\"><a href=\"#6）属性修饰符建议\" class=\"headerlink\" title=\"6）属性修饰符建议\"></a>6）属性修饰符建议</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=10\" target=\"_blank\" rel=\"external\">好的代码习惯</a></p>\n<blockquote>\n<p>在arc中，弱引用最好使用weak，来避免野指针的出现，weak可以在指向的对象dealloc的时候自动置为nil。</p>\n<p>在arc中强引用尽量使用strong，当然这里strong和retain的作用是一样的，但是为了保持代码的一致性，这里推荐使用strong。</p>\n</blockquote>\n<p>具体可以看链接中得案例</p>\n<h4 id=\"7）-字面量语法\"><a href=\"#7）-字面量语法\" class=\"headerlink\" title=\"7） 字面量语法\"></a>7） 字面量语法</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=10\" target=\"_blank\" rel=\"external\">好的代码习惯</a></p>\n<pre><code>_comps.items = [NSArray arrayWithObjects:_photoBarButton, _mediaBarButton, _alarmBarButton, _brushBarButton, _voiceBarButton, _doneBarButton, nil];\n</code></pre><p>字面量语法</p>\n<pre><code>_comps.items = @[_photoBarButton, _mediaBarButton, _alarmBarButton, _brushBarButton, _voiceBarButton, _doneBarButton];\n</code></pre><blockquote>\n<p>这种做法不仅简单，还更加安全。假如当中的_alarmBarButton为nil，那么通过第一种写法，数组还是会创建出来，只不过数组内只有2个对象，原因在于，“arrayWithObjects:”方法会依次处理各个参数，直到发现nil为止，而第二种写法会在插入nil指针的时候抛出异常，令程序终止运行，这比创建好数组后才发现数组内的元素个数少了要好很多。异常往往能更快地发现错误。</p>\n</blockquote>\n<h3 id=\"三-设计思路\"><a href=\"#三-设计思路\" class=\"headerlink\" title=\"三.设计思路\"></a>三.设计思路</h3><h4 id=\"1）公有私有混乱\"><a href=\"#1）公有私有混乱\" class=\"headerlink\" title=\"1）公有私有混乱\"></a>1）公有私有混乱</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=3\" target=\"_blank\" rel=\"external\">要你命三千：老代码中的那些坑</a></p>\n<p>具体案例可以看Link中得细节，大致思路是尽可能的减少接口在头文件中所暴露出来的属性和方法，头文件要尽可能的简洁</p>\n<p>如果有可能也尽量避免，一个头文件中出现多个类声明</p>\n<blockquote>\n<p>头文件里地方小，塞到一处并不好。 外部对象都知道，安全问题可不小</p>\n</blockquote>\n<h4 id=\"2）消息通知满天飞\"><a href=\"#2）消息通知满天飞\" class=\"headerlink\" title=\"2）消息通知满天飞\"></a>2）消息通知满天飞</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=3\" target=\"_blank\" rel=\"external\">要你命三千：老代码中的那些坑</a></p>\n<p>通知虽好，但也不要贪杯啊。</p>\n<blockquote>\n<p>看起来轻松，只是 post 了一下就搞定了，但是在 Debug 的时候有点麻烦。尤其是如果有多个 Observer ，改动的时候牵一发而动全身。如果真的是有这样使用的必要倒也罢了，但是本来一个 block 或者 delegate 就能简单清晰的解决，现在却被搞得这么繁重，实在是没有必要。</p>\n</blockquote>\n<p>我觉得明确使用通知的场景，在不需要一对多的情况下，路径不算远的2个模块，完全可以通过delegate，或者block解决</p>\n<h4 id=\"3）单个对象多职责\"><a href=\"#3）单个对象多职责\" class=\"headerlink\" title=\"3）单个对象多职责\"></a>3）单个对象多职责</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=3\" target=\"_blank\" rel=\"external\">要你命三千：老代码中的那些坑</a></p>\n<p>同一个一个模块</p>\n<ul>\n<li>上能和服务器聊天，上传聊天消息同步聊天记录</li>\n<li>下能做本地缓存管理，增删改查样样精通</li>\n<li>弹窗提醒，上传进度，完成提示，亦是轻松拿下。</li>\n<li>以至于你改着改着不知不觉都会走到这里，因为它处理了太多太多的业务逻辑，每次 DEBUG 追杀断点回到这里，都像是一场久别重逢时的相遇，似曾相识</li>\n</ul>\n<blockquote>\n<p>一人做事一人当，切忌都往类里装。 开发人员干的爽，维护人员很受伤。</p>\n</blockquote>\n<h4 id=\"4）盲目新增功能\"><a href=\"#4）盲目新增功能\" class=\"headerlink\" title=\"4）盲目新增功能\"></a>4）盲目新增功能</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=3\" target=\"_blank\" rel=\"external\">要你命三千：老代码中的那些坑</a></p>\n<p>具体案例可以看Link中的细节，简单描述下就是，随着项目的迭代，一个小功能点，多一个标记位，再来一个小功能点，又多一个标记位，随着业务迭代下去，标记位越来越多，如果这里面涉及到逻辑上的关联，一单有个标记位得特殊处理一下，那N个<code>if</code>嵌套的场景，简直是<code>画美不看</code></p>\n<p>新增的业务需求，还是要经常和老功能进行梳理和总结，该合并该梳理的都要重新和老代码里一起整合，切记直接拍脑袋上手直接添加功能</p>\n<h4 id=\"5）滥用委托\"><a href=\"#5）滥用委托\" class=\"headerlink\" title=\"5）滥用委托\"></a>5）滥用委托</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=3\" target=\"_blank\" rel=\"external\">要你命三千：老代码中的那些坑</a></p>\n<p><a href=\"http://www.reviewcode.cn/article.html?reviewId=5\" target=\"_blank\" rel=\"external\">封装一个UI控件的范例</a></p>\n<p>都提到了在处理回调的时候，委托或者block的2个方式的对比</p>\n<blockquote>\n<p>所谓悲哀就是，当程序员发现一个 delegate 就能访问上级的对象，于是便把各种需要通知上级的事情都放在了委托方法里，尽管这些事情与委托本身无关，但是为了实现功能已经不在意这些所谓的设计与美观</p>\n<p>可以考虑用block来传递数据源和响应事件，这样封装的view在代码的连贯性上更好一些</p>\n</blockquote>\n<p>简单的说结合具体案例，恰当的采用委托或者block来实现</p>\n<h4 id=\"6）静态DataSource\"><a href=\"#6）静态DataSource\" class=\"headerlink\" title=\"6）静态DataSource\"></a>6）静态DataSource</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=4\" target=\"_blank\" rel=\"external\">一些优化代码结构的方法</a></p>\n<p>开发中难免会遇到很多静态的几乎很少变化的tableView界面</p>\n<p>图省事的人直接在代码里 switchCase  一行行的硬编码，写死了整个tableview的界面</p>\n<p>还是推荐使用plist，用代码从数据源中读取数据，从而进行展示</p>\n<blockquote>\n<p>这样，后续迭代版本的内容只需要修改plist文件的内容就可以了。而不需要在代码中修改逻辑。</p>\n</blockquote>\n<h4 id=\"7）使用orm\"><a href=\"#7）使用orm\" class=\"headerlink\" title=\"7）使用orm\"></a>7）使用orm</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=4\" target=\"_blank\" rel=\"external\">一些优化代码结构的方法</a></p>\n<p>很多人都是这么做的</p>\n<p>不要在解析网络等数据的时候，手写解析过程，采用<code>mantle</code>or<code>JsonModel</code>等框架来做这些事情</p>\n<h4 id=\"8）构建易于测试的模块\"><a href=\"#8）构建易于测试的模块\" class=\"headerlink\" title=\"8）构建易于测试的模块\"></a>8）构建易于测试的模块</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=4\" target=\"_blank\" rel=\"external\">一些优化代码结构的方法</a><br><a href=\"http://www.reviewcode.cn/article.html?reviewId=1\" target=\"_blank\" rel=\"external\">如何打造令人愉悦的开发环境</a></p>\n<p>都提到了，尽量在开发中设计易于测试的模块。<br>众多功能杂糅在一个类里面是不利于测试的，写一个超大函数，干了很多功能也是不利于编写自动化测试的<br>后面还会提到，随着项目的逐渐扩大，保持至健壮的自动化测试+持续集成，才是一个健康的项目结构</p>\n<h4 id=\"9）不要想当然的使用tableView\"><a href=\"#9）不要想当然的使用tableView\" class=\"headerlink\" title=\"9）不要想当然的使用tableView\"></a>9）不要想当然的使用tableView</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=6\" target=\"_blank\" rel=\"external\">不要想当然的使用tableView</a></p>\n<ul>\n<li>不要试图过分的复用一个TableViewController</li>\n<li>一定要复用的场景<ul>\n<li>用switch来区分场景，用不同的tableview进行处理</li>\n<li>将数据源的判断逻辑，不同的tableview类给自己处理自己的<code>delegate</code> or <code>datasource</code></li>\n<li>这样多路复用的选择其实就发生在了返回tableView的操作里，可以避免在控制器中出现臃肿的代码</li>\n</ul>\n</li>\n<li>不要试图滥用Cell的重用机制</li>\n</ul>\n<h4 id=\"10）圆角\"><a href=\"#10）圆角\" class=\"headerlink\" title=\"10）圆角\"></a>10）圆角</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=7\" target=\"_blank\" rel=\"external\">关于性能的一些问题</a></p>\n<p>详细可以看关于离屏渲染的Link中的介绍，<br>也可以看另一位大神ibireme对渲染流畅的文章，<a href=\"http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/\" target=\"_blank\" rel=\"external\">iOS 保持界面流畅的技巧</a></p>\n<p>简单的说就是<code>CALayer</code>的<code>圆角</code>和<code>阴影</code>，当出现在大量的cell之中，会进项很多的离屏渲染，这样就会大幅度拖慢FPS</p>\n<p>如何解决？</p>\n<blockquote>\n<p>圆角使用UIImageView来处理。<br>简单来说，底层铺一个UIImageView,然后用GraphicsContext生成一张带圆角的图。</p>\n</blockquote>\n<h4 id=\"11-App沙盒数据存储目录\"><a href=\"#11-App沙盒数据存储目录\" class=\"headerlink\" title=\"11) App沙盒数据存储目录\"></a>11) App沙盒数据存储目录</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=8\" target=\"_blank\" rel=\"external\">一些代码建议</a></p>\n<blockquote>\n<p>数据存储应该再谨慎一些，至少用户数据可以放在 Documents 文件夹下某个子目录里，而不应该直接丢到 Documents 文件夹下，清空时也不应该清空整个 Documents 文件夹。</p>\n</blockquote>\n<p>PS:顺带我想说，如果app配置了itunes查看Documents的功能，apple审核的时候会查看documents目录，一些非用户可感知的数据，程序生成的数据，存放在Doc目录下，可能会被苹果拒审</p>\n<h4 id=\"12）-即时抽取函数\"><a href=\"#12）-即时抽取函数\" class=\"headerlink\" title=\"12） 即时抽取函数\"></a>12） 即时抽取函数</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=9\" target=\"_blank\" rel=\"external\">话谈 iOS 目录结构的划分</a></p>\n<p>可以细看Link中的案例</p>\n<p>简单描述就是，随着业务的不断增长，有时候会出现超长的函数，有时候会有相似代码，被写出来，适当的即时抽取函数，减少超长代码，减少近似冗余代码</p>\n<h4 id=\"13）-使用懒加载\"><a href=\"#13）-使用懒加载\" class=\"headerlink\" title=\"13） 使用懒加载\"></a>13） 使用懒加载</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=10\" target=\"_blank\" rel=\"external\">好的代码习惯</a></p>\n<pre><code> [self initComps];\n[self initToolbar];\n[self initVertical];\n[self initImageView];\n[self initMediaPick];\n[self setupSpeechRecognizer];\n[self initAttributedString];\n[self initTextView];\n</code></pre><p>这样的代码，推荐使用懒加载</p>\n<blockquote>\n<p>懒加载带来的收益：我们不再需要显式的生成和调用initAttributedString方法，只需要在使用的时候调用属性self.attrString，对象的实例化全部放在getter中，可以有效降低代码的耦合度;在使用属性之前，属性并不会提前生成，减少内存占用。</p>\n</blockquote>\n<h4 id=\"13）delegate校验参数\"><a href=\"#13）delegate校验参数\" class=\"headerlink\" title=\"13）delegate校验参数\"></a>13）delegate校验参数</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=10\" target=\"_blank\" rel=\"external\">好的代码习惯</a></p>\n<pre><code>- (void)textViewDidEndEditing:(YYTextView *)textView {\n    if (textView == self.textView) {\n        self.navigationItem.rightBarButtonItem = nil;\n    }\n}\n</code></pre><blockquote>\n<p>如果你的delegate方法，只作为一个textView的委托回调，这种写法没有任何。但是如果你想扩展你的界面，在将来的界面中很可能出现另一个textView，这时你就必须区分这两个textView是谁回调了这个代理方法</p>\n</blockquote>\n<h3 id=\"四-项目配置\"><a href=\"#四-项目配置\" class=\"headerlink\" title=\"四. 项目配置\"></a>四. 项目配置</h3><h4 id=\"1）目录结构\"><a href=\"#1）目录结构\" class=\"headerlink\" title=\"1）目录结构\"></a>1）目录结构</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=9\" target=\"_blank\" rel=\"external\">话谈iOS目录结构的划分</a></p>\n<p>提到了MVC结构，以及MVC结构下如何划分目录结构</p>\n<blockquote>\n<p>往往业界有两种做法：</p>\n<p>先按业务划分，再按照 MVC 来划分</p>\n<p>先按 MVC 划分，再按照业务划分</p>\n<p>第一种的好处是把相应业务的代码放在一起，找特别好找，相应的 xib、model 和 ViewController 全在一个地方。在这些代码之间跳转特别方便。Telegram 非常大的代码量，也是这么组织的。个人觉得如果代码量特别大，这种划分方式其实更好，先按照业务划分了，更容易分工合作。</p>\n<p>第二种似乎更多人用。Yep 也是按照这样的方式组织。</p>\n<p>其实我觉得都可以，看个人习惯。</p>\n</blockquote>\n<p>PS:我表示，我可能更习惯<code>先按业务模块划分，再MVC</code></p>\n<h4 id=\"2）合理高效的开发环境\"><a href=\"#2）合理高效的开发环境\" class=\"headerlink\" title=\"2）合理高效的开发环境\"></a>2）合理高效的开发环境</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=1\" target=\"_blank\" rel=\"external\">如何打造令人愉悦的开发环境</a></p>\n<p>这个案例里面详尽探讨了一个观点 <code>一个合理高效的开发环境应该是依托于自动化之上的.</code></p>\n<p>自动化应当包含以下几个方面:</p>\n<ul>\n<li>代码风格检查</li>\n<li>自动化测试</li>\n<li>持续集成</li>\n<li>常用库的封装和打包</li>\n</ul>\n<h4 id=\"3）第三方库管理\"><a href=\"#3）第三方库管理\" class=\"headerlink\" title=\"3）第三方库管理\"></a>3）第三方库管理</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=1\" target=\"_blank\" rel=\"external\">如何打造令人愉悦的开发环境</a><br><a href=\"http://www.reviewcode.cn/article.html?reviewId=3\" target=\"_blank\" rel=\"external\">要你命三千：老代码中的那些坑</a></p>\n<ul>\n<li>各种第三方库推荐使用cocoapods管理，提高效率</li>\n<li>项目勤用三方库，随意穿插改无数。 即使类库有更新，试问代码谁维护</li>\n</ul>\n<h4 id=\"4-自动打包配置\"><a href=\"#4-自动打包配置\" class=\"headerlink\" title=\"4) 自动打包配置\"></a>4) 自动打包配置</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=11\" target=\"_blank\" rel=\"external\">iOS下如何自动化打包App</a></p>\n<ul>\n<li>自动化的全面配置打包平台的一个方案</li>\n</ul>\n<h3 id=\"持续更新\"><a href=\"#持续更新\" class=\"headerlink\" title=\"持续更新\"></a>持续更新</h3><p>codeReview应该持续进行下去，这个总结也应该持续进行。</p>\n<p>扔到Git上吧，<a href=\"https://github.com/Awhisper/iOSCodeReviewTipsCollection\" target=\"_blank\" rel=\"external\">iOSCodeReviewTipsCollection</a>，（╮(╯_╰)╭ 又TM是广告)</p>\n","more":"<blockquote>\n<p>原文来自简书：<a href=\"http://www.jianshu.com/p/ae1090183fa8?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=writer_share&amp;utm_source=weibo\">reviewcode.cn 平台部分案例整理</a></p>\n</blockquote>\n<p>我是大神们的搬运工</p>\n<h2 id=\"彦祖大神的codeReview平台\"><a href=\"#彦祖大神的codeReview平台\" class=\"headerlink\" title=\"彦祖大神的codeReview平台\"></a>彦祖大神的codeReview平台</h2><p>@叶孤城___ 大神搞了一个提供邀请业内大神付费为你的项目进行CodeReview的平台，产出一份高质量的review报告。<a href=\"www.reviewcode.cn\">www.reviewcode.cn</a></p>\n<h2 id=\"平台案例整理\"><a href=\"#平台案例整理\" class=\"headerlink\" title=\"平台案例整理\"></a>平台案例整理</h2><p>可能不见得每个人都要把自己所有的项目，扔到平台上让大神们review，但是我们可以进行归纳总结，在那些大神们的<code>高质量review报告</code>中，归纳和总结我们自己需要的，汲取养分。</p>\n<p>更何况这些总结，每一个都包含着真实的代码案例，优化方案，以及原因详解，比我们每天看设计模式那些抽象的理念，名词，要接地气的多</p>\n<p>我不是大神，我只是大神的搬运工</p>\n<p>(农夫山泉的广告词…咳…装X了…跑题了…)</p>\n<p>目前CodeReview平台上已经有了超级详尽的10篇review报告，每一个都是实打实的干活，所以我就搬运一下，把他们case by case 的review报告，梳理归类一下，换个形式进行总结和学习</p>\n<h3 id=\"为什么要做CodeReview？\"><a href=\"#为什么要做CodeReview？\" class=\"headerlink\" title=\"为什么要做CodeReview？\"></a>为什么要做CodeReview？</h3><p>引用大神在网站中的一句话</p>\n<blockquote>\n<p>因为 Code Review 是一种最快捷有效的方式让你清楚地知道“好的代码是怎样写出的”。不知道你们有没有这样的经历。</p>\n<p>知道如何完成一个功能，或者完成一个组件。但是碰到稍微复杂的逻辑和业务，就会很容易的让代码变得一团糟。书中常常提及的解耦、分拆复杂逻辑都似乎变成了纸上谈兵，无从下手。又或者，总觉得自己的代码哪里不对劲，和高手们写的简洁、易懂、风格优雅的代码总是有似乎逾越不了的鸿沟。</p>\n</blockquote>\n<p>我个人是觉得，代码能力的培养，代码质量的提升，不仅仅是我又学到了什么新技术，掌握了什么nb的黑科技。</p>\n<p>更离不开对自己写出的每一句代码的反复challenge，小到命名规范，数字常量，大到模块设计，项目结构，无处不存在着可以不断优化和提升的细节。</p>\n<p>看看行业的高手大神们是怎么思考和写码的，看看他们在跟你思考一模一样的问题的时候，他们视野他们的角度，学习，汲取，不断地提升自己</p>\n<blockquote>\n<p>观一叶而知秋，道不远人即为此</p>\n</blockquote>\n<p>代码的<code>道</code>，其实就在这些点点滴滴的细节所汇聚而成的<code>艺术品</code>里（咳…装X了…跑题了…）</p>\n<h3 id=\"一-命名规范\"><a href=\"#一-命名规范\" class=\"headerlink\" title=\"一. 命名规范\"></a>一. 命名规范</h3><p>在10篇review报告中有3篇提到了命名规范这个事情</p>\n<ul>\n<li><a href=\"http://www.reviewcode.cn/article.html?reviewId=8\">一些代码建议</a></li>\n<li><a href=\"http://www.reviewcode.cn/article.html?reviewId=3\">要你命三千：老代码中的那些坑</a></li>\n<li><a href=\"http://www.reviewcode.cn/article.html?reviewId=2\">命名的艺术</a></li>\n</ul>\n<p>其实关于命名规范，有很多现成的方法论和规范了，各种语言，对于类，函数，变量，等等，一查都能查到很多。我觉得这里面最重要的意义是让你写出的东西别人好读，好认，不要靠猜。</p>\n<p>大神们给出了很多建议</p>\n<ul>\n<li>前缀：建议所有类名、enum 定义、typedef 类型定义，都加上前缀（prefix）</li>\n<li>拼写错误：不用多说了</li>\n<li>命名规范：建议尽可能统一，就算多人团队合作，在开发中统一一下习惯总是好的。<ul>\n<li>比如到底是_分割还是驼峰大小写分割单词？（建议驼峰）</li>\n<li>是否对返回值的类型描述写入函数名，方法名里面？（建议写像苹果系统Api）</li>\n</ul>\n</li>\n</ul>\n<p><a href=\"http://www.reviewcode.cn/article.html?reviewId=2\">命名的艺术</a>这篇报告更是着重的对命名规范从四个方向进行了很深入的剖析</p>\n<ul>\n<li>变量的命名</li>\n<li>代理的命名</li>\n<li>图片资源的命名</li>\n<li>方法的命名</li>\n</ul>\n<h3 id=\"二-编码细节\"><a href=\"#二-编码细节\" class=\"headerlink\" title=\"二.编码细节\"></a>二.编码细节</h3><p>写代码的时候，有时候很细微的一行代码，稍加变化，稍加处理，可能就会有很多性能，可读性，扩展性等得提升，在10篇review报告中，有太多这样高质量的编码细节干活。</p>\n<h4 id=\"1）数字与常量\"><a href=\"#1）数字与常量\" class=\"headerlink\" title=\"1）数字与常量\"></a>1）数字与常量</h4><ul>\n<li><a href=\"http://www.reviewcode.cn/article.html?reviewId=3\">要你命三千：老代码中的那些坑</a></li>\n<li><a href=\"http://www.reviewcode.cn/article.html?reviewId=7\">关于性能的一些问题</a></li>\n<li><a href=\"http://www.reviewcode.cn/article.html?reviewId=10\">好的代码习惯</a></li>\n<li><a href=\"http://www.reviewcode.cn/article.html?reviewId=4\">一些优化代码结构的方法</a></li>\n</ul>\n<p>都提到了<code>数字</code>，比如</p>\n<p># </p>\n<pre><code>UILabel *infoLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 241, 320, 28)];\n</code></pre><p>这个还算好的，再看看这个</p>\n<pre><code>CGRect rect = CGRectMake(12.2+(page-1)*320+42.5*(i%7),((totalRows-1)%3)*55+2,42.5,42.5);\n</code></pre><p>大神们建议这么使用</p>\n<pre><code>static const CGFloat kTagHeight = 30.0f;\nstatic const CGFloat kTagLabelWidthInset = 16.0f;\n</code></pre><p>另外，不建议用宏，具体有兴趣大家可以看简书的这个帖子 ，<a href=\"http://www.jianshu.com/p/c941e37a8a1d\">iOS中关于宏定义与常量的使用</a>，简单的说就是宏会增加编译速度</p>\n<p>同理一些字符串<code>常量</code>等，都建议使用 这样的定义</p>\n<pre><code>static NSString *const kcircleModelDataCategoryName = @&quot;categoryName&quot;;\n</code></pre><h4 id=\"2）监听通知的位置\"><a href=\"#2）监听通知的位置\" class=\"headerlink\" title=\"2）监听通知的位置\"></a>2）监听通知的位置</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=4\">一些优化代码结构的方法</a></p>\n<blockquote>\n<p>有人在willAppear和Disappear中添加通知，这样极容易出现问题。因为willAppear和Disappear出现的顺序并不一定是一对一的。所以有可能造成多次添加，多次移除通知。</p>\n</blockquote>\n<p>大神们建议这么使用</p>\n<blockquote>\n<p>建议在viewDidLoad里添加通知。在dealloc里移除通知。</p>\n</blockquote>\n<h4 id=\"3）-私有成员-or-Property\"><a href=\"#3）-私有成员-or-Property\" class=\"headerlink\" title=\"3） 私有成员 or Property\"></a>3） 私有成员 or Property</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=9\">话谈 iOS 目录结构的划分</a>中提到的一个问题</p>\n<pre><code>@interface PartyViewController ()\n\n@property (weak, nonatomic) IBOutlet UITableView *partyTableView;\n@property (strong,nonatomic) NSMutableArray *partys;\n@end\n\n@implementation PartyViewController{\n\n    NSMutableArray *lodedIndex;\n}\n</code></pre><p>到底该用哪一个？</p>\n<p>大婶们的建议是</p>\n<blockquote>\n<p>无论如何，应该一致，应该统一风格。建议这里用 property 。因为 @IBOutlet ，从 IB 拖出来的属性用的就是 property ，所以统一用 property 较好。</p>\n</blockquote>\n<p>关于这个，其实在开发中有一定的争议的，有兴趣的可以看一下唐巧老师的这篇文章，<a href=\"http://blog.devtang.com/2015/03/15/ios-dev-controversy-1/\">开发中得争议</a></p>\n<h4 id=\"4）-typedef-block\"><a href=\"#4）-typedef-block\" class=\"headerlink\" title=\"4） typedef block\"></a>4） typedef block</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=9\">话谈 iOS 目录结构的划分</a> 提到代码中多次使用的block，诸如<code>(void (^)(NSError *error))</code>等，可以统一进行声明，不要每次都手打完整block定义</p>\n<p>好处是</p>\n<blockquote>\n<p>还可以用上 Xcode 的自动补全功能，当你输入 Fa 的时候， FailureBlock 的提示就出来了。用 (void (^)(NSError *error)) 就没有自动补全了，每次都要手工输入一遍，很麻烦</p>\n</blockquote>\n<h4 id=\"5）-数字类型\"><a href=\"#5）-数字类型\" class=\"headerlink\" title=\"5） 数字类型\"></a>5） 数字类型</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=9\">话谈 iOS 目录结构的划分</a>中提到了3个问题</p>\n<ul>\n<li>用 int 还是 NSInteger</li>\n<li>尺寸变量统一用 CGFloat</li>\n<li>选用正确的类型，让编译器能静态检查</li>\n</ul>\n<p>第一个问题</p>\n<blockquote>\n<p>可以注意到 apple 的 UIKit 等代码一般都是用的 NSInteger。NSInteger 在 32位系统是 int ，64位系统是 long 。Apple 把它用在函数的参数处，和返回的地方。为什么？因为函数是需要跟其它代码或其它平台的代码交流互动的，所以是 int 还是 long 很重要。系统的代码用的是 NSInteger 的话，你的用了 int 的话，可能不够大而造成崩溃。</p>\n</blockquote>\n<p>还是建议NSInteger</p>\n<p>第二个问题 </p>\n<blockquote>\n<p>一开始看到 <code>int padding = 1</code> 后，不知道它是干嘛的。因为附近没有它的代码，看到后面才知道的。所以声明类型为 CGFloat ，更容易知道它是来定义尺寸距离的。</p>\n</blockquote>\n<p>为什么建议这样，CG开头是CoreGraphic的简写，我们开发也会发现CGFloat 是需要 import <code>UIKit</code>的，从名字定义上，他是与现实UI有关的</p>\n<p>第三个问题</p>\n<p>具体可以看链接里的案例</p>\n<p>简单的说就是，很多NSInterger等数值属性，不要把他定义成NSNumber，因为编译器在发现你对integer变量赋值float变量的时候会自动报错，是一个自动纠错的功能，如果定义成了NSNumber，用语法糖@（float）去转换，就不能自动纠错了</p>\n<h4 id=\"6）属性修饰符建议\"><a href=\"#6）属性修饰符建议\" class=\"headerlink\" title=\"6）属性修饰符建议\"></a>6）属性修饰符建议</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=10\">好的代码习惯</a></p>\n<blockquote>\n<p>在arc中，弱引用最好使用weak，来避免野指针的出现，weak可以在指向的对象dealloc的时候自动置为nil。</p>\n<p>在arc中强引用尽量使用strong，当然这里strong和retain的作用是一样的，但是为了保持代码的一致性，这里推荐使用strong。</p>\n</blockquote>\n<p>具体可以看链接中得案例</p>\n<h4 id=\"7）-字面量语法\"><a href=\"#7）-字面量语法\" class=\"headerlink\" title=\"7） 字面量语法\"></a>7） 字面量语法</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=10\">好的代码习惯</a></p>\n<pre><code>_comps.items = [NSArray arrayWithObjects:_photoBarButton, _mediaBarButton, _alarmBarButton, _brushBarButton, _voiceBarButton, _doneBarButton, nil];\n</code></pre><p>字面量语法</p>\n<pre><code>_comps.items = @[_photoBarButton, _mediaBarButton, _alarmBarButton, _brushBarButton, _voiceBarButton, _doneBarButton];\n</code></pre><blockquote>\n<p>这种做法不仅简单，还更加安全。假如当中的_alarmBarButton为nil，那么通过第一种写法，数组还是会创建出来，只不过数组内只有2个对象，原因在于，“arrayWithObjects:”方法会依次处理各个参数，直到发现nil为止，而第二种写法会在插入nil指针的时候抛出异常，令程序终止运行，这比创建好数组后才发现数组内的元素个数少了要好很多。异常往往能更快地发现错误。</p>\n</blockquote>\n<h3 id=\"三-设计思路\"><a href=\"#三-设计思路\" class=\"headerlink\" title=\"三.设计思路\"></a>三.设计思路</h3><h4 id=\"1）公有私有混乱\"><a href=\"#1）公有私有混乱\" class=\"headerlink\" title=\"1）公有私有混乱\"></a>1）公有私有混乱</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=3\">要你命三千：老代码中的那些坑</a></p>\n<p>具体案例可以看Link中得细节，大致思路是尽可能的减少接口在头文件中所暴露出来的属性和方法，头文件要尽可能的简洁</p>\n<p>如果有可能也尽量避免，一个头文件中出现多个类声明</p>\n<blockquote>\n<p>头文件里地方小，塞到一处并不好。 外部对象都知道，安全问题可不小</p>\n</blockquote>\n<h4 id=\"2）消息通知满天飞\"><a href=\"#2）消息通知满天飞\" class=\"headerlink\" title=\"2）消息通知满天飞\"></a>2）消息通知满天飞</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=3\">要你命三千：老代码中的那些坑</a></p>\n<p>通知虽好，但也不要贪杯啊。</p>\n<blockquote>\n<p>看起来轻松，只是 post 了一下就搞定了，但是在 Debug 的时候有点麻烦。尤其是如果有多个 Observer ，改动的时候牵一发而动全身。如果真的是有这样使用的必要倒也罢了，但是本来一个 block 或者 delegate 就能简单清晰的解决，现在却被搞得这么繁重，实在是没有必要。</p>\n</blockquote>\n<p>我觉得明确使用通知的场景，在不需要一对多的情况下，路径不算远的2个模块，完全可以通过delegate，或者block解决</p>\n<h4 id=\"3）单个对象多职责\"><a href=\"#3）单个对象多职责\" class=\"headerlink\" title=\"3）单个对象多职责\"></a>3）单个对象多职责</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=3\">要你命三千：老代码中的那些坑</a></p>\n<p>同一个一个模块</p>\n<ul>\n<li>上能和服务器聊天，上传聊天消息同步聊天记录</li>\n<li>下能做本地缓存管理，增删改查样样精通</li>\n<li>弹窗提醒，上传进度，完成提示，亦是轻松拿下。</li>\n<li>以至于你改着改着不知不觉都会走到这里，因为它处理了太多太多的业务逻辑，每次 DEBUG 追杀断点回到这里，都像是一场久别重逢时的相遇，似曾相识</li>\n</ul>\n<blockquote>\n<p>一人做事一人当，切忌都往类里装。 开发人员干的爽，维护人员很受伤。</p>\n</blockquote>\n<h4 id=\"4）盲目新增功能\"><a href=\"#4）盲目新增功能\" class=\"headerlink\" title=\"4）盲目新增功能\"></a>4）盲目新增功能</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=3\">要你命三千：老代码中的那些坑</a></p>\n<p>具体案例可以看Link中的细节，简单描述下就是，随着项目的迭代，一个小功能点，多一个标记位，再来一个小功能点，又多一个标记位，随着业务迭代下去，标记位越来越多，如果这里面涉及到逻辑上的关联，一单有个标记位得特殊处理一下，那N个<code>if</code>嵌套的场景，简直是<code>画美不看</code></p>\n<p>新增的业务需求，还是要经常和老功能进行梳理和总结，该合并该梳理的都要重新和老代码里一起整合，切记直接拍脑袋上手直接添加功能</p>\n<h4 id=\"5）滥用委托\"><a href=\"#5）滥用委托\" class=\"headerlink\" title=\"5）滥用委托\"></a>5）滥用委托</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=3\">要你命三千：老代码中的那些坑</a></p>\n<p><a href=\"http://www.reviewcode.cn/article.html?reviewId=5\">封装一个UI控件的范例</a></p>\n<p>都提到了在处理回调的时候，委托或者block的2个方式的对比</p>\n<blockquote>\n<p>所谓悲哀就是，当程序员发现一个 delegate 就能访问上级的对象，于是便把各种需要通知上级的事情都放在了委托方法里，尽管这些事情与委托本身无关，但是为了实现功能已经不在意这些所谓的设计与美观</p>\n<p>可以考虑用block来传递数据源和响应事件，这样封装的view在代码的连贯性上更好一些</p>\n</blockquote>\n<p>简单的说结合具体案例，恰当的采用委托或者block来实现</p>\n<h4 id=\"6）静态DataSource\"><a href=\"#6）静态DataSource\" class=\"headerlink\" title=\"6）静态DataSource\"></a>6）静态DataSource</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=4\">一些优化代码结构的方法</a></p>\n<p>开发中难免会遇到很多静态的几乎很少变化的tableView界面</p>\n<p>图省事的人直接在代码里 switchCase  一行行的硬编码，写死了整个tableview的界面</p>\n<p>还是推荐使用plist，用代码从数据源中读取数据，从而进行展示</p>\n<blockquote>\n<p>这样，后续迭代版本的内容只需要修改plist文件的内容就可以了。而不需要在代码中修改逻辑。</p>\n</blockquote>\n<h4 id=\"7）使用orm\"><a href=\"#7）使用orm\" class=\"headerlink\" title=\"7）使用orm\"></a>7）使用orm</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=4\">一些优化代码结构的方法</a></p>\n<p>很多人都是这么做的</p>\n<p>不要在解析网络等数据的时候，手写解析过程，采用<code>mantle</code>or<code>JsonModel</code>等框架来做这些事情</p>\n<h4 id=\"8）构建易于测试的模块\"><a href=\"#8）构建易于测试的模块\" class=\"headerlink\" title=\"8）构建易于测试的模块\"></a>8）构建易于测试的模块</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=4\">一些优化代码结构的方法</a><br><a href=\"http://www.reviewcode.cn/article.html?reviewId=1\">如何打造令人愉悦的开发环境</a></p>\n<p>都提到了，尽量在开发中设计易于测试的模块。<br>众多功能杂糅在一个类里面是不利于测试的，写一个超大函数，干了很多功能也是不利于编写自动化测试的<br>后面还会提到，随着项目的逐渐扩大，保持至健壮的自动化测试+持续集成，才是一个健康的项目结构</p>\n<h4 id=\"9）不要想当然的使用tableView\"><a href=\"#9）不要想当然的使用tableView\" class=\"headerlink\" title=\"9）不要想当然的使用tableView\"></a>9）不要想当然的使用tableView</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=6\">不要想当然的使用tableView</a></p>\n<ul>\n<li>不要试图过分的复用一个TableViewController</li>\n<li>一定要复用的场景<ul>\n<li>用switch来区分场景，用不同的tableview进行处理</li>\n<li>将数据源的判断逻辑，不同的tableview类给自己处理自己的<code>delegate</code> or <code>datasource</code></li>\n<li>这样多路复用的选择其实就发生在了返回tableView的操作里，可以避免在控制器中出现臃肿的代码</li>\n</ul>\n</li>\n<li>不要试图滥用Cell的重用机制</li>\n</ul>\n<h4 id=\"10）圆角\"><a href=\"#10）圆角\" class=\"headerlink\" title=\"10）圆角\"></a>10）圆角</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=7\">关于性能的一些问题</a></p>\n<p>详细可以看关于离屏渲染的Link中的介绍，<br>也可以看另一位大神ibireme对渲染流畅的文章，<a href=\"http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/\">iOS 保持界面流畅的技巧</a></p>\n<p>简单的说就是<code>CALayer</code>的<code>圆角</code>和<code>阴影</code>，当出现在大量的cell之中，会进项很多的离屏渲染，这样就会大幅度拖慢FPS</p>\n<p>如何解决？</p>\n<blockquote>\n<p>圆角使用UIImageView来处理。<br>简单来说，底层铺一个UIImageView,然后用GraphicsContext生成一张带圆角的图。</p>\n</blockquote>\n<h4 id=\"11-App沙盒数据存储目录\"><a href=\"#11-App沙盒数据存储目录\" class=\"headerlink\" title=\"11) App沙盒数据存储目录\"></a>11) App沙盒数据存储目录</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=8\">一些代码建议</a></p>\n<blockquote>\n<p>数据存储应该再谨慎一些，至少用户数据可以放在 Documents 文件夹下某个子目录里，而不应该直接丢到 Documents 文件夹下，清空时也不应该清空整个 Documents 文件夹。</p>\n</blockquote>\n<p>PS:顺带我想说，如果app配置了itunes查看Documents的功能，apple审核的时候会查看documents目录，一些非用户可感知的数据，程序生成的数据，存放在Doc目录下，可能会被苹果拒审</p>\n<h4 id=\"12）-即时抽取函数\"><a href=\"#12）-即时抽取函数\" class=\"headerlink\" title=\"12） 即时抽取函数\"></a>12） 即时抽取函数</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=9\">话谈 iOS 目录结构的划分</a></p>\n<p>可以细看Link中的案例</p>\n<p>简单描述就是，随着业务的不断增长，有时候会出现超长的函数，有时候会有相似代码，被写出来，适当的即时抽取函数，减少超长代码，减少近似冗余代码</p>\n<h4 id=\"13）-使用懒加载\"><a href=\"#13）-使用懒加载\" class=\"headerlink\" title=\"13） 使用懒加载\"></a>13） 使用懒加载</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=10\">好的代码习惯</a></p>\n<pre><code> [self initComps];\n[self initToolbar];\n[self initVertical];\n[self initImageView];\n[self initMediaPick];\n[self setupSpeechRecognizer];\n[self initAttributedString];\n[self initTextView];\n</code></pre><p>这样的代码，推荐使用懒加载</p>\n<blockquote>\n<p>懒加载带来的收益：我们不再需要显式的生成和调用initAttributedString方法，只需要在使用的时候调用属性self.attrString，对象的实例化全部放在getter中，可以有效降低代码的耦合度;在使用属性之前，属性并不会提前生成，减少内存占用。</p>\n</blockquote>\n<h4 id=\"13）delegate校验参数\"><a href=\"#13）delegate校验参数\" class=\"headerlink\" title=\"13）delegate校验参数\"></a>13）delegate校验参数</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=10\">好的代码习惯</a></p>\n<pre><code>- (void)textViewDidEndEditing:(YYTextView *)textView {\n    if (textView == self.textView) {\n        self.navigationItem.rightBarButtonItem = nil;\n    }\n}\n</code></pre><blockquote>\n<p>如果你的delegate方法，只作为一个textView的委托回调，这种写法没有任何。但是如果你想扩展你的界面，在将来的界面中很可能出现另一个textView，这时你就必须区分这两个textView是谁回调了这个代理方法</p>\n</blockquote>\n<h3 id=\"四-项目配置\"><a href=\"#四-项目配置\" class=\"headerlink\" title=\"四. 项目配置\"></a>四. 项目配置</h3><h4 id=\"1）目录结构\"><a href=\"#1）目录结构\" class=\"headerlink\" title=\"1）目录结构\"></a>1）目录结构</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=9\">话谈iOS目录结构的划分</a></p>\n<p>提到了MVC结构，以及MVC结构下如何划分目录结构</p>\n<blockquote>\n<p>往往业界有两种做法：</p>\n<p>先按业务划分，再按照 MVC 来划分</p>\n<p>先按 MVC 划分，再按照业务划分</p>\n<p>第一种的好处是把相应业务的代码放在一起，找特别好找，相应的 xib、model 和 ViewController 全在一个地方。在这些代码之间跳转特别方便。Telegram 非常大的代码量，也是这么组织的。个人觉得如果代码量特别大，这种划分方式其实更好，先按照业务划分了，更容易分工合作。</p>\n<p>第二种似乎更多人用。Yep 也是按照这样的方式组织。</p>\n<p>其实我觉得都可以，看个人习惯。</p>\n</blockquote>\n<p>PS:我表示，我可能更习惯<code>先按业务模块划分，再MVC</code></p>\n<h4 id=\"2）合理高效的开发环境\"><a href=\"#2）合理高效的开发环境\" class=\"headerlink\" title=\"2）合理高效的开发环境\"></a>2）合理高效的开发环境</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=1\">如何打造令人愉悦的开发环境</a></p>\n<p>这个案例里面详尽探讨了一个观点 <code>一个合理高效的开发环境应该是依托于自动化之上的.</code></p>\n<p>自动化应当包含以下几个方面:</p>\n<ul>\n<li>代码风格检查</li>\n<li>自动化测试</li>\n<li>持续集成</li>\n<li>常用库的封装和打包</li>\n</ul>\n<h4 id=\"3）第三方库管理\"><a href=\"#3）第三方库管理\" class=\"headerlink\" title=\"3）第三方库管理\"></a>3）第三方库管理</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=1\">如何打造令人愉悦的开发环境</a><br><a href=\"http://www.reviewcode.cn/article.html?reviewId=3\">要你命三千：老代码中的那些坑</a></p>\n<ul>\n<li>各种第三方库推荐使用cocoapods管理，提高效率</li>\n<li>项目勤用三方库，随意穿插改无数。 即使类库有更新，试问代码谁维护</li>\n</ul>\n<h4 id=\"4-自动打包配置\"><a href=\"#4-自动打包配置\" class=\"headerlink\" title=\"4) 自动打包配置\"></a>4) 自动打包配置</h4><p><a href=\"http://www.reviewcode.cn/article.html?reviewId=11\">iOS下如何自动化打包App</a></p>\n<ul>\n<li>自动化的全面配置打包平台的一个方案</li>\n</ul>\n<h3 id=\"持续更新\"><a href=\"#持续更新\" class=\"headerlink\" title=\"持续更新\"></a>持续更新</h3><p>codeReview应该持续进行下去，这个总结也应该持续进行。</p>\n<p>扔到Git上吧，<a href=\"https://github.com/Awhisper/iOSCodeReviewTipsCollection\">iOSCodeReviewTipsCollection</a>，（╮(╯_╰)╭ 又TM是广告)</p>\n"},{"layout":"post","date":"2016-03-31T15:50:46.000Z","title":"OC代码小Tips","keywords":"iOS","description":"iOS资料整理","excerpt":"","_content":"\n\n首先要说明的是，命名的最大规则是可读的，清晰的。\n\n其次，才考虑如何简洁的命名。\n\n\n## 代码组织\n\n\n在函数分组和protocol/delegate实现中使用#pragma mark -来分类方法，要遵循以下一般结构：\n\n\t#pragma mark - Lifecycle（View 的生命周期）  \n\t- (instancetype)init {}  \n\t- (void)dealloc {}  \n\t- (void)viewDidLoad {}  \n\t- (void)viewWillAppear:(BOOL)animated {}  \n\t- (void)didReceiveMemoryWarning {}  \n\t#pragma mark - Custom Accessors  （自定义访问器）\n\t- (void)setCustomProperty:(id)value {}  \n\t- (id)customProperty {}  \n\t#pragma mark - IBActions  \n\t- (IBAction)submitData:(id)sender {}  \n\t#pragma mark - Public  \n\t- (void)publicMethod {}  \n\t#pragma mark - Private  \n\t- (void)privateMethod {}  \n\t#pragma mark - Protocol conformance  \n\t#pragma mark - UITextFieldDelegate  \n\t#pragma mark - UITableViewDataSource  \n\t#pragma mark - UITableViewDelegate  \n\t#pragma mark - NSCopying  \n\t- (id)copyWithZone:(NSZone *)zone {}  \n\t#pragma mark - NSObject  \n\t- (NSString *)description {}  \n\n\n## 注释\n\n\n当需要注释时，注释应该用来解释这段特殊代码为什么要这样做。\n\n任何被使用的注释都必须保持最新或被删除。\n\n一般都避免使用块注释，因为代码尽可能做到自解释，只有当断断续续或几行代码时才需要注释。\n\n例外：这不应用在生成文档的注释\n\n## 字面量\n\nNSString、NSDictionary、NSArray和NSNumber的字面值，应该在创建这些类的不可变实例时被使用。\n\n请特别注意---nil值不能传入NSArray和NSDictionary字面值，因为这样会导致crash。\n\n推荐\n```objc\n\tNSArray *names = @[@\"Brian\", @\"Matt\", @\"Chris\", @\"Alex\", @\"Steve\", @\"Paul\"];  \n\tNSDictionary *productManagers = @{@\"iPhone\": @\"Kate\", @\"iPad\": @\"Kamal\", @\"Mobile Web\": @\"Bill\"};  \n\tNSNumber *shouldUseLiterals = @YES;  \n\tNSNumber *buildingStreetNumber = @10018;  \n```\n不推荐\n\n\tNSArray *names = [NSArray arrayWithObjects:@\"Brian\", @\"Matt\", @\"Chris\", @\"Alex\", @\"Steve\", @\"Paul\", nil];  \n\tNSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @\"Kate\", @\"iPhone\", @\"Kamal\", @\"iPad\", @\"Bill\", @\"Mobile Web\", nil];  \n\tNSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];  \n\tNSNumber *buildingStreetNumber = [NSNumber numberWithInteger:10018]; \n\t \n## 变量\n\n### 实例变量\n\n实例变量，应该在实现文件.m中声明。\n\n如果一定要直接在.h文件声明，加上@priavte，另外，使用@private、@public，前面需要一个缩进空格。\n\n一般以@property形式，在.h文件中声明。\n\n>推荐多用属性，并且避免直接访问实例变量。\n\nPS:尽可能保证 .h文件的简洁性，可以不公开的API就不要公开了，写在实现文件中即可。\n### 属性\n\n用@property声明属性后，默认的实例变量名称是\n\n\t_variableName。\n\n在.m实现文件中，可以用@synthesize,改变实例变量名称\n\n\t @synthessize variableName=goodVariableName\n \n\n如果你使用 @synthesize 关键字时，不去指明实例变量的名字的话，像下面这样：\n\n\t@synthesize firstName;\n\t\n那么实例变量将会被命成与属性一样的名字。 在这个例子中，实例变量将会被命名为 firstName ,并且不会加上下划线前缀。\n\n#### 属性特性\n\n所有属性特性应该显式地列出来，有助于阅读代码。\n\n顺序与在Interface Builder连接UI元素时自动生成代码一致。\n\n属性特性的顺序，应该是\n>1.原子性:atomic,nonatomic\n>\n>2.读写:readonly,readwrite\n>\n>3.内存管理：weak,strong,copy。\n\n- 属性可以存储一个代码块。为了让它存活到定义的块的结束，必须使用 copy （block 最早在栈里面创建，使用 copy让 block 拷贝到堆里面去）\n\n- 你必须使用 nonatomic，除非特别需要的情况。在iOS中，atomic带来的锁特别影响性能。\n\n- 对于非可变类（比如NSString,NSArray），通常使用copy修饰。\n\n- 对于一个外部引用对象，且外部不会发生set操作的对象，使用readonly属性。比如在创建界面元素的时候:\n\n\t\t@interface BWView : UIView\n\t\t@property (nonatomic, strong, readonly) UIView* backgroundView;\n\t\t@end\n\t\t@implementation BWView\n\t\t@end\n\nreadonly 表明其不能修改只能读取，在这种情况下编译器将会合成一个名为backgroundView getter方法，而不是一个setBackgroundView方法。\n\n- 为了完成一个共有的 getter 和一个私有的 setter，你应该声明公开的属性为 readonly ,并且在类扩展中重新定义通用的属性为 readwrite 的。\n\n\t\t//.h文件中\n\t\t@interface MyClass : NSObject\n\t\t@property (nonatomic, readonly, strong) NSObject *object;\n\t\t@end\n\t\t//.m文件中\n\t\t@interface MyClass ()\n\t\t@property (nonatomic, readwrite, strong) NSObject *object;\n\t\t@end\n\n\t\t@implementation MyClass\n\t\t//Do Something cool\n\t\t@end\n\t\t\n\t\t\n### 可变对象\n\n任何可以用一个可变的对象设置的(比如 NSString,NSArray,NSURLRequest)属性,它的内存管理类型必须是 copy 的。\n\n这是为了防止在不明确的情况下，修改被封装好的对象的值。\n\n>例如：array定义为 copy 的 NSArray 实例，当执行 array= mutableArray，copy 属性会让 array 的 setter 方法为 array = [mutableArray copy], [mutableArray copy] 返回的是不可变的 NSArray 实例，就保证了正确性。\n>\n>用其他属性修饰符修饰，容易在直接赋值的时候，array 指向的是 NSMuatbleArray 的实例，在之后可以随意改变它的值，就容易出错。\n\n\n同时，应该避免在公开的接口中，暴露可变的对象。\n\n因为这允许你的类的使用者，改变类自己的内部表示，并且破坏类的封装。你可以提供只读的属性，来返回你对象的不可变的副本。如：\n\n\n\t/* .h */\n\t@property (nonatomic, readonly) NSArray *elements\n\n\t/* .m */\n\t- (NSArray *)elements {\n  \treturn [self.mutableElements copy];\n\t}\n\t\n\n#### 私有属性\n\n私有属性应该定义在类的实现文件的类的扩展 (匿名的 category) 中。不允许在有名字的 category(如 ZOCPrivate）中定义私有属性，除非你扩展其他类。\n\n推荐\n\n\t@interface RWTDetailViewController ()  \n\t@property (strong, nonatomic) GADBannerView *googleAdView;  \n\t@property (strong, nonatomic) ADBannerView *iAdView;  \n\t@property (strong, nonatomic) UIWebView *adXWebView;  \n\t@end\n\t\n\n## 常量\n\n#### 常量使用\n\n常量是容易重复被使用，和无需通过查找和代替就能快速修改值的。\n\n常量应该使用static来声明，而不是使用#define，除非显式地使用宏\n所有的单词首字母大写，和加上与类名有关的前缀\n\n推荐\n\n\tstatic NSString * const RWTAboutViewControllerCompanyName = @\"RayWenderlich.com\";  \n\tstatic CGFloat const RWTImageThumbnailHeight = 50.0;  \n\t\n不推荐\n\n\t#define CompanyName @\"RayWenderlich.com\"  \n\t#define thumbnailHeight 2  \n\n### 常量小写k开头\n\n常量以小写字母k开头，后续首字母大写\n\n\tstatic NSString* const kBWBarTitle = @\"动态\";\n\n\n### 常量应该使用驼峰式命名规则。\n\n推荐\n\n\tstatic NSTimeInterval const RWTTutorialViewControllerNavigationFadeAnimationDuration = 0.3;  \n\t\n不推荐\n\n\tstatic NSTimeInterval const fadetime = 1.7;  \n\t\n\n。\n## 方法\n\n### 方法参数名\n\n方法参数名前，一般使用的前缀\n\n>the,an,new,a\n\n\t- (void)setTitle:(NSString *)aTitle;\n\t- (void)setName:(NSString *)newName;\n\t- (id)keyForOption:(CDCOption *)anOption\n\t- (NSArray *)emailsForMailbox:(CDCMailbox *)theMailbox;\n\t- (CDCEmail *)emailForRecipients:(NSArray *)    theRecipients;\n\n### \"and\"这个词的用法应该保留\n\n”and“不应该用于多个参数来说明，就像initWithWidth:height以下这个例子.\n\n推荐\n \n\t- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height;  \n\n不推荐\n\n\t- (instancetype)initWith:(int)width and:(int)height;  // Never do this.  \n\t\n\n### 方法长度\n函数长度不要超过50行，小函数要比大函数可阅读性和可复用性强。\n\n零元函数最好，一元函数也不错，二元函数担心了，三元函数有风险，高于三元需重构。函数的参数越多，引起其变化的因素就越多。越不利于以后的修改。\n\n### 避免出现火车链式的情况\n\n推荐\n\n\tBWAppSetting* shareSetting = [BWAppSetting GetInstance];\n\tBWLockDictionary* defaultSettings = [shareSetting appSetting];\n\t_needLogoutAccount = [[defaultSettings valueForKeyPath:NeedLogoutAccounts] retain];\n\n不推荐\n\n\t_needLogoutAccount = [[[[BWAppSetting GetInstance] appSetting] valueForKey:NeedLogoutAccounts] retain];\n\t\n\t\n### 取值方法\n\n- 取值方法前，不要加前缀“get”。\n- 如果BOOL属性的名字是一个形容词，属性就能忽略\"is\"前缀，但要指定get访问器的惯用名称。例如：\n\n\t\t@property (assign, getter=isEditable) BOOL editable;\n\n\n### 方法调用\n\n属性和幂等方法，推荐使用点标记语法访问。\n\n其他情况，使用方括号标记语法。\n\n推荐\n\n\tview.backgroundColor = [UIColor orangeColor];\n\t[UIApplication sharedApplication].delegate;\n\t\n不推荐\n\t\n\t[view setBackgroundColor:[UIColor orangeColor]];\n\tUIApplication.sharedApplication.delegate;\n\n## 委托代理模式\n\n### 区分delegate和datasource\n\n委托模式(delegate pattern)：事件发生的时候，委托者需要通知代理者。\n\n数据源模式(datasource pattern): 委托者需要从数据源对象拉取数据。\n\n重点:数据源模式，会要求数据源的对象来实现对应方法，达到委托者本身获取数据的目标。\n\n\n\n\t@class ZOCSignUpViewController;\n    //Delegate\n\t@protocol ZOCSignUpViewControllerDelegate <NSObject>\n\t- (void)signUpViewControllerDidPressSignUpButton:(ZOCSignUpViewController *)controller;\n\t@end\n\t//DataSource\n\t@protocol ZOCSignUpViewControllerDataSource <NSObject>\n\t- (ZOCUserCredentials *)credentialsForSignUpViewController:(ZOCSignUpViewController *)controller;\n\t@end\n\n\n\t@interface ZOCSignUpViewController : UIViewController\n\n\t@property (nonatomic, weak) id<ZOCSignUpViewControllerDelegate> delegate;\n\t@property (nonatomic, weak) id<ZOCSignUpViewControllerDataSource> dataSource;\n\n\t@end\n\nPS：\n\n- Protocol单独用一个文件来创建。尽量不要与相关类混在一个文件中。\n\n- 写delegate的时候类型应该为weak弱引用，以避免循环引用。\n\n当delegate对象不存在后，我们写的delegate也就没有存在意义了自然是需要销毁的\n\n\t@property(nonatomic,weak) id<viewControllerDelegate> delegat;\n\n\n## Block\n\nBlock 是 Objective-C 版本的 lambda 或者 closure（闭包）。\n\n当使用代码块和异步分发的时候，要注意避免引用循环。在block中使用到self变量的时候，一定要先weak再strong.\n\n推荐\n\n\t__weak typeof(self) weakSelf = self;\n\t[self doABlockOperation:^{\n    __strong typeof(weakSelf) strongSelf = weakSelf;\n    if (strongSelf) {\n        ...\n    }\n\t}];\n\n不推荐\n\n\t[self executeBlock:^(NSData *data, NSError *error) {\n    [self doSomethingWithData:data];\n\t}];\n## 控制结构\n\n### 分支结构\n\n当需要满足一定条件时才执行某项操作时，最左边缘应该是愉快路径代码。不要将愉快路径代码内嵌到if语句中。多个return是正常合理的。\n\n推荐\n\n\t- (void) someMethod {\n\tif (![someOther boolValue]) {\n      return;\n  \t}\n  \t//Do something important\n\t}\n\n不推荐\n\n\t- (void) someMethod {\n \t if ([someOther boolValue]) {\n   \t   //Do something important\n \t }\n\t}\n\n\n### 循环结构\n\n遍历可变容器(容器:如数组，字典等)，应该复制该容器，使用copy。\n\n\tNSArray *Arrays=[self.multableArray copy];\n\tfor(id obj in Arrays){\n\t//do something\n\t}\n\t\n尽量不要使用异常，尤其是不要将异常做为业务逻辑的一部分，在异常中尝试进行灾难恢复。\n\n## 类\n### 保持公共API简单\n\n 其实也就说，保持.h文件的整洁和干净。\n\n 避免 “厨房水槽（kitchen-sink）” 式的 API。如果一个函数压根没必要公开，就不要这么做。用私有类别，保证公共头文件整洁。\"\n### 初始化\n\n保持init函数简洁，不要让init函数成为千行的大函数，当超过50行的时候，适当考虑分拆一下。\n\n良好风格实例：\n\n\t- (void) commonInit\n\t{\n    _rightAppendImageView = [UIImageView new];\n    [self.contentView addSubview:_rightAppendImageView];\n\t}\n\t- (instancetype) initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier\n\t{\n    self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];\n    if (!self) {\n        return self;\n    }\n    [self commonInit];\n    return self;\n\t}\n\t\n## 其他\n\n### 布尔值\n\nObjective-C使用YES和NO。\n\n因为true和false应该只在CoreFoundation，C或C++代码使用。\n\n既然nil解析成NO，所以没有必要在条件语句比较。\n\n不要拿某样东西直接与YES比较，因为当YES被定义为1和一个BOOL会被设置为8位。\n\n推荐\n\n\tif (someObject) {}  \n\tif (![anotherObject boolValue]) {}  \n\t\n不推荐\n\n\tif (someObject == nil) {}  \n\tif ([anotherObject boolValue] == NO) {}  \n\tif (isAwesome == YES) {} // Never do this.  \n\tif (isAwesome == true) {} // Never do this.  \n###尽量不要在界面布局的写任何死数字\n\n推荐\n\n\tCGFloat cellHeight = CGRectGetHeight(self.frame);\n\tCGFloat cellWidth = CGRectGetWidth(self.frame);\n\tCGRect numFrame = CGRectZero;\n\tnumFrame.size = CGSizeMake(cellWidth,cellHeight);\n\n不推荐\n\t\n\tCGFloat delta = SYSTEM_VERSION >= 7.0 ? 0.0f : -14.0f;\n\tnewFrame = CGRectMake(245 + delta,\n                              (self.frame.size.height - tipNewSize.height)/2,\n                              tipNewSize.width,\n                              tipNewSize.height);\n    dotFrame = CGRectMake(258.0 + delta,  (self.frame.size.height - tipDotSize.height)/2,\n                              tipDotSize.width,\n                              tipDotSize.height);\n    iconFrame = CGRectMake(245 + delta,\n                               (self.frame.size.height - tipIconSize.height)/2,\n                               tipIconSize.width,\n                               tipIconSize.height);\n    numFrame = CGRectMake(245+delta, (self.frame.size.height - tipNumSize.height)/2, tipNumSize.width, tipNumSize.height);\n\n## 设计模式\n\nPS：使用设计模式的最基本原则----\n>除非你明确知道自己要做件什么事情，而且知道使用特定设计模式带来的影响.\n>\n>否则，不要刻意的使用设计模式。\n\n### 单例模式\n如果可能，请尽量避免使用单例而是依赖注入。 然而，如果一定要用，请使用一个线程安全的模式来创建共享的实例。对于 GCD，用 dispatch_once() 函数就可以咯。\n\n\t+ (instancetype)sharedInstance {  \n \t \tstatic id sharedInstance = nil;  \n  \t \tstatic dispatch_once_t onceToken=0;  \n \t \tdispatch_once(&onceToken, ^{  \n    \tsharedInstance = [[self alloc] init];  \n \t \t});  \n \t \treturn sharedInstance;  \n\t}  \n\n\n使用 dispatch_once()，来控制代码同步，取代了原来的约定俗成的用法。\n\n\t+ (instancetype)sharedInstance\n\t{\n    static id sharedInstance;\n    @synchronized(self) {\n        if (sharedInstance == nil) {\n            sharedInstance = [[MyClass alloc] init];\n        }\n    }\n    return sharedInstance;\n\t}\n\n\ndispatch_once() 的优点是，它更快，而且语法上更干净，因为dispatch_once()的意思就是 “把一些东西执行一次”，就像我们做的一样。\n\n同时，这可以防止[possible and sometimes prolific crashes](http://cocoasamurai.blogspot.com/2011/04/singletons-your-doing-them-wrong.html)。\n\n### 观察者模式\n\n如果只是单纯的传递数据，不要使用观察者模式，容易导致逻辑链断裂。\n\n\n>参考\n>\n>[禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译）](https://github.com/oa414/objc-zen-book-cn/#%E9%BB%84%E9%87%91%E5%A4%A7%E9%81%93)\n>\n>[programming with objective-c](http://wiki.jikexueyuan.com/project/programming-with-objective-c/encapsulating-data.html)\n>\n>[Object-C代码规范](http://www.cocoachina.com/ios/20140520/8484.html)\n>\n>[Objective-C 编码建议](http://www.cocoachina.com/ios/20151118/14242.html)\n>\n>[Objective-C编码规范：26个方面解决iOS开发问题](http://www.csdn.net/article/2015-06-01/2824818-objective-c-style-guide/1)\n>\n>《iOS6编程实战》 人民邮电出版社\n\n","source":"_posts/技术/2016-3-31-codeGuide.md","raw":"---\nlayout: post\ndate: 2016-03-31 23:50:46\ntitle: OC代码小Tips\ncategory: 技术\ntags: 资料\nkeywords: iOS\ndescription: iOS资料整理\nexcerpt: 关于属性修饰，方法使用，变量命名等日常开发，要时时注意的细节总结。保持良好的代码习惯！\n---\n\n\n首先要说明的是，命名的最大规则是可读的，清晰的。\n\n其次，才考虑如何简洁的命名。\n\n\n## 代码组织\n\n\n在函数分组和protocol/delegate实现中使用#pragma mark -来分类方法，要遵循以下一般结构：\n\n\t#pragma mark - Lifecycle（View 的生命周期）  \n\t- (instancetype)init {}  \n\t- (void)dealloc {}  \n\t- (void)viewDidLoad {}  \n\t- (void)viewWillAppear:(BOOL)animated {}  \n\t- (void)didReceiveMemoryWarning {}  \n\t#pragma mark - Custom Accessors  （自定义访问器）\n\t- (void)setCustomProperty:(id)value {}  \n\t- (id)customProperty {}  \n\t#pragma mark - IBActions  \n\t- (IBAction)submitData:(id)sender {}  \n\t#pragma mark - Public  \n\t- (void)publicMethod {}  \n\t#pragma mark - Private  \n\t- (void)privateMethod {}  \n\t#pragma mark - Protocol conformance  \n\t#pragma mark - UITextFieldDelegate  \n\t#pragma mark - UITableViewDataSource  \n\t#pragma mark - UITableViewDelegate  \n\t#pragma mark - NSCopying  \n\t- (id)copyWithZone:(NSZone *)zone {}  \n\t#pragma mark - NSObject  \n\t- (NSString *)description {}  \n\n\n## 注释\n\n\n当需要注释时，注释应该用来解释这段特殊代码为什么要这样做。\n\n任何被使用的注释都必须保持最新或被删除。\n\n一般都避免使用块注释，因为代码尽可能做到自解释，只有当断断续续或几行代码时才需要注释。\n\n例外：这不应用在生成文档的注释\n\n## 字面量\n\nNSString、NSDictionary、NSArray和NSNumber的字面值，应该在创建这些类的不可变实例时被使用。\n\n请特别注意---nil值不能传入NSArray和NSDictionary字面值，因为这样会导致crash。\n\n推荐\n```objc\n\tNSArray *names = @[@\"Brian\", @\"Matt\", @\"Chris\", @\"Alex\", @\"Steve\", @\"Paul\"];  \n\tNSDictionary *productManagers = @{@\"iPhone\": @\"Kate\", @\"iPad\": @\"Kamal\", @\"Mobile Web\": @\"Bill\"};  \n\tNSNumber *shouldUseLiterals = @YES;  \n\tNSNumber *buildingStreetNumber = @10018;  \n```\n不推荐\n\n\tNSArray *names = [NSArray arrayWithObjects:@\"Brian\", @\"Matt\", @\"Chris\", @\"Alex\", @\"Steve\", @\"Paul\", nil];  \n\tNSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @\"Kate\", @\"iPhone\", @\"Kamal\", @\"iPad\", @\"Bill\", @\"Mobile Web\", nil];  \n\tNSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];  \n\tNSNumber *buildingStreetNumber = [NSNumber numberWithInteger:10018]; \n\t \n## 变量\n\n### 实例变量\n\n实例变量，应该在实现文件.m中声明。\n\n如果一定要直接在.h文件声明，加上@priavte，另外，使用@private、@public，前面需要一个缩进空格。\n\n一般以@property形式，在.h文件中声明。\n\n>推荐多用属性，并且避免直接访问实例变量。\n\nPS:尽可能保证 .h文件的简洁性，可以不公开的API就不要公开了，写在实现文件中即可。\n### 属性\n\n用@property声明属性后，默认的实例变量名称是\n\n\t_variableName。\n\n在.m实现文件中，可以用@synthesize,改变实例变量名称\n\n\t @synthessize variableName=goodVariableName\n \n\n如果你使用 @synthesize 关键字时，不去指明实例变量的名字的话，像下面这样：\n\n\t@synthesize firstName;\n\t\n那么实例变量将会被命成与属性一样的名字。 在这个例子中，实例变量将会被命名为 firstName ,并且不会加上下划线前缀。\n\n#### 属性特性\n\n所有属性特性应该显式地列出来，有助于阅读代码。\n\n顺序与在Interface Builder连接UI元素时自动生成代码一致。\n\n属性特性的顺序，应该是\n>1.原子性:atomic,nonatomic\n>\n>2.读写:readonly,readwrite\n>\n>3.内存管理：weak,strong,copy。\n\n- 属性可以存储一个代码块。为了让它存活到定义的块的结束，必须使用 copy （block 最早在栈里面创建，使用 copy让 block 拷贝到堆里面去）\n\n- 你必须使用 nonatomic，除非特别需要的情况。在iOS中，atomic带来的锁特别影响性能。\n\n- 对于非可变类（比如NSString,NSArray），通常使用copy修饰。\n\n- 对于一个外部引用对象，且外部不会发生set操作的对象，使用readonly属性。比如在创建界面元素的时候:\n\n\t\t@interface BWView : UIView\n\t\t@property (nonatomic, strong, readonly) UIView* backgroundView;\n\t\t@end\n\t\t@implementation BWView\n\t\t@end\n\nreadonly 表明其不能修改只能读取，在这种情况下编译器将会合成一个名为backgroundView getter方法，而不是一个setBackgroundView方法。\n\n- 为了完成一个共有的 getter 和一个私有的 setter，你应该声明公开的属性为 readonly ,并且在类扩展中重新定义通用的属性为 readwrite 的。\n\n\t\t//.h文件中\n\t\t@interface MyClass : NSObject\n\t\t@property (nonatomic, readonly, strong) NSObject *object;\n\t\t@end\n\t\t//.m文件中\n\t\t@interface MyClass ()\n\t\t@property (nonatomic, readwrite, strong) NSObject *object;\n\t\t@end\n\n\t\t@implementation MyClass\n\t\t//Do Something cool\n\t\t@end\n\t\t\n\t\t\n### 可变对象\n\n任何可以用一个可变的对象设置的(比如 NSString,NSArray,NSURLRequest)属性,它的内存管理类型必须是 copy 的。\n\n这是为了防止在不明确的情况下，修改被封装好的对象的值。\n\n>例如：array定义为 copy 的 NSArray 实例，当执行 array= mutableArray，copy 属性会让 array 的 setter 方法为 array = [mutableArray copy], [mutableArray copy] 返回的是不可变的 NSArray 实例，就保证了正确性。\n>\n>用其他属性修饰符修饰，容易在直接赋值的时候，array 指向的是 NSMuatbleArray 的实例，在之后可以随意改变它的值，就容易出错。\n\n\n同时，应该避免在公开的接口中，暴露可变的对象。\n\n因为这允许你的类的使用者，改变类自己的内部表示，并且破坏类的封装。你可以提供只读的属性，来返回你对象的不可变的副本。如：\n\n\n\t/* .h */\n\t@property (nonatomic, readonly) NSArray *elements\n\n\t/* .m */\n\t- (NSArray *)elements {\n  \treturn [self.mutableElements copy];\n\t}\n\t\n\n#### 私有属性\n\n私有属性应该定义在类的实现文件的类的扩展 (匿名的 category) 中。不允许在有名字的 category(如 ZOCPrivate）中定义私有属性，除非你扩展其他类。\n\n推荐\n\n\t@interface RWTDetailViewController ()  \n\t@property (strong, nonatomic) GADBannerView *googleAdView;  \n\t@property (strong, nonatomic) ADBannerView *iAdView;  \n\t@property (strong, nonatomic) UIWebView *adXWebView;  \n\t@end\n\t\n\n## 常量\n\n#### 常量使用\n\n常量是容易重复被使用，和无需通过查找和代替就能快速修改值的。\n\n常量应该使用static来声明，而不是使用#define，除非显式地使用宏\n所有的单词首字母大写，和加上与类名有关的前缀\n\n推荐\n\n\tstatic NSString * const RWTAboutViewControllerCompanyName = @\"RayWenderlich.com\";  \n\tstatic CGFloat const RWTImageThumbnailHeight = 50.0;  \n\t\n不推荐\n\n\t#define CompanyName @\"RayWenderlich.com\"  \n\t#define thumbnailHeight 2  \n\n### 常量小写k开头\n\n常量以小写字母k开头，后续首字母大写\n\n\tstatic NSString* const kBWBarTitle = @\"动态\";\n\n\n### 常量应该使用驼峰式命名规则。\n\n推荐\n\n\tstatic NSTimeInterval const RWTTutorialViewControllerNavigationFadeAnimationDuration = 0.3;  \n\t\n不推荐\n\n\tstatic NSTimeInterval const fadetime = 1.7;  \n\t\n\n。\n## 方法\n\n### 方法参数名\n\n方法参数名前，一般使用的前缀\n\n>the,an,new,a\n\n\t- (void)setTitle:(NSString *)aTitle;\n\t- (void)setName:(NSString *)newName;\n\t- (id)keyForOption:(CDCOption *)anOption\n\t- (NSArray *)emailsForMailbox:(CDCMailbox *)theMailbox;\n\t- (CDCEmail *)emailForRecipients:(NSArray *)    theRecipients;\n\n### \"and\"这个词的用法应该保留\n\n”and“不应该用于多个参数来说明，就像initWithWidth:height以下这个例子.\n\n推荐\n \n\t- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height;  \n\n不推荐\n\n\t- (instancetype)initWith:(int)width and:(int)height;  // Never do this.  \n\t\n\n### 方法长度\n函数长度不要超过50行，小函数要比大函数可阅读性和可复用性强。\n\n零元函数最好，一元函数也不错，二元函数担心了，三元函数有风险，高于三元需重构。函数的参数越多，引起其变化的因素就越多。越不利于以后的修改。\n\n### 避免出现火车链式的情况\n\n推荐\n\n\tBWAppSetting* shareSetting = [BWAppSetting GetInstance];\n\tBWLockDictionary* defaultSettings = [shareSetting appSetting];\n\t_needLogoutAccount = [[defaultSettings valueForKeyPath:NeedLogoutAccounts] retain];\n\n不推荐\n\n\t_needLogoutAccount = [[[[BWAppSetting GetInstance] appSetting] valueForKey:NeedLogoutAccounts] retain];\n\t\n\t\n### 取值方法\n\n- 取值方法前，不要加前缀“get”。\n- 如果BOOL属性的名字是一个形容词，属性就能忽略\"is\"前缀，但要指定get访问器的惯用名称。例如：\n\n\t\t@property (assign, getter=isEditable) BOOL editable;\n\n\n### 方法调用\n\n属性和幂等方法，推荐使用点标记语法访问。\n\n其他情况，使用方括号标记语法。\n\n推荐\n\n\tview.backgroundColor = [UIColor orangeColor];\n\t[UIApplication sharedApplication].delegate;\n\t\n不推荐\n\t\n\t[view setBackgroundColor:[UIColor orangeColor]];\n\tUIApplication.sharedApplication.delegate;\n\n## 委托代理模式\n\n### 区分delegate和datasource\n\n委托模式(delegate pattern)：事件发生的时候，委托者需要通知代理者。\n\n数据源模式(datasource pattern): 委托者需要从数据源对象拉取数据。\n\n重点:数据源模式，会要求数据源的对象来实现对应方法，达到委托者本身获取数据的目标。\n\n\n\n\t@class ZOCSignUpViewController;\n    //Delegate\n\t@protocol ZOCSignUpViewControllerDelegate <NSObject>\n\t- (void)signUpViewControllerDidPressSignUpButton:(ZOCSignUpViewController *)controller;\n\t@end\n\t//DataSource\n\t@protocol ZOCSignUpViewControllerDataSource <NSObject>\n\t- (ZOCUserCredentials *)credentialsForSignUpViewController:(ZOCSignUpViewController *)controller;\n\t@end\n\n\n\t@interface ZOCSignUpViewController : UIViewController\n\n\t@property (nonatomic, weak) id<ZOCSignUpViewControllerDelegate> delegate;\n\t@property (nonatomic, weak) id<ZOCSignUpViewControllerDataSource> dataSource;\n\n\t@end\n\nPS：\n\n- Protocol单独用一个文件来创建。尽量不要与相关类混在一个文件中。\n\n- 写delegate的时候类型应该为weak弱引用，以避免循环引用。\n\n当delegate对象不存在后，我们写的delegate也就没有存在意义了自然是需要销毁的\n\n\t@property(nonatomic,weak) id<viewControllerDelegate> delegat;\n\n\n## Block\n\nBlock 是 Objective-C 版本的 lambda 或者 closure（闭包）。\n\n当使用代码块和异步分发的时候，要注意避免引用循环。在block中使用到self变量的时候，一定要先weak再strong.\n\n推荐\n\n\t__weak typeof(self) weakSelf = self;\n\t[self doABlockOperation:^{\n    __strong typeof(weakSelf) strongSelf = weakSelf;\n    if (strongSelf) {\n        ...\n    }\n\t}];\n\n不推荐\n\n\t[self executeBlock:^(NSData *data, NSError *error) {\n    [self doSomethingWithData:data];\n\t}];\n## 控制结构\n\n### 分支结构\n\n当需要满足一定条件时才执行某项操作时，最左边缘应该是愉快路径代码。不要将愉快路径代码内嵌到if语句中。多个return是正常合理的。\n\n推荐\n\n\t- (void) someMethod {\n\tif (![someOther boolValue]) {\n      return;\n  \t}\n  \t//Do something important\n\t}\n\n不推荐\n\n\t- (void) someMethod {\n \t if ([someOther boolValue]) {\n   \t   //Do something important\n \t }\n\t}\n\n\n### 循环结构\n\n遍历可变容器(容器:如数组，字典等)，应该复制该容器，使用copy。\n\n\tNSArray *Arrays=[self.multableArray copy];\n\tfor(id obj in Arrays){\n\t//do something\n\t}\n\t\n尽量不要使用异常，尤其是不要将异常做为业务逻辑的一部分，在异常中尝试进行灾难恢复。\n\n## 类\n### 保持公共API简单\n\n 其实也就说，保持.h文件的整洁和干净。\n\n 避免 “厨房水槽（kitchen-sink）” 式的 API。如果一个函数压根没必要公开，就不要这么做。用私有类别，保证公共头文件整洁。\"\n### 初始化\n\n保持init函数简洁，不要让init函数成为千行的大函数，当超过50行的时候，适当考虑分拆一下。\n\n良好风格实例：\n\n\t- (void) commonInit\n\t{\n    _rightAppendImageView = [UIImageView new];\n    [self.contentView addSubview:_rightAppendImageView];\n\t}\n\t- (instancetype) initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier\n\t{\n    self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];\n    if (!self) {\n        return self;\n    }\n    [self commonInit];\n    return self;\n\t}\n\t\n## 其他\n\n### 布尔值\n\nObjective-C使用YES和NO。\n\n因为true和false应该只在CoreFoundation，C或C++代码使用。\n\n既然nil解析成NO，所以没有必要在条件语句比较。\n\n不要拿某样东西直接与YES比较，因为当YES被定义为1和一个BOOL会被设置为8位。\n\n推荐\n\n\tif (someObject) {}  \n\tif (![anotherObject boolValue]) {}  \n\t\n不推荐\n\n\tif (someObject == nil) {}  \n\tif ([anotherObject boolValue] == NO) {}  \n\tif (isAwesome == YES) {} // Never do this.  \n\tif (isAwesome == true) {} // Never do this.  \n###尽量不要在界面布局的写任何死数字\n\n推荐\n\n\tCGFloat cellHeight = CGRectGetHeight(self.frame);\n\tCGFloat cellWidth = CGRectGetWidth(self.frame);\n\tCGRect numFrame = CGRectZero;\n\tnumFrame.size = CGSizeMake(cellWidth,cellHeight);\n\n不推荐\n\t\n\tCGFloat delta = SYSTEM_VERSION >= 7.0 ? 0.0f : -14.0f;\n\tnewFrame = CGRectMake(245 + delta,\n                              (self.frame.size.height - tipNewSize.height)/2,\n                              tipNewSize.width,\n                              tipNewSize.height);\n    dotFrame = CGRectMake(258.0 + delta,  (self.frame.size.height - tipDotSize.height)/2,\n                              tipDotSize.width,\n                              tipDotSize.height);\n    iconFrame = CGRectMake(245 + delta,\n                               (self.frame.size.height - tipIconSize.height)/2,\n                               tipIconSize.width,\n                               tipIconSize.height);\n    numFrame = CGRectMake(245+delta, (self.frame.size.height - tipNumSize.height)/2, tipNumSize.width, tipNumSize.height);\n\n## 设计模式\n\nPS：使用设计模式的最基本原则----\n>除非你明确知道自己要做件什么事情，而且知道使用特定设计模式带来的影响.\n>\n>否则，不要刻意的使用设计模式。\n\n### 单例模式\n如果可能，请尽量避免使用单例而是依赖注入。 然而，如果一定要用，请使用一个线程安全的模式来创建共享的实例。对于 GCD，用 dispatch_once() 函数就可以咯。\n\n\t+ (instancetype)sharedInstance {  \n \t \tstatic id sharedInstance = nil;  \n  \t \tstatic dispatch_once_t onceToken=0;  \n \t \tdispatch_once(&onceToken, ^{  \n    \tsharedInstance = [[self alloc] init];  \n \t \t});  \n \t \treturn sharedInstance;  \n\t}  \n\n\n使用 dispatch_once()，来控制代码同步，取代了原来的约定俗成的用法。\n\n\t+ (instancetype)sharedInstance\n\t{\n    static id sharedInstance;\n    @synchronized(self) {\n        if (sharedInstance == nil) {\n            sharedInstance = [[MyClass alloc] init];\n        }\n    }\n    return sharedInstance;\n\t}\n\n\ndispatch_once() 的优点是，它更快，而且语法上更干净，因为dispatch_once()的意思就是 “把一些东西执行一次”，就像我们做的一样。\n\n同时，这可以防止[possible and sometimes prolific crashes](http://cocoasamurai.blogspot.com/2011/04/singletons-your-doing-them-wrong.html)。\n\n### 观察者模式\n\n如果只是单纯的传递数据，不要使用观察者模式，容易导致逻辑链断裂。\n\n\n>参考\n>\n>[禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译）](https://github.com/oa414/objc-zen-book-cn/#%E9%BB%84%E9%87%91%E5%A4%A7%E9%81%93)\n>\n>[programming with objective-c](http://wiki.jikexueyuan.com/project/programming-with-objective-c/encapsulating-data.html)\n>\n>[Object-C代码规范](http://www.cocoachina.com/ios/20140520/8484.html)\n>\n>[Objective-C 编码建议](http://www.cocoachina.com/ios/20151118/14242.html)\n>\n>[Objective-C编码规范：26个方面解决iOS开发问题](http://www.csdn.net/article/2015-06-01/2824818-objective-c-style-guide/1)\n>\n>《iOS6编程实战》 人民邮电出版社\n\n","slug":"技术/2016-3-31-codeGuide","published":1,"updated":"2016-08-21T08:00:05.000Z","comments":1,"photos":[],"link":"","_id":"cisw1pts2000zyrntxy4gcxdi","content":"<p>首先要说明的是，命名的最大规则是可读的，清晰的。</p>\n<p>其次，才考虑如何简洁的命名。</p>\n<h2 id=\"代码组织\"><a href=\"#代码组织\" class=\"headerlink\" title=\"代码组织\"></a>代码组织</h2><p>在函数分组和protocol/delegate实现中使用#pragma mark -来分类方法，要遵循以下一般结构：</p>\n<pre><code>#pragma mark - Lifecycle（View 的生命周期）  \n- (instancetype)init {}  \n- (void)dealloc {}  \n- (void)viewDidLoad {}  \n- (void)viewWillAppear:(BOOL)animated {}  \n- (void)didReceiveMemoryWarning {}  \n#pragma mark - Custom Accessors  （自定义访问器）\n- (void)setCustomProperty:(id)value {}  \n- (id)customProperty {}  \n#pragma mark - IBActions  \n- (IBAction)submitData:(id)sender {}  \n#pragma mark - Public  \n- (void)publicMethod {}  \n#pragma mark - Private  \n- (void)privateMethod {}  \n#pragma mark - Protocol conformance  \n#pragma mark - UITextFieldDelegate  \n#pragma mark - UITableViewDataSource  \n#pragma mark - UITableViewDelegate  \n#pragma mark - NSCopying  \n- (id)copyWithZone:(NSZone *)zone {}  \n#pragma mark - NSObject  \n- (NSString *)description {}  \n</code></pre><h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><p>当需要注释时，注释应该用来解释这段特殊代码为什么要这样做。</p>\n<p>任何被使用的注释都必须保持最新或被删除。</p>\n<p>一般都避免使用块注释，因为代码尽可能做到自解释，只有当断断续续或几行代码时才需要注释。</p>\n<p>例外：这不应用在生成文档的注释</p>\n<h2 id=\"字面量\"><a href=\"#字面量\" class=\"headerlink\" title=\"字面量\"></a>字面量</h2><p>NSString、NSDictionary、NSArray和NSNumber的字面值，应该在创建这些类的不可变实例时被使用。</p>\n<p>请特别注意—nil值不能传入NSArray和NSDictionary字面值，因为这样会导致crash。</p>\n<p>推荐<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *names = @[<span class=\"string\">@\"Brian\"</span>, <span class=\"string\">@\"Matt\"</span>, <span class=\"string\">@\"Chris\"</span>, <span class=\"string\">@\"Alex\"</span>, <span class=\"string\">@\"Steve\"</span>, <span class=\"string\">@\"Paul\"</span>];  </span><br><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *productManagers = @&#123;<span class=\"string\">@\"iPhone\"</span>: <span class=\"string\">@\"Kate\"</span>, <span class=\"string\">@\"iPad\"</span>: <span class=\"string\">@\"Kamal\"</span>, <span class=\"string\">@\"Mobile Web\"</span>: <span class=\"string\">@\"Bill\"</span>&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *shouldUseLiterals = @YES;  </span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *buildingStreetNumber = @<span class=\"number\">10018</span>;</span><br></pre></td></tr></table></figure></p>\n<p>不推荐</p>\n<pre><code>NSArray *names = [NSArray arrayWithObjects:@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;, nil];  \nNSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @&quot;Kate&quot;, @&quot;iPhone&quot;, @&quot;Kamal&quot;, @&quot;iPad&quot;, @&quot;Bill&quot;, @&quot;Mobile Web&quot;, nil];  \nNSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];  \nNSNumber *buildingStreetNumber = [NSNumber numberWithInteger:10018]; \n</code></pre><h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h3 id=\"实例变量\"><a href=\"#实例变量\" class=\"headerlink\" title=\"实例变量\"></a>实例变量</h3><p>实例变量，应该在实现文件.m中声明。</p>\n<p>如果一定要直接在.h文件声明，加上@priavte，另外，使用@private、@public，前面需要一个缩进空格。</p>\n<p>一般以@property形式，在.h文件中声明。</p>\n<blockquote>\n<p>推荐多用属性，并且避免直接访问实例变量。</p>\n</blockquote>\n<p>PS:尽可能保证 .h文件的简洁性，可以不公开的API就不要公开了，写在实现文件中即可。</p>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><p>用@property声明属性后，默认的实例变量名称是</p>\n<pre><code>_variableName。\n</code></pre><p>在.m实现文件中，可以用@synthesize,改变实例变量名称</p>\n<pre><code>@synthessize variableName=goodVariableName\n</code></pre><p>如果你使用 @synthesize 关键字时，不去指明实例变量的名字的话，像下面这样：</p>\n<pre><code>@synthesize firstName;\n</code></pre><p>那么实例变量将会被命成与属性一样的名字。 在这个例子中，实例变量将会被命名为 firstName ,并且不会加上下划线前缀。</p>\n<h4 id=\"属性特性\"><a href=\"#属性特性\" class=\"headerlink\" title=\"属性特性\"></a>属性特性</h4><p>所有属性特性应该显式地列出来，有助于阅读代码。</p>\n<p>顺序与在Interface Builder连接UI元素时自动生成代码一致。</p>\n<p>属性特性的顺序，应该是</p>\n<blockquote>\n<p>1.原子性:atomic,nonatomic</p>\n<p>2.读写:readonly,readwrite</p>\n<p>3.内存管理：weak,strong,copy。</p>\n</blockquote>\n<ul>\n<li><p>属性可以存储一个代码块。为了让它存活到定义的块的结束，必须使用 copy （block 最早在栈里面创建，使用 copy让 block 拷贝到堆里面去）</p>\n</li>\n<li><p>你必须使用 nonatomic，除非特别需要的情况。在iOS中，atomic带来的锁特别影响性能。</p>\n</li>\n<li><p>对于非可变类（比如NSString,NSArray），通常使用copy修饰。</p>\n</li>\n<li><p>对于一个外部引用对象，且外部不会发生set操作的对象，使用readonly属性。比如在创建界面元素的时候:</p>\n<pre><code>@interface BWView : UIView\n@property (nonatomic, strong, readonly) UIView* backgroundView;\n@end\n@implementation BWView\n@end\n</code></pre></li>\n</ul>\n<p>readonly 表明其不能修改只能读取，在这种情况下编译器将会合成一个名为backgroundView getter方法，而不是一个setBackgroundView方法。</p>\n<ul>\n<li><p>为了完成一个共有的 getter 和一个私有的 setter，你应该声明公开的属性为 readonly ,并且在类扩展中重新定义通用的属性为 readwrite 的。</p>\n<pre><code>//.h文件中\n@interface MyClass : NSObject\n@property (nonatomic, readonly, strong) NSObject *object;\n@end\n//.m文件中\n@interface MyClass ()\n@property (nonatomic, readwrite, strong) NSObject *object;\n@end\n\n@implementation MyClass\n//Do Something cool\n@end\n</code></pre></li>\n</ul>\n<h3 id=\"可变对象\"><a href=\"#可变对象\" class=\"headerlink\" title=\"可变对象\"></a>可变对象</h3><p>任何可以用一个可变的对象设置的(比如 NSString,NSArray,NSURLRequest)属性,它的内存管理类型必须是 copy 的。</p>\n<p>这是为了防止在不明确的情况下，修改被封装好的对象的值。</p>\n<blockquote>\n<p>例如：array定义为 copy 的 NSArray 实例，当执行 array= mutableArray，copy 属性会让 array 的 setter 方法为 array = [mutableArray copy], [mutableArray copy] 返回的是不可变的 NSArray 实例，就保证了正确性。</p>\n<p>用其他属性修饰符修饰，容易在直接赋值的时候，array 指向的是 NSMuatbleArray 的实例，在之后可以随意改变它的值，就容易出错。</p>\n</blockquote>\n<p>同时，应该避免在公开的接口中，暴露可变的对象。</p>\n<p>因为这允许你的类的使用者，改变类自己的内部表示，并且破坏类的封装。你可以提供只读的属性，来返回你对象的不可变的副本。如：</p>\n<pre><code>/* .h */\n@property (nonatomic, readonly) NSArray *elements\n\n/* .m */\n- (NSArray *)elements {\n  return [self.mutableElements copy];\n}\n</code></pre><h4 id=\"私有属性\"><a href=\"#私有属性\" class=\"headerlink\" title=\"私有属性\"></a>私有属性</h4><p>私有属性应该定义在类的实现文件的类的扩展 (匿名的 category) 中。不允许在有名字的 category(如 ZOCPrivate）中定义私有属性，除非你扩展其他类。</p>\n<p>推荐</p>\n<pre><code>@interface RWTDetailViewController ()  \n@property (strong, nonatomic) GADBannerView *googleAdView;  \n@property (strong, nonatomic) ADBannerView *iAdView;  \n@property (strong, nonatomic) UIWebView *adXWebView;  \n@end\n</code></pre><h2 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h2><h4 id=\"常量使用\"><a href=\"#常量使用\" class=\"headerlink\" title=\"常量使用\"></a>常量使用</h4><p>常量是容易重复被使用，和无需通过查找和代替就能快速修改值的。</p>\n<p>常量应该使用static来声明，而不是使用#define，除非显式地使用宏<br>所有的单词首字母大写，和加上与类名有关的前缀</p>\n<p>推荐</p>\n<pre><code>static NSString * const RWTAboutViewControllerCompanyName = @&quot;RayWenderlich.com&quot;;  \nstatic CGFloat const RWTImageThumbnailHeight = 50.0;  \n</code></pre><p>不推荐</p>\n<pre><code>#define CompanyName @&quot;RayWenderlich.com&quot;  \n#define thumbnailHeight 2  \n</code></pre><h3 id=\"常量小写k开头\"><a href=\"#常量小写k开头\" class=\"headerlink\" title=\"常量小写k开头\"></a>常量小写k开头</h3><p>常量以小写字母k开头，后续首字母大写</p>\n<pre><code>static NSString* const kBWBarTitle = @&quot;动态&quot;;\n</code></pre><h3 id=\"常量应该使用驼峰式命名规则。\"><a href=\"#常量应该使用驼峰式命名规则。\" class=\"headerlink\" title=\"常量应该使用驼峰式命名规则。\"></a>常量应该使用驼峰式命名规则。</h3><p>推荐</p>\n<pre><code>static NSTimeInterval const RWTTutorialViewControllerNavigationFadeAnimationDuration = 0.3;  \n</code></pre><p>不推荐</p>\n<pre><code>static NSTimeInterval const fadetime = 1.7;  \n</code></pre><p>。</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"方法参数名\"><a href=\"#方法参数名\" class=\"headerlink\" title=\"方法参数名\"></a>方法参数名</h3><p>方法参数名前，一般使用的前缀</p>\n<blockquote>\n<p>the,an,new,a</p>\n</blockquote>\n<pre><code>- (void)setTitle:(NSString *)aTitle;\n- (void)setName:(NSString *)newName;\n- (id)keyForOption:(CDCOption *)anOption\n- (NSArray *)emailsForMailbox:(CDCMailbox *)theMailbox;\n- (CDCEmail *)emailForRecipients:(NSArray *)    theRecipients;\n</code></pre><h3 id=\"“and”这个词的用法应该保留\"><a href=\"#“and”这个词的用法应该保留\" class=\"headerlink\" title=\"“and”这个词的用法应该保留\"></a>“and”这个词的用法应该保留</h3><p>”and“不应该用于多个参数来说明，就像initWithWidth:height以下这个例子.</p>\n<p>推荐</p>\n<pre><code>- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height;  \n</code></pre><p>不推荐</p>\n<pre><code>- (instancetype)initWith:(int)width and:(int)height;  // Never do this.  \n</code></pre><h3 id=\"方法长度\"><a href=\"#方法长度\" class=\"headerlink\" title=\"方法长度\"></a>方法长度</h3><p>函数长度不要超过50行，小函数要比大函数可阅读性和可复用性强。</p>\n<p>零元函数最好，一元函数也不错，二元函数担心了，三元函数有风险，高于三元需重构。函数的参数越多，引起其变化的因素就越多。越不利于以后的修改。</p>\n<h3 id=\"避免出现火车链式的情况\"><a href=\"#避免出现火车链式的情况\" class=\"headerlink\" title=\"避免出现火车链式的情况\"></a>避免出现火车链式的情况</h3><p>推荐</p>\n<pre><code>BWAppSetting* shareSetting = [BWAppSetting GetInstance];\nBWLockDictionary* defaultSettings = [shareSetting appSetting];\n_needLogoutAccount = [[defaultSettings valueForKeyPath:NeedLogoutAccounts] retain];\n</code></pre><p>不推荐</p>\n<pre><code>_needLogoutAccount = [[[[BWAppSetting GetInstance] appSetting] valueForKey:NeedLogoutAccounts] retain];\n</code></pre><h3 id=\"取值方法\"><a href=\"#取值方法\" class=\"headerlink\" title=\"取值方法\"></a>取值方法</h3><ul>\n<li>取值方法前，不要加前缀“get”。</li>\n<li><p>如果BOOL属性的名字是一个形容词，属性就能忽略”is”前缀，但要指定get访问器的惯用名称。例如：</p>\n<pre><code>@property (assign, getter=isEditable) BOOL editable;\n</code></pre></li>\n</ul>\n<h3 id=\"方法调用\"><a href=\"#方法调用\" class=\"headerlink\" title=\"方法调用\"></a>方法调用</h3><p>属性和幂等方法，推荐使用点标记语法访问。</p>\n<p>其他情况，使用方括号标记语法。</p>\n<p>推荐</p>\n<pre><code>view.backgroundColor = [UIColor orangeColor];\n[UIApplication sharedApplication].delegate;\n</code></pre><p>不推荐</p>\n<pre><code>[view setBackgroundColor:[UIColor orangeColor]];\nUIApplication.sharedApplication.delegate;\n</code></pre><h2 id=\"委托代理模式\"><a href=\"#委托代理模式\" class=\"headerlink\" title=\"委托代理模式\"></a>委托代理模式</h2><h3 id=\"区分delegate和datasource\"><a href=\"#区分delegate和datasource\" class=\"headerlink\" title=\"区分delegate和datasource\"></a>区分delegate和datasource</h3><p>委托模式(delegate pattern)：事件发生的时候，委托者需要通知代理者。</p>\n<p>数据源模式(datasource pattern): 委托者需要从数据源对象拉取数据。</p>\n<p>重点:数据源模式，会要求数据源的对象来实现对应方法，达到委托者本身获取数据的目标。</p>\n<pre><code>@class ZOCSignUpViewController;\n//Delegate\n@protocol ZOCSignUpViewControllerDelegate &lt;NSObject&gt;\n- (void)signUpViewControllerDidPressSignUpButton:(ZOCSignUpViewController *)controller;\n@end\n//DataSource\n@protocol ZOCSignUpViewControllerDataSource &lt;NSObject&gt;\n- (ZOCUserCredentials *)credentialsForSignUpViewController:(ZOCSignUpViewController *)controller;\n@end\n\n\n@interface ZOCSignUpViewController : UIViewController\n\n@property (nonatomic, weak) id&lt;ZOCSignUpViewControllerDelegate&gt; delegate;\n@property (nonatomic, weak) id&lt;ZOCSignUpViewControllerDataSource&gt; dataSource;\n\n@end\n</code></pre><p>PS：</p>\n<ul>\n<li><p>Protocol单独用一个文件来创建。尽量不要与相关类混在一个文件中。</p>\n</li>\n<li><p>写delegate的时候类型应该为weak弱引用，以避免循环引用。</p>\n</li>\n</ul>\n<p>当delegate对象不存在后，我们写的delegate也就没有存在意义了自然是需要销毁的</p>\n<pre><code>@property(nonatomic,weak) id&lt;viewControllerDelegate&gt; delegat;\n</code></pre><h2 id=\"Block\"><a href=\"#Block\" class=\"headerlink\" title=\"Block\"></a>Block</h2><p>Block 是 Objective-C 版本的 lambda 或者 closure（闭包）。</p>\n<p>当使用代码块和异步分发的时候，要注意避免引用循环。在block中使用到self变量的时候，一定要先weak再strong.</p>\n<p>推荐</p>\n<pre><code>__weak typeof(self) weakSelf = self;\n[self doABlockOperation:^{\n__strong typeof(weakSelf) strongSelf = weakSelf;\nif (strongSelf) {\n    ...\n}\n}];\n</code></pre><p>不推荐</p>\n<pre><code>[self executeBlock:^(NSData *data, NSError *error) {\n[self doSomethingWithData:data];\n}];\n</code></pre><h2 id=\"控制结构\"><a href=\"#控制结构\" class=\"headerlink\" title=\"控制结构\"></a>控制结构</h2><h3 id=\"分支结构\"><a href=\"#分支结构\" class=\"headerlink\" title=\"分支结构\"></a>分支结构</h3><p>当需要满足一定条件时才执行某项操作时，最左边缘应该是愉快路径代码。不要将愉快路径代码内嵌到if语句中。多个return是正常合理的。</p>\n<p>推荐</p>\n<pre><code>- (void) someMethod {\nif (![someOther boolValue]) {\n  return;\n  }\n  //Do something important\n}\n</code></pre><p>不推荐</p>\n<pre><code>- (void) someMethod {\n  if ([someOther boolValue]) {\n      //Do something important\n  }\n}\n</code></pre><h3 id=\"循环结构\"><a href=\"#循环结构\" class=\"headerlink\" title=\"循环结构\"></a>循环结构</h3><p>遍历可变容器(容器:如数组，字典等)，应该复制该容器，使用copy。</p>\n<pre><code>NSArray *Arrays=[self.multableArray copy];\nfor(id obj in Arrays){\n//do something\n}\n</code></pre><p>尽量不要使用异常，尤其是不要将异常做为业务逻辑的一部分，在异常中尝试进行灾难恢复。</p>\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><h3 id=\"保持公共API简单\"><a href=\"#保持公共API简单\" class=\"headerlink\" title=\"保持公共API简单\"></a>保持公共API简单</h3><p> 其实也就说，保持.h文件的整洁和干净。</p>\n<p> 避免 “厨房水槽（kitchen-sink）” 式的 API。如果一个函数压根没必要公开，就不要这么做。用私有类别，保证公共头文件整洁。”</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>保持init函数简洁，不要让init函数成为千行的大函数，当超过50行的时候，适当考虑分拆一下。</p>\n<p>良好风格实例：</p>\n<pre><code>- (void) commonInit\n{\n_rightAppendImageView = [UIImageView new];\n[self.contentView addSubview:_rightAppendImageView];\n}\n- (instancetype) initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier\n{\nself = [super initWithStyle:style reuseIdentifier:reuseIdentifier];\nif (!self) {\n    return self;\n}\n[self commonInit];\nreturn self;\n}\n</code></pre><h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h3><p>Objective-C使用YES和NO。</p>\n<p>因为true和false应该只在CoreFoundation，C或C++代码使用。</p>\n<p>既然nil解析成NO，所以没有必要在条件语句比较。</p>\n<p>不要拿某样东西直接与YES比较，因为当YES被定义为1和一个BOOL会被设置为8位。</p>\n<p>推荐</p>\n<pre><code>if (someObject) {}  \nif (![anotherObject boolValue]) {}  \n</code></pre><p>不推荐</p>\n<pre><code>if (someObject == nil) {}  \nif ([anotherObject boolValue] == NO) {}  \nif (isAwesome == YES) {} // Never do this.  \nif (isAwesome == true) {} // Never do this.  \n</code></pre><p>###尽量不要在界面布局的写任何死数字</p>\n<p>推荐</p>\n<pre><code>CGFloat cellHeight = CGRectGetHeight(self.frame);\nCGFloat cellWidth = CGRectGetWidth(self.frame);\nCGRect numFrame = CGRectZero;\nnumFrame.size = CGSizeMake(cellWidth,cellHeight);\n</code></pre><p>不推荐</p>\n<pre><code>CGFloat delta = SYSTEM_VERSION &gt;= 7.0 ? 0.0f : -14.0f;\nnewFrame = CGRectMake(245 + delta,\n                          (self.frame.size.height - tipNewSize.height)/2,\n                          tipNewSize.width,\n                          tipNewSize.height);\ndotFrame = CGRectMake(258.0 + delta,  (self.frame.size.height - tipDotSize.height)/2,\n                          tipDotSize.width,\n                          tipDotSize.height);\niconFrame = CGRectMake(245 + delta,\n                           (self.frame.size.height - tipIconSize.height)/2,\n                           tipIconSize.width,\n                           tipIconSize.height);\nnumFrame = CGRectMake(245+delta, (self.frame.size.height - tipNumSize.height)/2, tipNumSize.width, tipNumSize.height);\n</code></pre><h2 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h2><p>PS：使用设计模式的最基本原则—-</p>\n<blockquote>\n<p>除非你明确知道自己要做件什么事情，而且知道使用特定设计模式带来的影响.</p>\n<p>否则，不要刻意的使用设计模式。</p>\n</blockquote>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><p>如果可能，请尽量避免使用单例而是依赖注入。 然而，如果一定要用，请使用一个线程安全的模式来创建共享的实例。对于 GCD，用 dispatch_once() 函数就可以咯。</p>\n<pre><code>+ (instancetype)sharedInstance {  \n      static id sharedInstance = nil;  \n       static dispatch_once_t onceToken=0;  \n      dispatch_once(&amp;onceToken, ^{  \n    sharedInstance = [[self alloc] init];  \n      });  \n      return sharedInstance;  \n}  \n</code></pre><p>使用 dispatch_once()，来控制代码同步，取代了原来的约定俗成的用法。</p>\n<pre><code>+ (instancetype)sharedInstance\n{\nstatic id sharedInstance;\n@synchronized(self) {\n    if (sharedInstance == nil) {\n        sharedInstance = [[MyClass alloc] init];\n    }\n}\nreturn sharedInstance;\n}\n</code></pre><p>dispatch_once() 的优点是，它更快，而且语法上更干净，因为dispatch_once()的意思就是 “把一些东西执行一次”，就像我们做的一样。</p>\n<p>同时，这可以防止<a href=\"http://cocoasamurai.blogspot.com/2011/04/singletons-your-doing-them-wrong.html\" target=\"_blank\" rel=\"external\">possible and sometimes prolific crashes</a>。</p>\n<h3 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h3><p>如果只是单纯的传递数据，不要使用观察者模式，容易导致逻辑链断裂。</p>\n<blockquote>\n<p>参考</p>\n<p><a href=\"https://github.com/oa414/objc-zen-book-cn/#%E9%BB%84%E9%87%91%E5%A4%A7%E9%81%93\" target=\"_blank\" rel=\"external\">禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译）</a></p>\n<p><a href=\"http://wiki.jikexueyuan.com/project/programming-with-objective-c/encapsulating-data.html\" target=\"_blank\" rel=\"external\">programming with objective-c</a></p>\n<p><a href=\"http://www.cocoachina.com/ios/20140520/8484.html\" target=\"_blank\" rel=\"external\">Object-C代码规范</a></p>\n<p><a href=\"http://www.cocoachina.com/ios/20151118/14242.html\" target=\"_blank\" rel=\"external\">Objective-C 编码建议</a></p>\n<p><a href=\"http://www.csdn.net/article/2015-06-01/2824818-objective-c-style-guide/1\" target=\"_blank\" rel=\"external\">Objective-C编码规范：26个方面解决iOS开发问题</a></p>\n<p>《iOS6编程实战》 人民邮电出版社</p>\n</blockquote>\n","more":"<p>首先要说明的是，命名的最大规则是可读的，清晰的。</p>\n<p>其次，才考虑如何简洁的命名。</p>\n<h2 id=\"代码组织\"><a href=\"#代码组织\" class=\"headerlink\" title=\"代码组织\"></a>代码组织</h2><p>在函数分组和protocol/delegate实现中使用#pragma mark -来分类方法，要遵循以下一般结构：</p>\n<pre><code>#pragma mark - Lifecycle（View 的生命周期）  \n- (instancetype)init {}  \n- (void)dealloc {}  \n- (void)viewDidLoad {}  \n- (void)viewWillAppear:(BOOL)animated {}  \n- (void)didReceiveMemoryWarning {}  \n#pragma mark - Custom Accessors  （自定义访问器）\n- (void)setCustomProperty:(id)value {}  \n- (id)customProperty {}  \n#pragma mark - IBActions  \n- (IBAction)submitData:(id)sender {}  \n#pragma mark - Public  \n- (void)publicMethod {}  \n#pragma mark - Private  \n- (void)privateMethod {}  \n#pragma mark - Protocol conformance  \n#pragma mark - UITextFieldDelegate  \n#pragma mark - UITableViewDataSource  \n#pragma mark - UITableViewDelegate  \n#pragma mark - NSCopying  \n- (id)copyWithZone:(NSZone *)zone {}  \n#pragma mark - NSObject  \n- (NSString *)description {}  \n</code></pre><h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><p>当需要注释时，注释应该用来解释这段特殊代码为什么要这样做。</p>\n<p>任何被使用的注释都必须保持最新或被删除。</p>\n<p>一般都避免使用块注释，因为代码尽可能做到自解释，只有当断断续续或几行代码时才需要注释。</p>\n<p>例外：这不应用在生成文档的注释</p>\n<h2 id=\"字面量\"><a href=\"#字面量\" class=\"headerlink\" title=\"字面量\"></a>字面量</h2><p>NSString、NSDictionary、NSArray和NSNumber的字面值，应该在创建这些类的不可变实例时被使用。</p>\n<p>请特别注意—nil值不能传入NSArray和NSDictionary字面值，因为这样会导致crash。</p>\n<p>推荐<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *names = @[<span class=\"string\">@\"Brian\"</span>, <span class=\"string\">@\"Matt\"</span>, <span class=\"string\">@\"Chris\"</span>, <span class=\"string\">@\"Alex\"</span>, <span class=\"string\">@\"Steve\"</span>, <span class=\"string\">@\"Paul\"</span>];  </span><br><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *productManagers = @&#123;<span class=\"string\">@\"iPhone\"</span>: <span class=\"string\">@\"Kate\"</span>, <span class=\"string\">@\"iPad\"</span>: <span class=\"string\">@\"Kamal\"</span>, <span class=\"string\">@\"Mobile Web\"</span>: <span class=\"string\">@\"Bill\"</span>&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *shouldUseLiterals = @YES;  </span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *buildingStreetNumber = @<span class=\"number\">10018</span>;</span><br></pre></td></tr></table></figure></p>\n<p>不推荐</p>\n<pre><code>NSArray *names = [NSArray arrayWithObjects:@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;, nil];  \nNSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @&quot;Kate&quot;, @&quot;iPhone&quot;, @&quot;Kamal&quot;, @&quot;iPad&quot;, @&quot;Bill&quot;, @&quot;Mobile Web&quot;, nil];  \nNSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];  \nNSNumber *buildingStreetNumber = [NSNumber numberWithInteger:10018]; \n</code></pre><h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h3 id=\"实例变量\"><a href=\"#实例变量\" class=\"headerlink\" title=\"实例变量\"></a>实例变量</h3><p>实例变量，应该在实现文件.m中声明。</p>\n<p>如果一定要直接在.h文件声明，加上@priavte，另外，使用@private、@public，前面需要一个缩进空格。</p>\n<p>一般以@property形式，在.h文件中声明。</p>\n<blockquote>\n<p>推荐多用属性，并且避免直接访问实例变量。</p>\n</blockquote>\n<p>PS:尽可能保证 .h文件的简洁性，可以不公开的API就不要公开了，写在实现文件中即可。</p>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><p>用@property声明属性后，默认的实例变量名称是</p>\n<pre><code>_variableName。\n</code></pre><p>在.m实现文件中，可以用@synthesize,改变实例变量名称</p>\n<pre><code>@synthessize variableName=goodVariableName\n</code></pre><p>如果你使用 @synthesize 关键字时，不去指明实例变量的名字的话，像下面这样：</p>\n<pre><code>@synthesize firstName;\n</code></pre><p>那么实例变量将会被命成与属性一样的名字。 在这个例子中，实例变量将会被命名为 firstName ,并且不会加上下划线前缀。</p>\n<h4 id=\"属性特性\"><a href=\"#属性特性\" class=\"headerlink\" title=\"属性特性\"></a>属性特性</h4><p>所有属性特性应该显式地列出来，有助于阅读代码。</p>\n<p>顺序与在Interface Builder连接UI元素时自动生成代码一致。</p>\n<p>属性特性的顺序，应该是</p>\n<blockquote>\n<p>1.原子性:atomic,nonatomic</p>\n<p>2.读写:readonly,readwrite</p>\n<p>3.内存管理：weak,strong,copy。</p>\n</blockquote>\n<ul>\n<li><p>属性可以存储一个代码块。为了让它存活到定义的块的结束，必须使用 copy （block 最早在栈里面创建，使用 copy让 block 拷贝到堆里面去）</p>\n</li>\n<li><p>你必须使用 nonatomic，除非特别需要的情况。在iOS中，atomic带来的锁特别影响性能。</p>\n</li>\n<li><p>对于非可变类（比如NSString,NSArray），通常使用copy修饰。</p>\n</li>\n<li><p>对于一个外部引用对象，且外部不会发生set操作的对象，使用readonly属性。比如在创建界面元素的时候:</p>\n<pre><code>@interface BWView : UIView\n@property (nonatomic, strong, readonly) UIView* backgroundView;\n@end\n@implementation BWView\n@end\n</code></pre></li>\n</ul>\n<p>readonly 表明其不能修改只能读取，在这种情况下编译器将会合成一个名为backgroundView getter方法，而不是一个setBackgroundView方法。</p>\n<ul>\n<li><p>为了完成一个共有的 getter 和一个私有的 setter，你应该声明公开的属性为 readonly ,并且在类扩展中重新定义通用的属性为 readwrite 的。</p>\n<pre><code>//.h文件中\n@interface MyClass : NSObject\n@property (nonatomic, readonly, strong) NSObject *object;\n@end\n//.m文件中\n@interface MyClass ()\n@property (nonatomic, readwrite, strong) NSObject *object;\n@end\n\n@implementation MyClass\n//Do Something cool\n@end\n</code></pre></li>\n</ul>\n<h3 id=\"可变对象\"><a href=\"#可变对象\" class=\"headerlink\" title=\"可变对象\"></a>可变对象</h3><p>任何可以用一个可变的对象设置的(比如 NSString,NSArray,NSURLRequest)属性,它的内存管理类型必须是 copy 的。</p>\n<p>这是为了防止在不明确的情况下，修改被封装好的对象的值。</p>\n<blockquote>\n<p>例如：array定义为 copy 的 NSArray 实例，当执行 array= mutableArray，copy 属性会让 array 的 setter 方法为 array = [mutableArray copy], [mutableArray copy] 返回的是不可变的 NSArray 实例，就保证了正确性。</p>\n<p>用其他属性修饰符修饰，容易在直接赋值的时候，array 指向的是 NSMuatbleArray 的实例，在之后可以随意改变它的值，就容易出错。</p>\n</blockquote>\n<p>同时，应该避免在公开的接口中，暴露可变的对象。</p>\n<p>因为这允许你的类的使用者，改变类自己的内部表示，并且破坏类的封装。你可以提供只读的属性，来返回你对象的不可变的副本。如：</p>\n<pre><code>/* .h */\n@property (nonatomic, readonly) NSArray *elements\n\n/* .m */\n- (NSArray *)elements {\n  return [self.mutableElements copy];\n}\n</code></pre><h4 id=\"私有属性\"><a href=\"#私有属性\" class=\"headerlink\" title=\"私有属性\"></a>私有属性</h4><p>私有属性应该定义在类的实现文件的类的扩展 (匿名的 category) 中。不允许在有名字的 category(如 ZOCPrivate）中定义私有属性，除非你扩展其他类。</p>\n<p>推荐</p>\n<pre><code>@interface RWTDetailViewController ()  \n@property (strong, nonatomic) GADBannerView *googleAdView;  \n@property (strong, nonatomic) ADBannerView *iAdView;  \n@property (strong, nonatomic) UIWebView *adXWebView;  \n@end\n</code></pre><h2 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h2><h4 id=\"常量使用\"><a href=\"#常量使用\" class=\"headerlink\" title=\"常量使用\"></a>常量使用</h4><p>常量是容易重复被使用，和无需通过查找和代替就能快速修改值的。</p>\n<p>常量应该使用static来声明，而不是使用#define，除非显式地使用宏<br>所有的单词首字母大写，和加上与类名有关的前缀</p>\n<p>推荐</p>\n<pre><code>static NSString * const RWTAboutViewControllerCompanyName = @&quot;RayWenderlich.com&quot;;  \nstatic CGFloat const RWTImageThumbnailHeight = 50.0;  \n</code></pre><p>不推荐</p>\n<pre><code>#define CompanyName @&quot;RayWenderlich.com&quot;  \n#define thumbnailHeight 2  \n</code></pre><h3 id=\"常量小写k开头\"><a href=\"#常量小写k开头\" class=\"headerlink\" title=\"常量小写k开头\"></a>常量小写k开头</h3><p>常量以小写字母k开头，后续首字母大写</p>\n<pre><code>static NSString* const kBWBarTitle = @&quot;动态&quot;;\n</code></pre><h3 id=\"常量应该使用驼峰式命名规则。\"><a href=\"#常量应该使用驼峰式命名规则。\" class=\"headerlink\" title=\"常量应该使用驼峰式命名规则。\"></a>常量应该使用驼峰式命名规则。</h3><p>推荐</p>\n<pre><code>static NSTimeInterval const RWTTutorialViewControllerNavigationFadeAnimationDuration = 0.3;  \n</code></pre><p>不推荐</p>\n<pre><code>static NSTimeInterval const fadetime = 1.7;  \n</code></pre><p>。</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"方法参数名\"><a href=\"#方法参数名\" class=\"headerlink\" title=\"方法参数名\"></a>方法参数名</h3><p>方法参数名前，一般使用的前缀</p>\n<blockquote>\n<p>the,an,new,a</p>\n</blockquote>\n<pre><code>- (void)setTitle:(NSString *)aTitle;\n- (void)setName:(NSString *)newName;\n- (id)keyForOption:(CDCOption *)anOption\n- (NSArray *)emailsForMailbox:(CDCMailbox *)theMailbox;\n- (CDCEmail *)emailForRecipients:(NSArray *)    theRecipients;\n</code></pre><h3 id=\"“and”这个词的用法应该保留\"><a href=\"#“and”这个词的用法应该保留\" class=\"headerlink\" title=\"“and”这个词的用法应该保留\"></a>“and”这个词的用法应该保留</h3><p>”and“不应该用于多个参数来说明，就像initWithWidth:height以下这个例子.</p>\n<p>推荐</p>\n<pre><code>- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height;  \n</code></pre><p>不推荐</p>\n<pre><code>- (instancetype)initWith:(int)width and:(int)height;  // Never do this.  \n</code></pre><h3 id=\"方法长度\"><a href=\"#方法长度\" class=\"headerlink\" title=\"方法长度\"></a>方法长度</h3><p>函数长度不要超过50行，小函数要比大函数可阅读性和可复用性强。</p>\n<p>零元函数最好，一元函数也不错，二元函数担心了，三元函数有风险，高于三元需重构。函数的参数越多，引起其变化的因素就越多。越不利于以后的修改。</p>\n<h3 id=\"避免出现火车链式的情况\"><a href=\"#避免出现火车链式的情况\" class=\"headerlink\" title=\"避免出现火车链式的情况\"></a>避免出现火车链式的情况</h3><p>推荐</p>\n<pre><code>BWAppSetting* shareSetting = [BWAppSetting GetInstance];\nBWLockDictionary* defaultSettings = [shareSetting appSetting];\n_needLogoutAccount = [[defaultSettings valueForKeyPath:NeedLogoutAccounts] retain];\n</code></pre><p>不推荐</p>\n<pre><code>_needLogoutAccount = [[[[BWAppSetting GetInstance] appSetting] valueForKey:NeedLogoutAccounts] retain];\n</code></pre><h3 id=\"取值方法\"><a href=\"#取值方法\" class=\"headerlink\" title=\"取值方法\"></a>取值方法</h3><ul>\n<li>取值方法前，不要加前缀“get”。</li>\n<li><p>如果BOOL属性的名字是一个形容词，属性就能忽略”is”前缀，但要指定get访问器的惯用名称。例如：</p>\n<pre><code>@property (assign, getter=isEditable) BOOL editable;\n</code></pre></li>\n</ul>\n<h3 id=\"方法调用\"><a href=\"#方法调用\" class=\"headerlink\" title=\"方法调用\"></a>方法调用</h3><p>属性和幂等方法，推荐使用点标记语法访问。</p>\n<p>其他情况，使用方括号标记语法。</p>\n<p>推荐</p>\n<pre><code>view.backgroundColor = [UIColor orangeColor];\n[UIApplication sharedApplication].delegate;\n</code></pre><p>不推荐</p>\n<pre><code>[view setBackgroundColor:[UIColor orangeColor]];\nUIApplication.sharedApplication.delegate;\n</code></pre><h2 id=\"委托代理模式\"><a href=\"#委托代理模式\" class=\"headerlink\" title=\"委托代理模式\"></a>委托代理模式</h2><h3 id=\"区分delegate和datasource\"><a href=\"#区分delegate和datasource\" class=\"headerlink\" title=\"区分delegate和datasource\"></a>区分delegate和datasource</h3><p>委托模式(delegate pattern)：事件发生的时候，委托者需要通知代理者。</p>\n<p>数据源模式(datasource pattern): 委托者需要从数据源对象拉取数据。</p>\n<p>重点:数据源模式，会要求数据源的对象来实现对应方法，达到委托者本身获取数据的目标。</p>\n<pre><code>@class ZOCSignUpViewController;\n//Delegate\n@protocol ZOCSignUpViewControllerDelegate &lt;NSObject&gt;\n- (void)signUpViewControllerDidPressSignUpButton:(ZOCSignUpViewController *)controller;\n@end\n//DataSource\n@protocol ZOCSignUpViewControllerDataSource &lt;NSObject&gt;\n- (ZOCUserCredentials *)credentialsForSignUpViewController:(ZOCSignUpViewController *)controller;\n@end\n\n\n@interface ZOCSignUpViewController : UIViewController\n\n@property (nonatomic, weak) id&lt;ZOCSignUpViewControllerDelegate&gt; delegate;\n@property (nonatomic, weak) id&lt;ZOCSignUpViewControllerDataSource&gt; dataSource;\n\n@end\n</code></pre><p>PS：</p>\n<ul>\n<li><p>Protocol单独用一个文件来创建。尽量不要与相关类混在一个文件中。</p>\n</li>\n<li><p>写delegate的时候类型应该为weak弱引用，以避免循环引用。</p>\n</li>\n</ul>\n<p>当delegate对象不存在后，我们写的delegate也就没有存在意义了自然是需要销毁的</p>\n<pre><code>@property(nonatomic,weak) id&lt;viewControllerDelegate&gt; delegat;\n</code></pre><h2 id=\"Block\"><a href=\"#Block\" class=\"headerlink\" title=\"Block\"></a>Block</h2><p>Block 是 Objective-C 版本的 lambda 或者 closure（闭包）。</p>\n<p>当使用代码块和异步分发的时候，要注意避免引用循环。在block中使用到self变量的时候，一定要先weak再strong.</p>\n<p>推荐</p>\n<pre><code>__weak typeof(self) weakSelf = self;\n[self doABlockOperation:^{\n__strong typeof(weakSelf) strongSelf = weakSelf;\nif (strongSelf) {\n    ...\n}\n}];\n</code></pre><p>不推荐</p>\n<pre><code>[self executeBlock:^(NSData *data, NSError *error) {\n[self doSomethingWithData:data];\n}];\n</code></pre><h2 id=\"控制结构\"><a href=\"#控制结构\" class=\"headerlink\" title=\"控制结构\"></a>控制结构</h2><h3 id=\"分支结构\"><a href=\"#分支结构\" class=\"headerlink\" title=\"分支结构\"></a>分支结构</h3><p>当需要满足一定条件时才执行某项操作时，最左边缘应该是愉快路径代码。不要将愉快路径代码内嵌到if语句中。多个return是正常合理的。</p>\n<p>推荐</p>\n<pre><code>- (void) someMethod {\nif (![someOther boolValue]) {\n  return;\n  }\n  //Do something important\n}\n</code></pre><p>不推荐</p>\n<pre><code>- (void) someMethod {\n  if ([someOther boolValue]) {\n      //Do something important\n  }\n}\n</code></pre><h3 id=\"循环结构\"><a href=\"#循环结构\" class=\"headerlink\" title=\"循环结构\"></a>循环结构</h3><p>遍历可变容器(容器:如数组，字典等)，应该复制该容器，使用copy。</p>\n<pre><code>NSArray *Arrays=[self.multableArray copy];\nfor(id obj in Arrays){\n//do something\n}\n</code></pre><p>尽量不要使用异常，尤其是不要将异常做为业务逻辑的一部分，在异常中尝试进行灾难恢复。</p>\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><h3 id=\"保持公共API简单\"><a href=\"#保持公共API简单\" class=\"headerlink\" title=\"保持公共API简单\"></a>保持公共API简单</h3><p> 其实也就说，保持.h文件的整洁和干净。</p>\n<p> 避免 “厨房水槽（kitchen-sink）” 式的 API。如果一个函数压根没必要公开，就不要这么做。用私有类别，保证公共头文件整洁。”</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>保持init函数简洁，不要让init函数成为千行的大函数，当超过50行的时候，适当考虑分拆一下。</p>\n<p>良好风格实例：</p>\n<pre><code>- (void) commonInit\n{\n_rightAppendImageView = [UIImageView new];\n[self.contentView addSubview:_rightAppendImageView];\n}\n- (instancetype) initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier\n{\nself = [super initWithStyle:style reuseIdentifier:reuseIdentifier];\nif (!self) {\n    return self;\n}\n[self commonInit];\nreturn self;\n}\n</code></pre><h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h3><p>Objective-C使用YES和NO。</p>\n<p>因为true和false应该只在CoreFoundation，C或C++代码使用。</p>\n<p>既然nil解析成NO，所以没有必要在条件语句比较。</p>\n<p>不要拿某样东西直接与YES比较，因为当YES被定义为1和一个BOOL会被设置为8位。</p>\n<p>推荐</p>\n<pre><code>if (someObject) {}  \nif (![anotherObject boolValue]) {}  \n</code></pre><p>不推荐</p>\n<pre><code>if (someObject == nil) {}  \nif ([anotherObject boolValue] == NO) {}  \nif (isAwesome == YES) {} // Never do this.  \nif (isAwesome == true) {} // Never do this.  \n</code></pre><p>###尽量不要在界面布局的写任何死数字</p>\n<p>推荐</p>\n<pre><code>CGFloat cellHeight = CGRectGetHeight(self.frame);\nCGFloat cellWidth = CGRectGetWidth(self.frame);\nCGRect numFrame = CGRectZero;\nnumFrame.size = CGSizeMake(cellWidth,cellHeight);\n</code></pre><p>不推荐</p>\n<pre><code>CGFloat delta = SYSTEM_VERSION &gt;= 7.0 ? 0.0f : -14.0f;\nnewFrame = CGRectMake(245 + delta,\n                          (self.frame.size.height - tipNewSize.height)/2,\n                          tipNewSize.width,\n                          tipNewSize.height);\ndotFrame = CGRectMake(258.0 + delta,  (self.frame.size.height - tipDotSize.height)/2,\n                          tipDotSize.width,\n                          tipDotSize.height);\niconFrame = CGRectMake(245 + delta,\n                           (self.frame.size.height - tipIconSize.height)/2,\n                           tipIconSize.width,\n                           tipIconSize.height);\nnumFrame = CGRectMake(245+delta, (self.frame.size.height - tipNumSize.height)/2, tipNumSize.width, tipNumSize.height);\n</code></pre><h2 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h2><p>PS：使用设计模式的最基本原则—-</p>\n<blockquote>\n<p>除非你明确知道自己要做件什么事情，而且知道使用特定设计模式带来的影响.</p>\n<p>否则，不要刻意的使用设计模式。</p>\n</blockquote>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><p>如果可能，请尽量避免使用单例而是依赖注入。 然而，如果一定要用，请使用一个线程安全的模式来创建共享的实例。对于 GCD，用 dispatch_once() 函数就可以咯。</p>\n<pre><code>+ (instancetype)sharedInstance {  \n      static id sharedInstance = nil;  \n       static dispatch_once_t onceToken=0;  \n      dispatch_once(&amp;onceToken, ^{  \n    sharedInstance = [[self alloc] init];  \n      });  \n      return sharedInstance;  \n}  \n</code></pre><p>使用 dispatch_once()，来控制代码同步，取代了原来的约定俗成的用法。</p>\n<pre><code>+ (instancetype)sharedInstance\n{\nstatic id sharedInstance;\n@synchronized(self) {\n    if (sharedInstance == nil) {\n        sharedInstance = [[MyClass alloc] init];\n    }\n}\nreturn sharedInstance;\n}\n</code></pre><p>dispatch_once() 的优点是，它更快，而且语法上更干净，因为dispatch_once()的意思就是 “把一些东西执行一次”，就像我们做的一样。</p>\n<p>同时，这可以防止<a href=\"http://cocoasamurai.blogspot.com/2011/04/singletons-your-doing-them-wrong.html\">possible and sometimes prolific crashes</a>。</p>\n<h3 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h3><p>如果只是单纯的传递数据，不要使用观察者模式，容易导致逻辑链断裂。</p>\n<blockquote>\n<p>参考</p>\n<p><a href=\"https://github.com/oa414/objc-zen-book-cn/#%E9%BB%84%E9%87%91%E5%A4%A7%E9%81%93\">禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译）</a></p>\n<p><a href=\"http://wiki.jikexueyuan.com/project/programming-with-objective-c/encapsulating-data.html\">programming with objective-c</a></p>\n<p><a href=\"http://www.cocoachina.com/ios/20140520/8484.html\">Object-C代码规范</a></p>\n<p><a href=\"http://www.cocoachina.com/ios/20151118/14242.html\">Objective-C 编码建议</a></p>\n<p><a href=\"http://www.csdn.net/article/2015-06-01/2824818-objective-c-style-guide/1\">Objective-C编码规范：26个方面解决iOS开发问题</a></p>\n<p>《iOS6编程实战》 人民邮电出版社</p>\n</blockquote>\n"},{"layout":"post","title":"实习（一）","date":"2015-09-19T16:00:00.000Z","keywords":null,"description":"新博客的第一篇日志，之前做安卓的一些菜鸟日志在CSDN被人恶意删除，决心自己搭个窝","_content":"\n## 投简历\n9月6日开学，告别了家乡，我再次来到了学校。\n意识到大学一直没有实习的我，开始想要接触些工作。\n\n当天半夜的时候我上了拉勾网看了一下招聘，发现了现在实习的公司。\n离学校也近，最主要的是，接受实习生。虽然已经自学了一年的时间，但我知道这太不够了。\n\n在简历上的技能栏，我连熟悉都不敢写：\n\n?imageView2/2/w/350\n![](http://7xiym9.com1.z0.glb.clouddn.com/lagou.png)\n\n\n第二天，发现自己的简历通过了筛选.毕竟有过几个实战项目和专业获奖经历，也算是意料之中。隔了一天，周一下午接到公司的电话，问了一些情况，约定周二的下午去面试。\n\n坦白说，我高三跟着做过更新数字电视插口的工作，大一大二做过志愿者，甚至还面试过别人，还去学校电信网络维护做过。按理也应该有些经验，可我仍旧感觉到紧张。\n\n害怕的是，自己的所学，经不起社会的检验。\n\n##面试\n鑫鑫知道我要去面试，我说不必了。她却要陪着我，等着我面试完再一起回去。\n\n我心里很感动。\n\n我们怕找不到路，提前了大半个小时先去看了地方。一直走到门口确认之后，才放心。\n\n对正式的约定不迟到，应该是基本的礼节。\n\n然后找了个和咖啡的小店，让她坐着看kindle,我就独自过去了。\n\n到了说好的时间，打了严哥的电话(严哥是我们公司的老大，ceo兼cto).顺利进去。进去之后，严哥马上招呼兴淘（公司的运营）给我倒了一杯水，第一眼的感觉公司的哥们都挺年轻的。严哥也一直让我别紧张，很随和。他的照顾也让我感觉没有那么紧张了，气氛稍松。\n\n然而。。。这并没有什么卵用啊。。\n\n介绍我自己的时候，完全都不敢吹牛逼。简单的表述了一下。\n\n总结就是：自学了几门语言，做过几个项目，懂一点框架。用过github,csdn。\n翻译过一点技术文章，写过简单的教程。课余发挥价值当过志愿者。\n\n说完之后，问了一下数据结构，栈是什么，堆是什么。还问了一下专业比赛。我当然不敢说出“全国软件专业人才设计与创业大赛”这样的名字，只是说蓝桥杯，因为算法我早就不知道丢哪里去了。严哥人好，并没有一定要我写个排序出来。感谢。\n\n\n之后回去还是很担心的，怕自己不行。\n\n\n第二天。\n\n“经过考虑，我们想邀请你来工作室实习”\n\n这是我最近听到最美妙的一句话。\n\n原来过去的一年，曾经戴耳塞看教学视频，塞到耳朵疼痛不已，看到眼睛见光流泪，都不是白费。翻过的书页，也真的成为了自己的实力。\n\n\n\n\n","source":"_posts/生活/2015-9-20-study-1.md","raw":"---\nlayout: post\ntitle: 实习（一）\ndate: 2015-09-20\ncategory: 生活\ntags: \nkeywords: \ndescription: 新博客的第一篇日志，之前做安卓的一些菜鸟日志在CSDN被人恶意删除，决心自己搭个窝\n---\n\n## 投简历\n9月6日开学，告别了家乡，我再次来到了学校。\n意识到大学一直没有实习的我，开始想要接触些工作。\n\n当天半夜的时候我上了拉勾网看了一下招聘，发现了现在实习的公司。\n离学校也近，最主要的是，接受实习生。虽然已经自学了一年的时间，但我知道这太不够了。\n\n在简历上的技能栏，我连熟悉都不敢写：\n\n?imageView2/2/w/350\n![](http://7xiym9.com1.z0.glb.clouddn.com/lagou.png)\n\n\n第二天，发现自己的简历通过了筛选.毕竟有过几个实战项目和专业获奖经历，也算是意料之中。隔了一天，周一下午接到公司的电话，问了一些情况，约定周二的下午去面试。\n\n坦白说，我高三跟着做过更新数字电视插口的工作，大一大二做过志愿者，甚至还面试过别人，还去学校电信网络维护做过。按理也应该有些经验，可我仍旧感觉到紧张。\n\n害怕的是，自己的所学，经不起社会的检验。\n\n##面试\n鑫鑫知道我要去面试，我说不必了。她却要陪着我，等着我面试完再一起回去。\n\n我心里很感动。\n\n我们怕找不到路，提前了大半个小时先去看了地方。一直走到门口确认之后，才放心。\n\n对正式的约定不迟到，应该是基本的礼节。\n\n然后找了个和咖啡的小店，让她坐着看kindle,我就独自过去了。\n\n到了说好的时间，打了严哥的电话(严哥是我们公司的老大，ceo兼cto).顺利进去。进去之后，严哥马上招呼兴淘（公司的运营）给我倒了一杯水，第一眼的感觉公司的哥们都挺年轻的。严哥也一直让我别紧张，很随和。他的照顾也让我感觉没有那么紧张了，气氛稍松。\n\n然而。。。这并没有什么卵用啊。。\n\n介绍我自己的时候，完全都不敢吹牛逼。简单的表述了一下。\n\n总结就是：自学了几门语言，做过几个项目，懂一点框架。用过github,csdn。\n翻译过一点技术文章，写过简单的教程。课余发挥价值当过志愿者。\n\n说完之后，问了一下数据结构，栈是什么，堆是什么。还问了一下专业比赛。我当然不敢说出“全国软件专业人才设计与创业大赛”这样的名字，只是说蓝桥杯，因为算法我早就不知道丢哪里去了。严哥人好，并没有一定要我写个排序出来。感谢。\n\n\n之后回去还是很担心的，怕自己不行。\n\n\n第二天。\n\n“经过考虑，我们想邀请你来工作室实习”\n\n这是我最近听到最美妙的一句话。\n\n原来过去的一年，曾经戴耳塞看教学视频，塞到耳朵疼痛不已，看到眼睛见光流泪，都不是白费。翻过的书页，也真的成为了自己的实力。\n\n\n\n\n","slug":"生活/2015-9-20-study-1","published":1,"updated":"2016-09-06T17:30:51.000Z","comments":1,"photos":[],"link":"","_id":"cisw1pts50012yrntyfh2zerx","content":"<h2 id=\"投简历\"><a href=\"#投简历\" class=\"headerlink\" title=\"投简历\"></a>投简历</h2><p>9月6日开学，告别了家乡，我再次来到了学校。<br>意识到大学一直没有实习的我，开始想要接触些工作。</p>\n<p>当天半夜的时候我上了拉勾网看了一下招聘，发现了现在实习的公司。<br>离学校也近，最主要的是，接受实习生。虽然已经自学了一年的时间，但我知道这太不够了。</p>\n<p>在简历上的技能栏，我连熟悉都不敢写：</p>\n<p>?imageView2/2/w/350<br><img src=\"http://7xiym9.com1.z0.glb.clouddn.com/lagou.png\" alt=\"\"></p>\n<p>第二天，发现自己的简历通过了筛选.毕竟有过几个实战项目和专业获奖经历，也算是意料之中。隔了一天，周一下午接到公司的电话，问了一些情况，约定周二的下午去面试。</p>\n<p>坦白说，我高三跟着做过更新数字电视插口的工作，大一大二做过志愿者，甚至还面试过别人，还去学校电信网络维护做过。按理也应该有些经验，可我仍旧感觉到紧张。</p>\n<p>害怕的是，自己的所学，经不起社会的检验。</p>\n<p>##面试<br>鑫鑫知道我要去面试，我说不必了。她却要陪着我，等着我面试完再一起回去。</p>\n<p>我心里很感动。</p>\n<p>我们怕找不到路，提前了大半个小时先去看了地方。一直走到门口确认之后，才放心。</p>\n<p>对正式的约定不迟到，应该是基本的礼节。</p>\n<p>然后找了个和咖啡的小店，让她坐着看kindle,我就独自过去了。</p>\n<p>到了说好的时间，打了严哥的电话(严哥是我们公司的老大，ceo兼cto).顺利进去。进去之后，严哥马上招呼兴淘（公司的运营）给我倒了一杯水，第一眼的感觉公司的哥们都挺年轻的。严哥也一直让我别紧张，很随和。他的照顾也让我感觉没有那么紧张了，气氛稍松。</p>\n<p>然而。。。这并没有什么卵用啊。。</p>\n<p>介绍我自己的时候，完全都不敢吹牛逼。简单的表述了一下。</p>\n<p>总结就是：自学了几门语言，做过几个项目，懂一点框架。用过github,csdn。<br>翻译过一点技术文章，写过简单的教程。课余发挥价值当过志愿者。</p>\n<p>说完之后，问了一下数据结构，栈是什么，堆是什么。还问了一下专业比赛。我当然不敢说出“全国软件专业人才设计与创业大赛”这样的名字，只是说蓝桥杯，因为算法我早就不知道丢哪里去了。严哥人好，并没有一定要我写个排序出来。感谢。</p>\n<p>之后回去还是很担心的，怕自己不行。</p>\n<p>第二天。</p>\n<p>“经过考虑，我们想邀请你来工作室实习”</p>\n<p>这是我最近听到最美妙的一句话。</p>\n<p>原来过去的一年，曾经戴耳塞看教学视频，塞到耳朵疼痛不已，看到眼睛见光流泪，都不是白费。翻过的书页，也真的成为了自己的实力。</p>\n","excerpt":"","more":"<h2 id=\"投简历\"><a href=\"#投简历\" class=\"headerlink\" title=\"投简历\"></a>投简历</h2><p>9月6日开学，告别了家乡，我再次来到了学校。<br>意识到大学一直没有实习的我，开始想要接触些工作。</p>\n<p>当天半夜的时候我上了拉勾网看了一下招聘，发现了现在实习的公司。<br>离学校也近，最主要的是，接受实习生。虽然已经自学了一年的时间，但我知道这太不够了。</p>\n<p>在简历上的技能栏，我连熟悉都不敢写：</p>\n<p>?imageView2/2/w/350<br><img src=\"http://7xiym9.com1.z0.glb.clouddn.com/lagou.png\" alt=\"\"></p>\n<p>第二天，发现自己的简历通过了筛选.毕竟有过几个实战项目和专业获奖经历，也算是意料之中。隔了一天，周一下午接到公司的电话，问了一些情况，约定周二的下午去面试。</p>\n<p>坦白说，我高三跟着做过更新数字电视插口的工作，大一大二做过志愿者，甚至还面试过别人，还去学校电信网络维护做过。按理也应该有些经验，可我仍旧感觉到紧张。</p>\n<p>害怕的是，自己的所学，经不起社会的检验。</p>\n<p>##面试<br>鑫鑫知道我要去面试，我说不必了。她却要陪着我，等着我面试完再一起回去。</p>\n<p>我心里很感动。</p>\n<p>我们怕找不到路，提前了大半个小时先去看了地方。一直走到门口确认之后，才放心。</p>\n<p>对正式的约定不迟到，应该是基本的礼节。</p>\n<p>然后找了个和咖啡的小店，让她坐着看kindle,我就独自过去了。</p>\n<p>到了说好的时间，打了严哥的电话(严哥是我们公司的老大，ceo兼cto).顺利进去。进去之后，严哥马上招呼兴淘（公司的运营）给我倒了一杯水，第一眼的感觉公司的哥们都挺年轻的。严哥也一直让我别紧张，很随和。他的照顾也让我感觉没有那么紧张了，气氛稍松。</p>\n<p>然而。。。这并没有什么卵用啊。。</p>\n<p>介绍我自己的时候，完全都不敢吹牛逼。简单的表述了一下。</p>\n<p>总结就是：自学了几门语言，做过几个项目，懂一点框架。用过github,csdn。<br>翻译过一点技术文章，写过简单的教程。课余发挥价值当过志愿者。</p>\n<p>说完之后，问了一下数据结构，栈是什么，堆是什么。还问了一下专业比赛。我当然不敢说出“全国软件专业人才设计与创业大赛”这样的名字，只是说蓝桥杯，因为算法我早就不知道丢哪里去了。严哥人好，并没有一定要我写个排序出来。感谢。</p>\n<p>之后回去还是很担心的，怕自己不行。</p>\n<p>第二天。</p>\n<p>“经过考虑，我们想邀请你来工作室实习”</p>\n<p>这是我最近听到最美妙的一句话。</p>\n<p>原来过去的一年，曾经戴耳塞看教学视频，塞到耳朵疼痛不已，看到眼睛见光流泪，都不是白费。翻过的书页，也真的成为了自己的实力。</p>\n"},{"layout":"post","date":"2016-08-21T08:50:46.000Z","title":"iOS代码Objective-C编程规范","keywords":"iOS","description":"根据自己经验总结的编程规范","_content":"\n# iOS代码Objective-C编程规范\n\n## 前言\n\n在经过一段时间学习和工作之后，自己写了不少代码，也看了不少代码。深知千人千面，每个人写的代码都有自己的风格。\n\n而坏的代码各有各的\"特色\"，好的代码总是清晰明了（当然有一些代码由于高度的抽象，导致不那么\"清楚\"，需要我们深入去理解它们）。\n\n在一个团队中，如果没有一个文档规范，特别是当新人进入时，每次都进行口头的说教，将带来不必要的时间成本。\n\n因此有了这一份iOS代码的Objective-C编程规范。\n\n## 项目目录结构\n\n关于目录结构和架构等组织方式，现在总结出一个道理：\n>架构是逐渐演进的，适合自己的业务的架构才是最好的架构，没有所谓最好的架构\n\n之前自己忙于工作，没记录下来思考过程有些遗憾，这一篇[《iOS移动端架构的那些事》](http://www.jianshu.com/p/15e5b83ab70e)说的非常好。文中最后的middleman以及urlRoute，我已经有一些涉猎和实践，但是在这里不做讨论。\n\n在一般的开发当中，我们使用按`模块`划分的方法，已经足够用了。\n目前使用的目录结构如下：\n\n```\n\n|---AppDelegate\n  |---AppDelegate+category1\n  |---AppDelegate+category2\n  ...\n|---Classes\n  |---Module\n    |---Controller\n    |---Model\n    |---View\n  ...\n|---Expand\n  |---Category\n    |---UIKit\n    |---Foundation\n  |---Const\n    |---HZConst\n    |---APIConst\n  |---Macros\n  |---NetWork\n  |---Utility\n  ...\n|---Resource\n  |---Image\n  |---Plist\n  |---File\n  |---Video\n  |---Sound\n  ...\n|---Vendor\n\n```\n\n乍一看很多，容我慢慢讲解。\n\n#### AppDelegate\nApp的Delegate类实现，它必须有。但是有时候会在里面做很多操作，比如：监听前后台切换，或者第三方登录，统计分析，通知注册回调等等的操作。因而将代码进行拆分，对AppDelegate按功能分类。\n#### Classes\n这里是我们写业务的地方。\n\n首先横向拆分业务、功能模块。\n\n然后模块里面纵向拆分，一般采用MVC/MVVM/MVP等方式都可以。\n\n>注意，这个地方曾经有同事倾向于按界面去分模块。这样有两个不好的地方:第一，比如电商APP，在首页/收藏/商品买卖等等各个地方，都需要一个商品详情模块，那这个模块界面层级，该怎么放？按业务拆分时，就不应该再用界面去划分模块。第二，代码组织的层级很容易过深，如果界面复和功能复杂起来，那展开一个文件可能需要打开很多层文件夹。\n\n#### Expand\n顾名思义，这里放的都是我们的扩展文件,可以存放Category(分类文件)，Const(常用常量，api常量)，Macros(宏)，Network(网络库的封装扩展)，Utility(工具箱)等等。\n\n#### Resource\n在Resource里面，存放我们的各种资源文件,plist,image,video等等。\n\n#### Vendor\n这里面统一存放的是我们引入的第三方库和框架。\n\n虽然可以用CocoaPods和Carthage很方便地管理第三方库，但偶尔也会需要直接引入第三方的文件。\n\n## 文件内代码组织\n\n考虑到知易行难这样亘古不变的道理，我已经整理好代码模板文件到[我的Github](https://github.com/zzgo/CodeTemplate)上,直接clone下来后，放在如下路径:\n\n>/Applications/Xcode.app/Contents/Developer/Library/Xcode/Templates/File Templates/Source/\n\n### 文件头注释\n\n所有的文件在文件头注释上，应当具有:\n\n* 文件创建的时间\u0010\n* 文件创建者\n* 文件创建者的联系方式\n\n如下所示：\n\n```\n//\n//  Created by zzgo on 16/8/21.\n//  Contact by zzgoCC@gmail.com\n//  Copyright © 2016年 quseit. All rights reserved.\n//\n```\n\n意义在于让后来者知道代码创建的时间，以及碰到问题时，可以及时联系上原作者。\n\n### @interface\n在接口中，先写属性（delegate在最后），再写方法(类方法在前)。\n如:\n\n    @interface Object : NSObject\n    @property (nonatomic, readwrite, strong) NSString *name;\n    @property (nonatomic, readwrite, weak) id<ObjectDelegate> delegate;\n    + (void)testLog;\n    - (void)configure;\n    @end\n\n#### 接口设计原则\n避免 “厨房水槽（kitchen-sink）” 式的 API。如果一个函数压根没必要公开，就不要这么做。提一下接口的设计原则:\n\n- 只暴露外部需要看到的。尽可能少的`暴露`类的方法，属性，和成员变量等。\n- 合理分组\n- 避免头文件污染\n- 避免接口过度设计\n- 隐藏继承关系中的私有接口\n- 避免单例的滥用\n\n有兴趣的可以看一看这个文章<[objc@interface的设计哲学与设计技巧](http://blog.sunnyxx.com/2014/04/13/objc_dig_interface/)>\n\n另外，对于一个外部引用对象，且外部不会发生set操作的对象，使用readonly属性:\n\n```\n //.h文件中\n@interface MyClass : NSObject\n@property (nonatomic, readonly, strong) NSObject *object;\n@end\n//.m文件中\n@interface MyClass ()\n@property (nonatomic, readwrite, strong) NSObject *object;\n@end\n\n@implementation MyClass\n//Do Something cool\n@end\n```\n\n### .m文件的布局顺序\n\n布局顺序如下：\n\n```\n    //文件头注释\n    //import\n    //文件内部使用的宏\n    //常量定义\n    //@interface()\n    //@implementation\n```\n\n#### @implementation中的组织\n\n```\n#pragma mark - Intial Methods\n\n#pragma mark - Override/Life Cycle\n\n#pragma mark - Notification\n\n#pragma mark - KVO\n\n#pragma mark - target-action/IBActions\n\n#pragma mark - delegate dataSource protocol\n\n#pragma mark - public\n\n#pragma mark - private\n\n#pragma mark - getter / setter\n```\n\n#### 控制流语句的括号使用\n在使用控制流语句时，必须使用括号.\n推荐:\n\n```\nif (someObject) {\n  [someObject doSomething];\n} \n```\n\n不推荐:\n\n```\nif (someObject) [someObject doSomething];\n```\n\n括号让我们的控制流语句的执行体看起来更明了。\n\n### 其他具体风格\n关于更细节的代码风格，统一使用Xcode的插件 [clang-format](https://github.com/travisjeffery/ClangFormat-Xcode) ，来格式化代码风格。\n\n>clang-format是基于clang的一个命令行工具。这个工具能够自动化格式C/C++/Obj-C代码，支持多种代码风格：Google, Chromium, LLVM, Mozilla, WebKit，也支持自定义风格（通过编写.clang-format文件）。\n\n在工程目录或者workspace目录下创建一个\".clang-format\"文件，就可以使用自定义的格式。\n\n在这里我们采用统一的`.clang-format`文件.同样可以前往[我的Github](https://github.com/zzgo/CodeTemplate)上下载。\n\n","source":"_posts/技术/2016-8-21-Objective-CCodeGuide.md","raw":"---\nlayout: post\ndate: 2016-08-21 16:50:46\ntitle: iOS代码Objective-C编程规范\ncategory: 技术\ntags: 资料\nkeywords: iOS\ndescription: 根据自己经验总结的编程规范\n---\n\n# iOS代码Objective-C编程规范\n\n## 前言\n\n在经过一段时间学习和工作之后，自己写了不少代码，也看了不少代码。深知千人千面，每个人写的代码都有自己的风格。\n\n而坏的代码各有各的\"特色\"，好的代码总是清晰明了（当然有一些代码由于高度的抽象，导致不那么\"清楚\"，需要我们深入去理解它们）。\n\n在一个团队中，如果没有一个文档规范，特别是当新人进入时，每次都进行口头的说教，将带来不必要的时间成本。\n\n因此有了这一份iOS代码的Objective-C编程规范。\n\n## 项目目录结构\n\n关于目录结构和架构等组织方式，现在总结出一个道理：\n>架构是逐渐演进的，适合自己的业务的架构才是最好的架构，没有所谓最好的架构\n\n之前自己忙于工作，没记录下来思考过程有些遗憾，这一篇[《iOS移动端架构的那些事》](http://www.jianshu.com/p/15e5b83ab70e)说的非常好。文中最后的middleman以及urlRoute，我已经有一些涉猎和实践，但是在这里不做讨论。\n\n在一般的开发当中，我们使用按`模块`划分的方法，已经足够用了。\n目前使用的目录结构如下：\n\n```\n\n|---AppDelegate\n  |---AppDelegate+category1\n  |---AppDelegate+category2\n  ...\n|---Classes\n  |---Module\n    |---Controller\n    |---Model\n    |---View\n  ...\n|---Expand\n  |---Category\n    |---UIKit\n    |---Foundation\n  |---Const\n    |---HZConst\n    |---APIConst\n  |---Macros\n  |---NetWork\n  |---Utility\n  ...\n|---Resource\n  |---Image\n  |---Plist\n  |---File\n  |---Video\n  |---Sound\n  ...\n|---Vendor\n\n```\n\n乍一看很多，容我慢慢讲解。\n\n#### AppDelegate\nApp的Delegate类实现，它必须有。但是有时候会在里面做很多操作，比如：监听前后台切换，或者第三方登录，统计分析，通知注册回调等等的操作。因而将代码进行拆分，对AppDelegate按功能分类。\n#### Classes\n这里是我们写业务的地方。\n\n首先横向拆分业务、功能模块。\n\n然后模块里面纵向拆分，一般采用MVC/MVVM/MVP等方式都可以。\n\n>注意，这个地方曾经有同事倾向于按界面去分模块。这样有两个不好的地方:第一，比如电商APP，在首页/收藏/商品买卖等等各个地方，都需要一个商品详情模块，那这个模块界面层级，该怎么放？按业务拆分时，就不应该再用界面去划分模块。第二，代码组织的层级很容易过深，如果界面复和功能复杂起来，那展开一个文件可能需要打开很多层文件夹。\n\n#### Expand\n顾名思义，这里放的都是我们的扩展文件,可以存放Category(分类文件)，Const(常用常量，api常量)，Macros(宏)，Network(网络库的封装扩展)，Utility(工具箱)等等。\n\n#### Resource\n在Resource里面，存放我们的各种资源文件,plist,image,video等等。\n\n#### Vendor\n这里面统一存放的是我们引入的第三方库和框架。\n\n虽然可以用CocoaPods和Carthage很方便地管理第三方库，但偶尔也会需要直接引入第三方的文件。\n\n## 文件内代码组织\n\n考虑到知易行难这样亘古不变的道理，我已经整理好代码模板文件到[我的Github](https://github.com/zzgo/CodeTemplate)上,直接clone下来后，放在如下路径:\n\n>/Applications/Xcode.app/Contents/Developer/Library/Xcode/Templates/File Templates/Source/\n\n### 文件头注释\n\n所有的文件在文件头注释上，应当具有:\n\n* 文件创建的时间\u0010\n* 文件创建者\n* 文件创建者的联系方式\n\n如下所示：\n\n```\n//\n//  Created by zzgo on 16/8/21.\n//  Contact by zzgoCC@gmail.com\n//  Copyright © 2016年 quseit. All rights reserved.\n//\n```\n\n意义在于让后来者知道代码创建的时间，以及碰到问题时，可以及时联系上原作者。\n\n### @interface\n在接口中，先写属性（delegate在最后），再写方法(类方法在前)。\n如:\n\n    @interface Object : NSObject\n    @property (nonatomic, readwrite, strong) NSString *name;\n    @property (nonatomic, readwrite, weak) id<ObjectDelegate> delegate;\n    + (void)testLog;\n    - (void)configure;\n    @end\n\n#### 接口设计原则\n避免 “厨房水槽（kitchen-sink）” 式的 API。如果一个函数压根没必要公开，就不要这么做。提一下接口的设计原则:\n\n- 只暴露外部需要看到的。尽可能少的`暴露`类的方法，属性，和成员变量等。\n- 合理分组\n- 避免头文件污染\n- 避免接口过度设计\n- 隐藏继承关系中的私有接口\n- 避免单例的滥用\n\n有兴趣的可以看一看这个文章<[objc@interface的设计哲学与设计技巧](http://blog.sunnyxx.com/2014/04/13/objc_dig_interface/)>\n\n另外，对于一个外部引用对象，且外部不会发生set操作的对象，使用readonly属性:\n\n```\n //.h文件中\n@interface MyClass : NSObject\n@property (nonatomic, readonly, strong) NSObject *object;\n@end\n//.m文件中\n@interface MyClass ()\n@property (nonatomic, readwrite, strong) NSObject *object;\n@end\n\n@implementation MyClass\n//Do Something cool\n@end\n```\n\n### .m文件的布局顺序\n\n布局顺序如下：\n\n```\n    //文件头注释\n    //import\n    //文件内部使用的宏\n    //常量定义\n    //@interface()\n    //@implementation\n```\n\n#### @implementation中的组织\n\n```\n#pragma mark - Intial Methods\n\n#pragma mark - Override/Life Cycle\n\n#pragma mark - Notification\n\n#pragma mark - KVO\n\n#pragma mark - target-action/IBActions\n\n#pragma mark - delegate dataSource protocol\n\n#pragma mark - public\n\n#pragma mark - private\n\n#pragma mark - getter / setter\n```\n\n#### 控制流语句的括号使用\n在使用控制流语句时，必须使用括号.\n推荐:\n\n```\nif (someObject) {\n  [someObject doSomething];\n} \n```\n\n不推荐:\n\n```\nif (someObject) [someObject doSomething];\n```\n\n括号让我们的控制流语句的执行体看起来更明了。\n\n### 其他具体风格\n关于更细节的代码风格，统一使用Xcode的插件 [clang-format](https://github.com/travisjeffery/ClangFormat-Xcode) ，来格式化代码风格。\n\n>clang-format是基于clang的一个命令行工具。这个工具能够自动化格式C/C++/Obj-C代码，支持多种代码风格：Google, Chromium, LLVM, Mozilla, WebKit，也支持自定义风格（通过编写.clang-format文件）。\n\n在工程目录或者workspace目录下创建一个\".clang-format\"文件，就可以使用自定义的格式。\n\n在这里我们采用统一的`.clang-format`文件.同样可以前往[我的Github](https://github.com/zzgo/CodeTemplate)上下载。\n\n","slug":"技术/2016-8-21-Objective-CCodeGuide","published":1,"updated":"2016-08-22T15:46:59.000Z","comments":1,"photos":[],"link":"","_id":"cisw1pts90015yrntgu5rid6z","content":"<h1 id=\"iOS代码Objective-C编程规范\"><a href=\"#iOS代码Objective-C编程规范\" class=\"headerlink\" title=\"iOS代码Objective-C编程规范\"></a>iOS代码Objective-C编程规范</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在经过一段时间学习和工作之后，自己写了不少代码，也看了不少代码。深知千人千面，每个人写的代码都有自己的风格。</p>\n<p>而坏的代码各有各的”特色”，好的代码总是清晰明了（当然有一些代码由于高度的抽象，导致不那么”清楚”，需要我们深入去理解它们）。</p>\n<p>在一个团队中，如果没有一个文档规范，特别是当新人进入时，每次都进行口头的说教，将带来不必要的时间成本。</p>\n<p>因此有了这一份iOS代码的Objective-C编程规范。</p>\n<h2 id=\"项目目录结构\"><a href=\"#项目目录结构\" class=\"headerlink\" title=\"项目目录结构\"></a>项目目录结构</h2><p>关于目录结构和架构等组织方式，现在总结出一个道理：</p>\n<blockquote>\n<p>架构是逐渐演进的，适合自己的业务的架构才是最好的架构，没有所谓最好的架构</p>\n</blockquote>\n<p>之前自己忙于工作，没记录下来思考过程有些遗憾，这一篇<a href=\"http://www.jianshu.com/p/15e5b83ab70e\" target=\"_blank\" rel=\"external\">《iOS移动端架构的那些事》</a>说的非常好。文中最后的middleman以及urlRoute，我已经有一些涉猎和实践，但是在这里不做讨论。</p>\n<p>在一般的开发当中，我们使用按<code>模块</code>划分的方法，已经足够用了。<br>目前使用的目录结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">|---AppDelegate</span><br><span class=\"line\">  |---AppDelegate+category1</span><br><span class=\"line\">  |---AppDelegate+category2</span><br><span class=\"line\">  ...</span><br><span class=\"line\">|---Classes</span><br><span class=\"line\">  |---Module</span><br><span class=\"line\">    |---Controller</span><br><span class=\"line\">    |---Model</span><br><span class=\"line\">    |---View</span><br><span class=\"line\">  ...</span><br><span class=\"line\">|---Expand</span><br><span class=\"line\">  |---Category</span><br><span class=\"line\">    |---UIKit</span><br><span class=\"line\">    |---Foundation</span><br><span class=\"line\">  |---Const</span><br><span class=\"line\">    |---HZConst</span><br><span class=\"line\">    |---APIConst</span><br><span class=\"line\">  |---Macros</span><br><span class=\"line\">  |---NetWork</span><br><span class=\"line\">  |---Utility</span><br><span class=\"line\">  ...</span><br><span class=\"line\">|---Resource</span><br><span class=\"line\">  |---Image</span><br><span class=\"line\">  |---Plist</span><br><span class=\"line\">  |---File</span><br><span class=\"line\">  |---Video</span><br><span class=\"line\">  |---Sound</span><br><span class=\"line\">  ...</span><br><span class=\"line\">|---Vendor</span><br></pre></td></tr></table></figure>\n<p>乍一看很多，容我慢慢讲解。</p>\n<h4 id=\"AppDelegate\"><a href=\"#AppDelegate\" class=\"headerlink\" title=\"AppDelegate\"></a>AppDelegate</h4><p>App的Delegate类实现，它必须有。但是有时候会在里面做很多操作，比如：监听前后台切换，或者第三方登录，统计分析，通知注册回调等等的操作。因而将代码进行拆分，对AppDelegate按功能分类。</p>\n<h4 id=\"Classes\"><a href=\"#Classes\" class=\"headerlink\" title=\"Classes\"></a>Classes</h4><p>这里是我们写业务的地方。</p>\n<p>首先横向拆分业务、功能模块。</p>\n<p>然后模块里面纵向拆分，一般采用MVC/MVVM/MVP等方式都可以。</p>\n<blockquote>\n<p>注意，这个地方曾经有同事倾向于按界面去分模块。这样有两个不好的地方:第一，比如电商APP，在首页/收藏/商品买卖等等各个地方，都需要一个商品详情模块，那这个模块界面层级，该怎么放？按业务拆分时，就不应该再用界面去划分模块。第二，代码组织的层级很容易过深，如果界面复和功能复杂起来，那展开一个文件可能需要打开很多层文件夹。</p>\n</blockquote>\n<h4 id=\"Expand\"><a href=\"#Expand\" class=\"headerlink\" title=\"Expand\"></a>Expand</h4><p>顾名思义，这里放的都是我们的扩展文件,可以存放Category(分类文件)，Const(常用常量，api常量)，Macros(宏)，Network(网络库的封装扩展)，Utility(工具箱)等等。</p>\n<h4 id=\"Resource\"><a href=\"#Resource\" class=\"headerlink\" title=\"Resource\"></a>Resource</h4><p>在Resource里面，存放我们的各种资源文件,plist,image,video等等。</p>\n<h4 id=\"Vendor\"><a href=\"#Vendor\" class=\"headerlink\" title=\"Vendor\"></a>Vendor</h4><p>这里面统一存放的是我们引入的第三方库和框架。</p>\n<p>虽然可以用CocoaPods和Carthage很方便地管理第三方库，但偶尔也会需要直接引入第三方的文件。</p>\n<h2 id=\"文件内代码组织\"><a href=\"#文件内代码组织\" class=\"headerlink\" title=\"文件内代码组织\"></a>文件内代码组织</h2><p>考虑到知易行难这样亘古不变的道理，我已经整理好代码模板文件到<a href=\"https://github.com/zzgo/CodeTemplate\" target=\"_blank\" rel=\"external\">我的Github</a>上,直接clone下来后，放在如下路径:</p>\n<blockquote>\n<p>/Applications/Xcode.app/Contents/Developer/Library/Xcode/Templates/File Templates/Source/</p>\n</blockquote>\n<h3 id=\"文件头注释\"><a href=\"#文件头注释\" class=\"headerlink\" title=\"文件头注释\"></a>文件头注释</h3><p>所有的文件在文件头注释上，应当具有:</p>\n<ul>\n<li>文件创建的时间\u0010</li>\n<li>文件创建者</li>\n<li>文件创建者的联系方式</li>\n</ul>\n<p>如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//</span><br><span class=\"line\">//  Created by zzgo on 16/8/21.</span><br><span class=\"line\">//  Contact by zzgoCC@gmail.com</span><br><span class=\"line\">//  Copyright © 2016年 quseit. All rights reserved.</span><br><span class=\"line\">//</span><br></pre></td></tr></table></figure>\n<p>意义在于让后来者知道代码创建的时间，以及碰到问题时，可以及时联系上原作者。</p>\n<h3 id=\"interface\"><a href=\"#interface\" class=\"headerlink\" title=\"@interface\"></a>@interface</h3><p>在接口中，先写属性（delegate在最后），再写方法(类方法在前)。<br>如:</p>\n<pre><code>@interface Object : NSObject\n@property (nonatomic, readwrite, strong) NSString *name;\n@property (nonatomic, readwrite, weak) id&lt;ObjectDelegate&gt; delegate;\n+ (void)testLog;\n- (void)configure;\n@end\n</code></pre><h4 id=\"接口设计原则\"><a href=\"#接口设计原则\" class=\"headerlink\" title=\"接口设计原则\"></a>接口设计原则</h4><p>避免 “厨房水槽（kitchen-sink）” 式的 API。如果一个函数压根没必要公开，就不要这么做。提一下接口的设计原则:</p>\n<ul>\n<li>只暴露外部需要看到的。尽可能少的<code>暴露</code>类的方法，属性，和成员变量等。</li>\n<li>合理分组</li>\n<li>避免头文件污染</li>\n<li>避免接口过度设计</li>\n<li>隐藏继承关系中的私有接口</li>\n<li>避免单例的滥用</li>\n</ul>\n<p>有兴趣的可以看一看这个文章<a href=\"[objc@interface的设计哲学与设计技巧](http://blog.sunnyxx.com/2014/04/13/objc_dig_interface/)\">[objc@interface的设计哲学与设计技巧](http://blog.sunnyxx.com/2014/04/13/objc_dig_interface/)</a></p>\n<p>另外，对于一个外部引用对象，且外部不会发生set操作的对象，使用readonly属性:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> //.h文件中</span><br><span class=\"line\">@interface MyClass : NSObject</span><br><span class=\"line\">@property (nonatomic, readonly, strong) NSObject *object;</span><br><span class=\"line\">@end</span><br><span class=\"line\">//.m文件中</span><br><span class=\"line\">@interface MyClass ()</span><br><span class=\"line\">@property (nonatomic, readwrite, strong) NSObject *object;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation MyClass</span><br><span class=\"line\">//Do Something cool</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<h3 id=\"m文件的布局顺序\"><a href=\"#m文件的布局顺序\" class=\"headerlink\" title=\".m文件的布局顺序\"></a>.m文件的布局顺序</h3><p>布局顺序如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//文件头注释</span><br><span class=\"line\">//import</span><br><span class=\"line\">//文件内部使用的宏</span><br><span class=\"line\">//常量定义</span><br><span class=\"line\">//@interface()</span><br><span class=\"line\">//@implementation</span><br></pre></td></tr></table></figure>\n<h4 id=\"implementation中的组织\"><a href=\"#implementation中的组织\" class=\"headerlink\" title=\"@implementation中的组织\"></a>@implementation中的组织</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#pragma mark - Intial Methods</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark - Override/Life Cycle</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark - Notification</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark - KVO</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark - target-action/IBActions</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark - delegate dataSource protocol</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark - public</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark - private</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark - getter / setter</span><br></pre></td></tr></table></figure>\n<h4 id=\"控制流语句的括号使用\"><a href=\"#控制流语句的括号使用\" class=\"headerlink\" title=\"控制流语句的括号使用\"></a>控制流语句的括号使用</h4><p>在使用控制流语句时，必须使用括号.<br>推荐:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (someObject) &#123;</span><br><span class=\"line\">  [someObject doSomething];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不推荐:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (someObject) [someObject doSomething];</span><br></pre></td></tr></table></figure>\n<p>括号让我们的控制流语句的执行体看起来更明了。</p>\n<h3 id=\"其他具体风格\"><a href=\"#其他具体风格\" class=\"headerlink\" title=\"其他具体风格\"></a>其他具体风格</h3><p>关于更细节的代码风格，统一使用Xcode的插件 <a href=\"https://github.com/travisjeffery/ClangFormat-Xcode\" target=\"_blank\" rel=\"external\">clang-format</a> ，来格式化代码风格。</p>\n<blockquote>\n<p>clang-format是基于clang的一个命令行工具。这个工具能够自动化格式C/C++/Obj-C代码，支持多种代码风格：Google, Chromium, LLVM, Mozilla, WebKit，也支持自定义风格（通过编写.clang-format文件）。</p>\n</blockquote>\n<p>在工程目录或者workspace目录下创建一个”.clang-format”文件，就可以使用自定义的格式。</p>\n<p>在这里我们采用统一的<code>.clang-format</code>文件.同样可以前往<a href=\"https://github.com/zzgo/CodeTemplate\" target=\"_blank\" rel=\"external\">我的Github</a>上下载。</p>\n","excerpt":"","more":"<h1 id=\"iOS代码Objective-C编程规范\"><a href=\"#iOS代码Objective-C编程规范\" class=\"headerlink\" title=\"iOS代码Objective-C编程规范\"></a>iOS代码Objective-C编程规范</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在经过一段时间学习和工作之后，自己写了不少代码，也看了不少代码。深知千人千面，每个人写的代码都有自己的风格。</p>\n<p>而坏的代码各有各的”特色”，好的代码总是清晰明了（当然有一些代码由于高度的抽象，导致不那么”清楚”，需要我们深入去理解它们）。</p>\n<p>在一个团队中，如果没有一个文档规范，特别是当新人进入时，每次都进行口头的说教，将带来不必要的时间成本。</p>\n<p>因此有了这一份iOS代码的Objective-C编程规范。</p>\n<h2 id=\"项目目录结构\"><a href=\"#项目目录结构\" class=\"headerlink\" title=\"项目目录结构\"></a>项目目录结构</h2><p>关于目录结构和架构等组织方式，现在总结出一个道理：</p>\n<blockquote>\n<p>架构是逐渐演进的，适合自己的业务的架构才是最好的架构，没有所谓最好的架构</p>\n</blockquote>\n<p>之前自己忙于工作，没记录下来思考过程有些遗憾，这一篇<a href=\"http://www.jianshu.com/p/15e5b83ab70e\">《iOS移动端架构的那些事》</a>说的非常好。文中最后的middleman以及urlRoute，我已经有一些涉猎和实践，但是在这里不做讨论。</p>\n<p>在一般的开发当中，我们使用按<code>模块</code>划分的方法，已经足够用了。<br>目前使用的目录结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">|---AppDelegate</span><br><span class=\"line\">  |---AppDelegate+category1</span><br><span class=\"line\">  |---AppDelegate+category2</span><br><span class=\"line\">  ...</span><br><span class=\"line\">|---Classes</span><br><span class=\"line\">  |---Module</span><br><span class=\"line\">    |---Controller</span><br><span class=\"line\">    |---Model</span><br><span class=\"line\">    |---View</span><br><span class=\"line\">  ...</span><br><span class=\"line\">|---Expand</span><br><span class=\"line\">  |---Category</span><br><span class=\"line\">    |---UIKit</span><br><span class=\"line\">    |---Foundation</span><br><span class=\"line\">  |---Const</span><br><span class=\"line\">    |---HZConst</span><br><span class=\"line\">    |---APIConst</span><br><span class=\"line\">  |---Macros</span><br><span class=\"line\">  |---NetWork</span><br><span class=\"line\">  |---Utility</span><br><span class=\"line\">  ...</span><br><span class=\"line\">|---Resource</span><br><span class=\"line\">  |---Image</span><br><span class=\"line\">  |---Plist</span><br><span class=\"line\">  |---File</span><br><span class=\"line\">  |---Video</span><br><span class=\"line\">  |---Sound</span><br><span class=\"line\">  ...</span><br><span class=\"line\">|---Vendor</span><br></pre></td></tr></table></figure>\n<p>乍一看很多，容我慢慢讲解。</p>\n<h4 id=\"AppDelegate\"><a href=\"#AppDelegate\" class=\"headerlink\" title=\"AppDelegate\"></a>AppDelegate</h4><p>App的Delegate类实现，它必须有。但是有时候会在里面做很多操作，比如：监听前后台切换，或者第三方登录，统计分析，通知注册回调等等的操作。因而将代码进行拆分，对AppDelegate按功能分类。</p>\n<h4 id=\"Classes\"><a href=\"#Classes\" class=\"headerlink\" title=\"Classes\"></a>Classes</h4><p>这里是我们写业务的地方。</p>\n<p>首先横向拆分业务、功能模块。</p>\n<p>然后模块里面纵向拆分，一般采用MVC/MVVM/MVP等方式都可以。</p>\n<blockquote>\n<p>注意，这个地方曾经有同事倾向于按界面去分模块。这样有两个不好的地方:第一，比如电商APP，在首页/收藏/商品买卖等等各个地方，都需要一个商品详情模块，那这个模块界面层级，该怎么放？按业务拆分时，就不应该再用界面去划分模块。第二，代码组织的层级很容易过深，如果界面复和功能复杂起来，那展开一个文件可能需要打开很多层文件夹。</p>\n</blockquote>\n<h4 id=\"Expand\"><a href=\"#Expand\" class=\"headerlink\" title=\"Expand\"></a>Expand</h4><p>顾名思义，这里放的都是我们的扩展文件,可以存放Category(分类文件)，Const(常用常量，api常量)，Macros(宏)，Network(网络库的封装扩展)，Utility(工具箱)等等。</p>\n<h4 id=\"Resource\"><a href=\"#Resource\" class=\"headerlink\" title=\"Resource\"></a>Resource</h4><p>在Resource里面，存放我们的各种资源文件,plist,image,video等等。</p>\n<h4 id=\"Vendor\"><a href=\"#Vendor\" class=\"headerlink\" title=\"Vendor\"></a>Vendor</h4><p>这里面统一存放的是我们引入的第三方库和框架。</p>\n<p>虽然可以用CocoaPods和Carthage很方便地管理第三方库，但偶尔也会需要直接引入第三方的文件。</p>\n<h2 id=\"文件内代码组织\"><a href=\"#文件内代码组织\" class=\"headerlink\" title=\"文件内代码组织\"></a>文件内代码组织</h2><p>考虑到知易行难这样亘古不变的道理，我已经整理好代码模板文件到<a href=\"https://github.com/zzgo/CodeTemplate\">我的Github</a>上,直接clone下来后，放在如下路径:</p>\n<blockquote>\n<p>/Applications/Xcode.app/Contents/Developer/Library/Xcode/Templates/File Templates/Source/</p>\n</blockquote>\n<h3 id=\"文件头注释\"><a href=\"#文件头注释\" class=\"headerlink\" title=\"文件头注释\"></a>文件头注释</h3><p>所有的文件在文件头注释上，应当具有:</p>\n<ul>\n<li>文件创建的时间\u0010</li>\n<li>文件创建者</li>\n<li>文件创建者的联系方式</li>\n</ul>\n<p>如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//</span><br><span class=\"line\">//  Created by zzgo on 16/8/21.</span><br><span class=\"line\">//  Contact by zzgoCC@gmail.com</span><br><span class=\"line\">//  Copyright © 2016年 quseit. All rights reserved.</span><br><span class=\"line\">//</span><br></pre></td></tr></table></figure>\n<p>意义在于让后来者知道代码创建的时间，以及碰到问题时，可以及时联系上原作者。</p>\n<h3 id=\"interface\"><a href=\"#interface\" class=\"headerlink\" title=\"@interface\"></a>@interface</h3><p>在接口中，先写属性（delegate在最后），再写方法(类方法在前)。<br>如:</p>\n<pre><code>@interface Object : NSObject\n@property (nonatomic, readwrite, strong) NSString *name;\n@property (nonatomic, readwrite, weak) id&lt;ObjectDelegate&gt; delegate;\n+ (void)testLog;\n- (void)configure;\n@end\n</code></pre><h4 id=\"接口设计原则\"><a href=\"#接口设计原则\" class=\"headerlink\" title=\"接口设计原则\"></a>接口设计原则</h4><p>避免 “厨房水槽（kitchen-sink）” 式的 API。如果一个函数压根没必要公开，就不要这么做。提一下接口的设计原则:</p>\n<ul>\n<li>只暴露外部需要看到的。尽可能少的<code>暴露</code>类的方法，属性，和成员变量等。</li>\n<li>合理分组</li>\n<li>避免头文件污染</li>\n<li>避免接口过度设计</li>\n<li>隐藏继承关系中的私有接口</li>\n<li>避免单例的滥用</li>\n</ul>\n<p>有兴趣的可以看一看这个文章<a href=\"[objc@interface的设计哲学与设计技巧](http://blog.sunnyxx.com/2014/04/13/objc_dig_interface/)\">[objc@interface的设计哲学与设计技巧](http://blog.sunnyxx.com/2014/04/13/objc_dig_interface/)</a></p>\n<p>另外，对于一个外部引用对象，且外部不会发生set操作的对象，使用readonly属性:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> //.h文件中</span><br><span class=\"line\">@interface MyClass : NSObject</span><br><span class=\"line\">@property (nonatomic, readonly, strong) NSObject *object;</span><br><span class=\"line\">@end</span><br><span class=\"line\">//.m文件中</span><br><span class=\"line\">@interface MyClass ()</span><br><span class=\"line\">@property (nonatomic, readwrite, strong) NSObject *object;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation MyClass</span><br><span class=\"line\">//Do Something cool</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<h3 id=\"m文件的布局顺序\"><a href=\"#m文件的布局顺序\" class=\"headerlink\" title=\".m文件的布局顺序\"></a>.m文件的布局顺序</h3><p>布局顺序如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//文件头注释</span><br><span class=\"line\">//import</span><br><span class=\"line\">//文件内部使用的宏</span><br><span class=\"line\">//常量定义</span><br><span class=\"line\">//@interface()</span><br><span class=\"line\">//@implementation</span><br></pre></td></tr></table></figure>\n<h4 id=\"implementation中的组织\"><a href=\"#implementation中的组织\" class=\"headerlink\" title=\"@implementation中的组织\"></a>@implementation中的组织</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#pragma mark - Intial Methods</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark - Override/Life Cycle</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark - Notification</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark - KVO</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark - target-action/IBActions</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark - delegate dataSource protocol</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark - public</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark - private</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark - getter / setter</span><br></pre></td></tr></table></figure>\n<h4 id=\"控制流语句的括号使用\"><a href=\"#控制流语句的括号使用\" class=\"headerlink\" title=\"控制流语句的括号使用\"></a>控制流语句的括号使用</h4><p>在使用控制流语句时，必须使用括号.<br>推荐:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (someObject) &#123;</span><br><span class=\"line\">  [someObject doSomething];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不推荐:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (someObject) [someObject doSomething];</span><br></pre></td></tr></table></figure>\n<p>括号让我们的控制流语句的执行体看起来更明了。</p>\n<h3 id=\"其他具体风格\"><a href=\"#其他具体风格\" class=\"headerlink\" title=\"其他具体风格\"></a>其他具体风格</h3><p>关于更细节的代码风格，统一使用Xcode的插件 <a href=\"https://github.com/travisjeffery/ClangFormat-Xcode\">clang-format</a> ，来格式化代码风格。</p>\n<blockquote>\n<p>clang-format是基于clang的一个命令行工具。这个工具能够自动化格式C/C++/Obj-C代码，支持多种代码风格：Google, Chromium, LLVM, Mozilla, WebKit，也支持自定义风格（通过编写.clang-format文件）。</p>\n</blockquote>\n<p>在工程目录或者workspace目录下创建一个”.clang-format”文件，就可以使用自定义的格式。</p>\n<p>在这里我们采用统一的<code>.clang-format</code>文件.同样可以前往<a href=\"https://github.com/zzgo/CodeTemplate\">我的Github</a>上下载。</p>\n"},{"layout":"post","date":"2016-08-25T15:50:46.000Z","title":"GoSpark直播","keywords":"iOS","description":"负责四个月的直播总结，也算是自己的小结","_content":"\n# 前言\nGoSpark团队，产品和运营由花姐和老曲亲自操刀。技术团队由严哥牵头，国涛负责后台，宾纷担任设计,我做iOS客户端。\n\n下面将分为技术，产品，协作三个方面来说。\n\n最后做一个对我自己的总结。\n\n# 技术\n毫无疑问，做直播的技术门槛非常大。之前知乎有一个回答，有兴趣可以进去阅读一下--[如何搭建一个完整的视频直播系统](https://www.zhihu.com/question/42162310).\n\n简单来说，客户端需要涉及到音频/视频处理，图形处理，音频/视频压缩;服务器需要做CDN分发，转码等。如果真的从零开始深入，每种技术都够学几年。\n\n以上还不包括即时通讯，礼物系统等社交功能。\n\n好在已经有各个领域的大牛，封装出稳定易用的框架，让我们得以在前人的基础上编程。\n\n## 直播中，移动端的工作\n\n直播中，移动端的工作还不少。需要兼顾推流端和拉流端，以及礼物效果，弹幕效果等等。\n\n下面简单介绍一下流程，概念。\n\n### 推流端\n推流端，就是主播端。通过手机摄像头`采集`视频数据和麦克风采集音频数据，经过一系列`前处理`、`编码`、`封装`，然后推流到CDN进行分发。\n\n\n#### 采集\n采集主要为：`视频采集`，`音频采集`。\n\n采集到的原始音视频的体积是非常大的，需要经过压缩技术处理来提高传输效率。\n#### 前处理\n前处理主要是`美颜`，`水印`。\n\n##### 美颜功能\n美颜几乎是直播的标配功能，它实际上是通过算法去识别图像中的皮肤部分，对皮肤区域进行色值调整。通过颜色对比找到皮肤区域，可以进行色值调整、添加白色图层或调整透明度等来等来达到美白效果。\n\n磨皮的本质实际上是模糊。而在图像处理领域，模糊就是将像素点的取值与周边的像素点取值相关联。有兴趣的，可以看这篇文章[实时美颜滤镜](http://www.jianshu.com/p/945fc806a9b4)。\n\n#### 编码\n为了便于手机视频的推流、拉流以及存储，通常采用视频编码压缩技术来减少视频的体积。\n\n现在比较常用的视频编码是`H.264`。在音频方面，比较常用的是用`AAC`编码格式。\n\n当然，经过压缩后的视频在播放时必须进行解码。\n\n另外，`硬件编码`已经成为移动直播的首选方案，软编码处理在720p以上的视频颓势非常明显。在iOS平台上硬件编码的兼容性比较好，可以直接采用，但在 Android 平台上，MediaCodec 编码器针对不同的芯片平台表现差异还是非常大的，要完全实现全平台兼容的成本还是非常高的。\n\n#### 推流\n要想用于`推流`还必须把音视频数据使用传输协议进行`封装`，变成`流数据`。\n\n常见流传输协议有RTSP、RTMP、HLS等，使用RTMP传输的延时通常在1–3秒，对于移动直播这种实时性要求非常高的场景，RTMP也成为移动直播中最常用的流传输协议。\n\n而在网络传输方面全部自己来做太难了，找CDN服务商提供解决方案，其实是最好的选择。稳定快速和专业的服务，可以节省大量的时间。\n\n### 拉流端\n拉流实际是推流的逆过程。\n\n#### 拉流\n首先通过播放端获取码流。\n\n标准的拉流格式有RTMP、HLS、FLV等:\n\n- `RTMP`是Adobe的专利协议，直播延迟一般在1–3秒。tcp长连接。\n- `HLS`是苹果提出的基于HTTP的流媒体传输协议，优点是HTML5可以直接打开播放，通过社交分享出去，用户也可以直接观看直播，缺点是延迟通常大于10秒。http短连接。\n- `FLV（HTTP-FLV）`协议是使用HTTP协议传输流媒体内容的一个协议。直播延迟同样可以做到1–3秒。http长连接。\n\n三种协议是可以同时使用的，分别用到自己的场景就可以了。\n\n#### 解码和渲染\n现在一般播放器都是基于`ffmepg`的，它是一个跨平台的开源视频框架。\n\n这里有个一`硬解码`和`软解码`的概念，硬解码用GPU来解码，减少cpu运算。缺点是兼容不太好。\n软解码用cpu来解码，容易耗电发热。优点是兼容好。\n\n#### 秒开\n指点击播放后，一秒内即可看到播放画面。首屏打开越快，说明用户体验越好。技术上指播放器解码第一帧渲染显示画面所花的耗时。\n\n首帧数据的展示过程，其实是一个下载，解码，渲染的过程。\n\n`GOP ( Group of Pictures )` 是一组连续的画面，由一张 I 帧和数张 B / P 帧组成，是视频图像编码器和解码器存取的基本单位，它的排列顺序将会一直重复到影像结束。简单地讲，I 帧是一个完整的画面，而 P 帧和 B 帧记录的是相对于 I 帧的变化。\n如果要秒开，就要减少GOP Cache，也意味着画质下降。\n\n>优化策略: 接口机缓存首帧数据，减少 GOP 分片时间，修改播放器逻辑，解析到I帧就开始播放。\n\n我们在这里是使用了B站开源的[ijkplayer](https://github.com/Bilibili/ijkplayer)的框架，它针对直播进行了优化。\n\n## 服务端\n直播是 媒体流 ,而 APP 的交互是 API 信令流，两者的状态不能混为一谈。\n\n尤其是判断网络状况时，不能基于 APP 的交互的 API 状态来判断直播流的状态。\n\n要想适配各终端和平台，服务端还需要对流进行转码，如支持RTMP、HLS、FLV等格式拉流，支持一路转多路适配不同网络和分辨率的终端设备。\n\n### CDN\n\nCDN是Content Delivery Network的缩写，即内容分发网络。将网站内容发布到最接近用户的网络\"边缘\"，让用户就近取得所需要的内容。\n\n### 负载均衡\n\n多台服务器组成一个服务器的集合，每台服务器具有等价的地位，,都可以单独对外提供服务。\n\n可以将外部请求均匀分配到服务器上，均衡负载能平均分配客户的请求，解决大量并发访问服务的问题。\n\n### QoS\n带宽管理可以限制每一个组群的带宽，让有限的带宽发挥最大的作用。\n\n\n# 产品 and 协作\n\n产品对用户的定位主要是国外年轻的学生群体。因而在产品的设计上也是有所针对。色彩活泼，内容有趣。\n\n中间经历了很多次的改版和思考 : )\n\n## 关于产品设计\n\n从花姐认真的办事态度，小到一个眼色都反复思考和改到，学习到了很多。然后偶尔有的东西由于技术或者其他等因素，也可以放掉。\n\n关于产品的取舍，不是一两句话可以说清，首先是多用其他人的产品，然后是自己去分析产生自己的看法。\n\n产品需要很多方面的学习，包括设计知识，心理分析，技术实现等等，都需要一定的了解。\n\n## 运营\n\n产品非常需要运营。这个是我以前没有专门思考过的。就算是真的一匹千里马，也需要伯乐才能发挥它的价值。\n\n公司是商业的，说直白一点，出于什么样的运营其实都或多或少带点销售性质，无论是什么到最后都是作为变现的工具。\n\n运营定位的比较宽泛，如果产品需要内容，运营就是编辑，需要推广，运营就是市场。所以一个产品，一定需要好的运营才能发挥价值。\n\n运营又有:\n\n- 内容运营\n- 用户运营\n- 市场运营\n\n## 文档化\n把一些关键的信息，进行统一存储在服务器上，简化协作沟通的成本。\n- 每日任务说明\n- 账号存储\n- 测试反馈\n- api说明\n- 任务记录\n\n## scrum保持沟通\n每天组织的scrum，了解各个成员的工作计划。需要什么样的资源，确定什么样的目标等。\n\n## 版本总结。\n在重大节点完成后，进行一次大的总结。每个成员，通过自己的角度，评价协作中其他人员不足的地方，针对不足的地方进行优化。\n\n# 个人的进步\n\n## 有挑战的工作，驱动进步\n在接受直播项目的时候，都还没有毕业，经验有限。\n\n但是一整个流程走下来，学到了很多东西。主要谈学习的方法，具体的技术点更是数不过来了。\n\n总的来说有：\n\n- `查看issues`。工作中大量使用第三方库，直接去开源的项目下看issues,会得到很多有用的信息。\n- `参与开源`，发起pr。对使用到的饿了么网络库/来疯直播推流器/leanCloud的ChatKit，发起pr并被成功合并 : )\n- `自动化流程`尝试。由于频繁的打包，尝试用python脚本自动编译打包，上传到fir.im发邮件通知。并进一步了解到 `Travis CI`，能做初步使用。\n- `热修复技术`的使用。因为缺乏足够测试，总有些小问题，但是发版的时间成本太大，就学习了`JSPatch`的使用。\n- `响应式编程`了解。针对繁琐的业务逻辑，相对于面对对象，响应式编程更有优势，同时尝试mvvm的学习。以及了解RAC，和学习rxSwift。\n- `调试技能`。学会使用一些`lldb命令`，进行调试，输出视图层级，查看崩溃调用栈等;学习了解到`instruments`，学会检测内存泄露，让代码更加优化等。\n\n## 思想的进步\n\n- 保持成长—交流发现了各个领域的牛人。对照自己，还非常的年轻和不足\n- 协作的认识—产品不是单靠技术，需要各个角色一起完成\n- 严谨的思维—做产品，第一还需要理解产品的思维，和逻辑。针对各个情况，代码上进行处理和折中取舍等。\n\n\n\n>本文参考文章:\n>[《如何快速搭建一个完整的移动直播系统？》](http://www.jianshu.com/p/d391a0069993)\n>[《如何快速的开发一个完整的iOS直播app》](http://mp.weixin.qq.com/s?__biz=MzAxMzE2Mjc2Ng==&mid=2652155243&idx=1&sn=a4e4178511cd58394058588e66be36c1&scene=0#wechat_redirect)\n\n\n","source":"_posts/技术/2016-9-2-GoSpark.md","raw":"---\nlayout: post\ndate: 2016-08-25 23:50:46\ntitle: GoSpark直播\ncategory: 技术\ntags: 资料\nkeywords: iOS\ndescription: 负责四个月的直播总结，也算是自己的小结\n---\n\n# 前言\nGoSpark团队，产品和运营由花姐和老曲亲自操刀。技术团队由严哥牵头，国涛负责后台，宾纷担任设计,我做iOS客户端。\n\n下面将分为技术，产品，协作三个方面来说。\n\n最后做一个对我自己的总结。\n\n# 技术\n毫无疑问，做直播的技术门槛非常大。之前知乎有一个回答，有兴趣可以进去阅读一下--[如何搭建一个完整的视频直播系统](https://www.zhihu.com/question/42162310).\n\n简单来说，客户端需要涉及到音频/视频处理，图形处理，音频/视频压缩;服务器需要做CDN分发，转码等。如果真的从零开始深入，每种技术都够学几年。\n\n以上还不包括即时通讯，礼物系统等社交功能。\n\n好在已经有各个领域的大牛，封装出稳定易用的框架，让我们得以在前人的基础上编程。\n\n## 直播中，移动端的工作\n\n直播中，移动端的工作还不少。需要兼顾推流端和拉流端，以及礼物效果，弹幕效果等等。\n\n下面简单介绍一下流程，概念。\n\n### 推流端\n推流端，就是主播端。通过手机摄像头`采集`视频数据和麦克风采集音频数据，经过一系列`前处理`、`编码`、`封装`，然后推流到CDN进行分发。\n\n\n#### 采集\n采集主要为：`视频采集`，`音频采集`。\n\n采集到的原始音视频的体积是非常大的，需要经过压缩技术处理来提高传输效率。\n#### 前处理\n前处理主要是`美颜`，`水印`。\n\n##### 美颜功能\n美颜几乎是直播的标配功能，它实际上是通过算法去识别图像中的皮肤部分，对皮肤区域进行色值调整。通过颜色对比找到皮肤区域，可以进行色值调整、添加白色图层或调整透明度等来等来达到美白效果。\n\n磨皮的本质实际上是模糊。而在图像处理领域，模糊就是将像素点的取值与周边的像素点取值相关联。有兴趣的，可以看这篇文章[实时美颜滤镜](http://www.jianshu.com/p/945fc806a9b4)。\n\n#### 编码\n为了便于手机视频的推流、拉流以及存储，通常采用视频编码压缩技术来减少视频的体积。\n\n现在比较常用的视频编码是`H.264`。在音频方面，比较常用的是用`AAC`编码格式。\n\n当然，经过压缩后的视频在播放时必须进行解码。\n\n另外，`硬件编码`已经成为移动直播的首选方案，软编码处理在720p以上的视频颓势非常明显。在iOS平台上硬件编码的兼容性比较好，可以直接采用，但在 Android 平台上，MediaCodec 编码器针对不同的芯片平台表现差异还是非常大的，要完全实现全平台兼容的成本还是非常高的。\n\n#### 推流\n要想用于`推流`还必须把音视频数据使用传输协议进行`封装`，变成`流数据`。\n\n常见流传输协议有RTSP、RTMP、HLS等，使用RTMP传输的延时通常在1–3秒，对于移动直播这种实时性要求非常高的场景，RTMP也成为移动直播中最常用的流传输协议。\n\n而在网络传输方面全部自己来做太难了，找CDN服务商提供解决方案，其实是最好的选择。稳定快速和专业的服务，可以节省大量的时间。\n\n### 拉流端\n拉流实际是推流的逆过程。\n\n#### 拉流\n首先通过播放端获取码流。\n\n标准的拉流格式有RTMP、HLS、FLV等:\n\n- `RTMP`是Adobe的专利协议，直播延迟一般在1–3秒。tcp长连接。\n- `HLS`是苹果提出的基于HTTP的流媒体传输协议，优点是HTML5可以直接打开播放，通过社交分享出去，用户也可以直接观看直播，缺点是延迟通常大于10秒。http短连接。\n- `FLV（HTTP-FLV）`协议是使用HTTP协议传输流媒体内容的一个协议。直播延迟同样可以做到1–3秒。http长连接。\n\n三种协议是可以同时使用的，分别用到自己的场景就可以了。\n\n#### 解码和渲染\n现在一般播放器都是基于`ffmepg`的，它是一个跨平台的开源视频框架。\n\n这里有个一`硬解码`和`软解码`的概念，硬解码用GPU来解码，减少cpu运算。缺点是兼容不太好。\n软解码用cpu来解码，容易耗电发热。优点是兼容好。\n\n#### 秒开\n指点击播放后，一秒内即可看到播放画面。首屏打开越快，说明用户体验越好。技术上指播放器解码第一帧渲染显示画面所花的耗时。\n\n首帧数据的展示过程，其实是一个下载，解码，渲染的过程。\n\n`GOP ( Group of Pictures )` 是一组连续的画面，由一张 I 帧和数张 B / P 帧组成，是视频图像编码器和解码器存取的基本单位，它的排列顺序将会一直重复到影像结束。简单地讲，I 帧是一个完整的画面，而 P 帧和 B 帧记录的是相对于 I 帧的变化。\n如果要秒开，就要减少GOP Cache，也意味着画质下降。\n\n>优化策略: 接口机缓存首帧数据，减少 GOP 分片时间，修改播放器逻辑，解析到I帧就开始播放。\n\n我们在这里是使用了B站开源的[ijkplayer](https://github.com/Bilibili/ijkplayer)的框架，它针对直播进行了优化。\n\n## 服务端\n直播是 媒体流 ,而 APP 的交互是 API 信令流，两者的状态不能混为一谈。\n\n尤其是判断网络状况时，不能基于 APP 的交互的 API 状态来判断直播流的状态。\n\n要想适配各终端和平台，服务端还需要对流进行转码，如支持RTMP、HLS、FLV等格式拉流，支持一路转多路适配不同网络和分辨率的终端设备。\n\n### CDN\n\nCDN是Content Delivery Network的缩写，即内容分发网络。将网站内容发布到最接近用户的网络\"边缘\"，让用户就近取得所需要的内容。\n\n### 负载均衡\n\n多台服务器组成一个服务器的集合，每台服务器具有等价的地位，,都可以单独对外提供服务。\n\n可以将外部请求均匀分配到服务器上，均衡负载能平均分配客户的请求，解决大量并发访问服务的问题。\n\n### QoS\n带宽管理可以限制每一个组群的带宽，让有限的带宽发挥最大的作用。\n\n\n# 产品 and 协作\n\n产品对用户的定位主要是国外年轻的学生群体。因而在产品的设计上也是有所针对。色彩活泼，内容有趣。\n\n中间经历了很多次的改版和思考 : )\n\n## 关于产品设计\n\n从花姐认真的办事态度，小到一个眼色都反复思考和改到，学习到了很多。然后偶尔有的东西由于技术或者其他等因素，也可以放掉。\n\n关于产品的取舍，不是一两句话可以说清，首先是多用其他人的产品，然后是自己去分析产生自己的看法。\n\n产品需要很多方面的学习，包括设计知识，心理分析，技术实现等等，都需要一定的了解。\n\n## 运营\n\n产品非常需要运营。这个是我以前没有专门思考过的。就算是真的一匹千里马，也需要伯乐才能发挥它的价值。\n\n公司是商业的，说直白一点，出于什么样的运营其实都或多或少带点销售性质，无论是什么到最后都是作为变现的工具。\n\n运营定位的比较宽泛，如果产品需要内容，运营就是编辑，需要推广，运营就是市场。所以一个产品，一定需要好的运营才能发挥价值。\n\n运营又有:\n\n- 内容运营\n- 用户运营\n- 市场运营\n\n## 文档化\n把一些关键的信息，进行统一存储在服务器上，简化协作沟通的成本。\n- 每日任务说明\n- 账号存储\n- 测试反馈\n- api说明\n- 任务记录\n\n## scrum保持沟通\n每天组织的scrum，了解各个成员的工作计划。需要什么样的资源，确定什么样的目标等。\n\n## 版本总结。\n在重大节点完成后，进行一次大的总结。每个成员，通过自己的角度，评价协作中其他人员不足的地方，针对不足的地方进行优化。\n\n# 个人的进步\n\n## 有挑战的工作，驱动进步\n在接受直播项目的时候，都还没有毕业，经验有限。\n\n但是一整个流程走下来，学到了很多东西。主要谈学习的方法，具体的技术点更是数不过来了。\n\n总的来说有：\n\n- `查看issues`。工作中大量使用第三方库，直接去开源的项目下看issues,会得到很多有用的信息。\n- `参与开源`，发起pr。对使用到的饿了么网络库/来疯直播推流器/leanCloud的ChatKit，发起pr并被成功合并 : )\n- `自动化流程`尝试。由于频繁的打包，尝试用python脚本自动编译打包，上传到fir.im发邮件通知。并进一步了解到 `Travis CI`，能做初步使用。\n- `热修复技术`的使用。因为缺乏足够测试，总有些小问题，但是发版的时间成本太大，就学习了`JSPatch`的使用。\n- `响应式编程`了解。针对繁琐的业务逻辑，相对于面对对象，响应式编程更有优势，同时尝试mvvm的学习。以及了解RAC，和学习rxSwift。\n- `调试技能`。学会使用一些`lldb命令`，进行调试，输出视图层级，查看崩溃调用栈等;学习了解到`instruments`，学会检测内存泄露，让代码更加优化等。\n\n## 思想的进步\n\n- 保持成长—交流发现了各个领域的牛人。对照自己，还非常的年轻和不足\n- 协作的认识—产品不是单靠技术，需要各个角色一起完成\n- 严谨的思维—做产品，第一还需要理解产品的思维，和逻辑。针对各个情况，代码上进行处理和折中取舍等。\n\n\n\n>本文参考文章:\n>[《如何快速搭建一个完整的移动直播系统？》](http://www.jianshu.com/p/d391a0069993)\n>[《如何快速的开发一个完整的iOS直播app》](http://mp.weixin.qq.com/s?__biz=MzAxMzE2Mjc2Ng==&mid=2652155243&idx=1&sn=a4e4178511cd58394058588e66be36c1&scene=0#wechat_redirect)\n\n\n","slug":"技术/2016-9-2-GoSpark","published":1,"updated":"2016-09-06T17:24:56.000Z","comments":1,"photos":[],"link":"","_id":"cisw1ptsd0019yrntabbkbzj5","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>GoSpark团队，产品和运营由花姐和老曲亲自操刀。技术团队由严哥牵头，国涛负责后台，宾纷担任设计,我做iOS客户端。</p>\n<p>下面将分为技术，产品，协作三个方面来说。</p>\n<p>最后做一个对我自己的总结。</p>\n<h1 id=\"技术\"><a href=\"#技术\" class=\"headerlink\" title=\"技术\"></a>技术</h1><p>毫无疑问，做直播的技术门槛非常大。之前知乎有一个回答，有兴趣可以进去阅读一下–<a href=\"https://www.zhihu.com/question/42162310\" target=\"_blank\" rel=\"external\">如何搭建一个完整的视频直播系统</a>.</p>\n<p>简单来说，客户端需要涉及到音频/视频处理，图形处理，音频/视频压缩;服务器需要做CDN分发，转码等。如果真的从零开始深入，每种技术都够学几年。</p>\n<p>以上还不包括即时通讯，礼物系统等社交功能。</p>\n<p>好在已经有各个领域的大牛，封装出稳定易用的框架，让我们得以在前人的基础上编程。</p>\n<h2 id=\"直播中，移动端的工作\"><a href=\"#直播中，移动端的工作\" class=\"headerlink\" title=\"直播中，移动端的工作\"></a>直播中，移动端的工作</h2><p>直播中，移动端的工作还不少。需要兼顾推流端和拉流端，以及礼物效果，弹幕效果等等。</p>\n<p>下面简单介绍一下流程，概念。</p>\n<h3 id=\"推流端\"><a href=\"#推流端\" class=\"headerlink\" title=\"推流端\"></a>推流端</h3><p>推流端，就是主播端。通过手机摄像头<code>采集</code>视频数据和麦克风采集音频数据，经过一系列<code>前处理</code>、<code>编码</code>、<code>封装</code>，然后推流到CDN进行分发。</p>\n<h4 id=\"采集\"><a href=\"#采集\" class=\"headerlink\" title=\"采集\"></a>采集</h4><p>采集主要为：<code>视频采集</code>，<code>音频采集</code>。</p>\n<p>采集到的原始音视频的体积是非常大的，需要经过压缩技术处理来提高传输效率。</p>\n<h4 id=\"前处理\"><a href=\"#前处理\" class=\"headerlink\" title=\"前处理\"></a>前处理</h4><p>前处理主要是<code>美颜</code>，<code>水印</code>。</p>\n<h5 id=\"美颜功能\"><a href=\"#美颜功能\" class=\"headerlink\" title=\"美颜功能\"></a>美颜功能</h5><p>美颜几乎是直播的标配功能，它实际上是通过算法去识别图像中的皮肤部分，对皮肤区域进行色值调整。通过颜色对比找到皮肤区域，可以进行色值调整、添加白色图层或调整透明度等来等来达到美白效果。</p>\n<p>磨皮的本质实际上是模糊。而在图像处理领域，模糊就是将像素点的取值与周边的像素点取值相关联。有兴趣的，可以看这篇文章<a href=\"http://www.jianshu.com/p/945fc806a9b4\" target=\"_blank\" rel=\"external\">实时美颜滤镜</a>。</p>\n<h4 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h4><p>为了便于手机视频的推流、拉流以及存储，通常采用视频编码压缩技术来减少视频的体积。</p>\n<p>现在比较常用的视频编码是<code>H.264</code>。在音频方面，比较常用的是用<code>AAC</code>编码格式。</p>\n<p>当然，经过压缩后的视频在播放时必须进行解码。</p>\n<p>另外，<code>硬件编码</code>已经成为移动直播的首选方案，软编码处理在720p以上的视频颓势非常明显。在iOS平台上硬件编码的兼容性比较好，可以直接采用，但在 Android 平台上，MediaCodec 编码器针对不同的芯片平台表现差异还是非常大的，要完全实现全平台兼容的成本还是非常高的。</p>\n<h4 id=\"推流\"><a href=\"#推流\" class=\"headerlink\" title=\"推流\"></a>推流</h4><p>要想用于<code>推流</code>还必须把音视频数据使用传输协议进行<code>封装</code>，变成<code>流数据</code>。</p>\n<p>常见流传输协议有RTSP、RTMP、HLS等，使用RTMP传输的延时通常在1–3秒，对于移动直播这种实时性要求非常高的场景，RTMP也成为移动直播中最常用的流传输协议。</p>\n<p>而在网络传输方面全部自己来做太难了，找CDN服务商提供解决方案，其实是最好的选择。稳定快速和专业的服务，可以节省大量的时间。</p>\n<h3 id=\"拉流端\"><a href=\"#拉流端\" class=\"headerlink\" title=\"拉流端\"></a>拉流端</h3><p>拉流实际是推流的逆过程。</p>\n<h4 id=\"拉流\"><a href=\"#拉流\" class=\"headerlink\" title=\"拉流\"></a>拉流</h4><p>首先通过播放端获取码流。</p>\n<p>标准的拉流格式有RTMP、HLS、FLV等:</p>\n<ul>\n<li><code>RTMP</code>是Adobe的专利协议，直播延迟一般在1–3秒。tcp长连接。</li>\n<li><code>HLS</code>是苹果提出的基于HTTP的流媒体传输协议，优点是HTML5可以直接打开播放，通过社交分享出去，用户也可以直接观看直播，缺点是延迟通常大于10秒。http短连接。</li>\n<li><code>FLV（HTTP-FLV）</code>协议是使用HTTP协议传输流媒体内容的一个协议。直播延迟同样可以做到1–3秒。http长连接。</li>\n</ul>\n<p>三种协议是可以同时使用的，分别用到自己的场景就可以了。</p>\n<h4 id=\"解码和渲染\"><a href=\"#解码和渲染\" class=\"headerlink\" title=\"解码和渲染\"></a>解码和渲染</h4><p>现在一般播放器都是基于<code>ffmepg</code>的，它是一个跨平台的开源视频框架。</p>\n<p>这里有个一<code>硬解码</code>和<code>软解码</code>的概念，硬解码用GPU来解码，减少cpu运算。缺点是兼容不太好。<br>软解码用cpu来解码，容易耗电发热。优点是兼容好。</p>\n<h4 id=\"秒开\"><a href=\"#秒开\" class=\"headerlink\" title=\"秒开\"></a>秒开</h4><p>指点击播放后，一秒内即可看到播放画面。首屏打开越快，说明用户体验越好。技术上指播放器解码第一帧渲染显示画面所花的耗时。</p>\n<p>首帧数据的展示过程，其实是一个下载，解码，渲染的过程。</p>\n<p><code>GOP ( Group of Pictures )</code> 是一组连续的画面，由一张 I 帧和数张 B / P 帧组成，是视频图像编码器和解码器存取的基本单位，它的排列顺序将会一直重复到影像结束。简单地讲，I 帧是一个完整的画面，而 P 帧和 B 帧记录的是相对于 I 帧的变化。<br>如果要秒开，就要减少GOP Cache，也意味着画质下降。</p>\n<blockquote>\n<p>优化策略: 接口机缓存首帧数据，减少 GOP 分片时间，修改播放器逻辑，解析到I帧就开始播放。</p>\n</blockquote>\n<p>我们在这里是使用了B站开源的<a href=\"https://github.com/Bilibili/ijkplayer\" target=\"_blank\" rel=\"external\">ijkplayer</a>的框架，它针对直播进行了优化。</p>\n<h2 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h2><p>直播是 媒体流 ,而 APP 的交互是 API 信令流，两者的状态不能混为一谈。</p>\n<p>尤其是判断网络状况时，不能基于 APP 的交互的 API 状态来判断直播流的状态。</p>\n<p>要想适配各终端和平台，服务端还需要对流进行转码，如支持RTMP、HLS、FLV等格式拉流，支持一路转多路适配不同网络和分辨率的终端设备。</p>\n<h3 id=\"CDN\"><a href=\"#CDN\" class=\"headerlink\" title=\"CDN\"></a>CDN</h3><p>CDN是Content Delivery Network的缩写，即内容分发网络。将网站内容发布到最接近用户的网络”边缘”，让用户就近取得所需要的内容。</p>\n<h3 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h3><p>多台服务器组成一个服务器的集合，每台服务器具有等价的地位，,都可以单独对外提供服务。</p>\n<p>可以将外部请求均匀分配到服务器上，均衡负载能平均分配客户的请求，解决大量并发访问服务的问题。</p>\n<h3 id=\"QoS\"><a href=\"#QoS\" class=\"headerlink\" title=\"QoS\"></a>QoS</h3><p>带宽管理可以限制每一个组群的带宽，让有限的带宽发挥最大的作用。</p>\n<h1 id=\"产品-and-协作\"><a href=\"#产品-and-协作\" class=\"headerlink\" title=\"产品 and 协作\"></a>产品 and 协作</h1><p>产品对用户的定位主要是国外年轻的学生群体。因而在产品的设计上也是有所针对。色彩活泼，内容有趣。</p>\n<p>中间经历了很多次的改版和思考 : )</p>\n<h2 id=\"关于产品设计\"><a href=\"#关于产品设计\" class=\"headerlink\" title=\"关于产品设计\"></a>关于产品设计</h2><p>从花姐认真的办事态度，小到一个眼色都反复思考和改到，学习到了很多。然后偶尔有的东西由于技术或者其他等因素，也可以放掉。</p>\n<p>关于产品的取舍，不是一两句话可以说清，首先是多用其他人的产品，然后是自己去分析产生自己的看法。</p>\n<p>产品需要很多方面的学习，包括设计知识，心理分析，技术实现等等，都需要一定的了解。</p>\n<h2 id=\"运营\"><a href=\"#运营\" class=\"headerlink\" title=\"运营\"></a>运营</h2><p>产品非常需要运营。这个是我以前没有专门思考过的。就算是真的一匹千里马，也需要伯乐才能发挥它的价值。</p>\n<p>公司是商业的，说直白一点，出于什么样的运营其实都或多或少带点销售性质，无论是什么到最后都是作为变现的工具。</p>\n<p>运营定位的比较宽泛，如果产品需要内容，运营就是编辑，需要推广，运营就是市场。所以一个产品，一定需要好的运营才能发挥价值。</p>\n<p>运营又有:</p>\n<ul>\n<li>内容运营</li>\n<li>用户运营</li>\n<li>市场运营</li>\n</ul>\n<h2 id=\"文档化\"><a href=\"#文档化\" class=\"headerlink\" title=\"文档化\"></a>文档化</h2><p>把一些关键的信息，进行统一存储在服务器上，简化协作沟通的成本。</p>\n<ul>\n<li>每日任务说明</li>\n<li>账号存储</li>\n<li>测试反馈</li>\n<li>api说明</li>\n<li>任务记录</li>\n</ul>\n<h2 id=\"scrum保持沟通\"><a href=\"#scrum保持沟通\" class=\"headerlink\" title=\"scrum保持沟通\"></a>scrum保持沟通</h2><p>每天组织的scrum，了解各个成员的工作计划。需要什么样的资源，确定什么样的目标等。</p>\n<h2 id=\"版本总结。\"><a href=\"#版本总结。\" class=\"headerlink\" title=\"版本总结。\"></a>版本总结。</h2><p>在重大节点完成后，进行一次大的总结。每个成员，通过自己的角度，评价协作中其他人员不足的地方，针对不足的地方进行优化。</p>\n<h1 id=\"个人的进步\"><a href=\"#个人的进步\" class=\"headerlink\" title=\"个人的进步\"></a>个人的进步</h1><h2 id=\"有挑战的工作，驱动进步\"><a href=\"#有挑战的工作，驱动进步\" class=\"headerlink\" title=\"有挑战的工作，驱动进步\"></a>有挑战的工作，驱动进步</h2><p>在接受直播项目的时候，都还没有毕业，经验有限。</p>\n<p>但是一整个流程走下来，学到了很多东西。主要谈学习的方法，具体的技术点更是数不过来了。</p>\n<p>总的来说有：</p>\n<ul>\n<li><code>查看issues</code>。工作中大量使用第三方库，直接去开源的项目下看issues,会得到很多有用的信息。</li>\n<li><code>参与开源</code>，发起pr。对使用到的饿了么网络库/来疯直播推流器/leanCloud的ChatKit，发起pr并被成功合并 : )</li>\n<li><code>自动化流程</code>尝试。由于频繁的打包，尝试用python脚本自动编译打包，上传到fir.im发邮件通知。并进一步了解到 <code>Travis CI</code>，能做初步使用。</li>\n<li><code>热修复技术</code>的使用。因为缺乏足够测试，总有些小问题，但是发版的时间成本太大，就学习了<code>JSPatch</code>的使用。</li>\n<li><code>响应式编程</code>了解。针对繁琐的业务逻辑，相对于面对对象，响应式编程更有优势，同时尝试mvvm的学习。以及了解RAC，和学习rxSwift。</li>\n<li><code>调试技能</code>。学会使用一些<code>lldb命令</code>，进行调试，输出视图层级，查看崩溃调用栈等;学习了解到<code>instruments</code>，学会检测内存泄露，让代码更加优化等。</li>\n</ul>\n<h2 id=\"思想的进步\"><a href=\"#思想的进步\" class=\"headerlink\" title=\"思想的进步\"></a>思想的进步</h2><ul>\n<li>保持成长—交流发现了各个领域的牛人。对照自己，还非常的年轻和不足</li>\n<li>协作的认识—产品不是单靠技术，需要各个角色一起完成</li>\n<li>严谨的思维—做产品，第一还需要理解产品的思维，和逻辑。针对各个情况，代码上进行处理和折中取舍等。</li>\n</ul>\n<blockquote>\n<p>本文参考文章:<br><a href=\"http://www.jianshu.com/p/d391a0069993\" target=\"_blank\" rel=\"external\">《如何快速搭建一个完整的移动直播系统？》</a><br><a href=\"http://mp.weixin.qq.com/s?__biz=MzAxMzE2Mjc2Ng==&amp;mid=2652155243&amp;idx=1&amp;sn=a4e4178511cd58394058588e66be36c1&amp;scene=0#wechat_redirect\" target=\"_blank\" rel=\"external\">《如何快速的开发一个完整的iOS直播app》</a></p>\n</blockquote>\n","excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>GoSpark团队，产品和运营由花姐和老曲亲自操刀。技术团队由严哥牵头，国涛负责后台，宾纷担任设计,我做iOS客户端。</p>\n<p>下面将分为技术，产品，协作三个方面来说。</p>\n<p>最后做一个对我自己的总结。</p>\n<h1 id=\"技术\"><a href=\"#技术\" class=\"headerlink\" title=\"技术\"></a>技术</h1><p>毫无疑问，做直播的技术门槛非常大。之前知乎有一个回答，有兴趣可以进去阅读一下–<a href=\"https://www.zhihu.com/question/42162310\">如何搭建一个完整的视频直播系统</a>.</p>\n<p>简单来说，客户端需要涉及到音频/视频处理，图形处理，音频/视频压缩;服务器需要做CDN分发，转码等。如果真的从零开始深入，每种技术都够学几年。</p>\n<p>以上还不包括即时通讯，礼物系统等社交功能。</p>\n<p>好在已经有各个领域的大牛，封装出稳定易用的框架，让我们得以在前人的基础上编程。</p>\n<h2 id=\"直播中，移动端的工作\"><a href=\"#直播中，移动端的工作\" class=\"headerlink\" title=\"直播中，移动端的工作\"></a>直播中，移动端的工作</h2><p>直播中，移动端的工作还不少。需要兼顾推流端和拉流端，以及礼物效果，弹幕效果等等。</p>\n<p>下面简单介绍一下流程，概念。</p>\n<h3 id=\"推流端\"><a href=\"#推流端\" class=\"headerlink\" title=\"推流端\"></a>推流端</h3><p>推流端，就是主播端。通过手机摄像头<code>采集</code>视频数据和麦克风采集音频数据，经过一系列<code>前处理</code>、<code>编码</code>、<code>封装</code>，然后推流到CDN进行分发。</p>\n<h4 id=\"采集\"><a href=\"#采集\" class=\"headerlink\" title=\"采集\"></a>采集</h4><p>采集主要为：<code>视频采集</code>，<code>音频采集</code>。</p>\n<p>采集到的原始音视频的体积是非常大的，需要经过压缩技术处理来提高传输效率。</p>\n<h4 id=\"前处理\"><a href=\"#前处理\" class=\"headerlink\" title=\"前处理\"></a>前处理</h4><p>前处理主要是<code>美颜</code>，<code>水印</code>。</p>\n<h5 id=\"美颜功能\"><a href=\"#美颜功能\" class=\"headerlink\" title=\"美颜功能\"></a>美颜功能</h5><p>美颜几乎是直播的标配功能，它实际上是通过算法去识别图像中的皮肤部分，对皮肤区域进行色值调整。通过颜色对比找到皮肤区域，可以进行色值调整、添加白色图层或调整透明度等来等来达到美白效果。</p>\n<p>磨皮的本质实际上是模糊。而在图像处理领域，模糊就是将像素点的取值与周边的像素点取值相关联。有兴趣的，可以看这篇文章<a href=\"http://www.jianshu.com/p/945fc806a9b4\">实时美颜滤镜</a>。</p>\n<h4 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h4><p>为了便于手机视频的推流、拉流以及存储，通常采用视频编码压缩技术来减少视频的体积。</p>\n<p>现在比较常用的视频编码是<code>H.264</code>。在音频方面，比较常用的是用<code>AAC</code>编码格式。</p>\n<p>当然，经过压缩后的视频在播放时必须进行解码。</p>\n<p>另外，<code>硬件编码</code>已经成为移动直播的首选方案，软编码处理在720p以上的视频颓势非常明显。在iOS平台上硬件编码的兼容性比较好，可以直接采用，但在 Android 平台上，MediaCodec 编码器针对不同的芯片平台表现差异还是非常大的，要完全实现全平台兼容的成本还是非常高的。</p>\n<h4 id=\"推流\"><a href=\"#推流\" class=\"headerlink\" title=\"推流\"></a>推流</h4><p>要想用于<code>推流</code>还必须把音视频数据使用传输协议进行<code>封装</code>，变成<code>流数据</code>。</p>\n<p>常见流传输协议有RTSP、RTMP、HLS等，使用RTMP传输的延时通常在1–3秒，对于移动直播这种实时性要求非常高的场景，RTMP也成为移动直播中最常用的流传输协议。</p>\n<p>而在网络传输方面全部自己来做太难了，找CDN服务商提供解决方案，其实是最好的选择。稳定快速和专业的服务，可以节省大量的时间。</p>\n<h3 id=\"拉流端\"><a href=\"#拉流端\" class=\"headerlink\" title=\"拉流端\"></a>拉流端</h3><p>拉流实际是推流的逆过程。</p>\n<h4 id=\"拉流\"><a href=\"#拉流\" class=\"headerlink\" title=\"拉流\"></a>拉流</h4><p>首先通过播放端获取码流。</p>\n<p>标准的拉流格式有RTMP、HLS、FLV等:</p>\n<ul>\n<li><code>RTMP</code>是Adobe的专利协议，直播延迟一般在1–3秒。tcp长连接。</li>\n<li><code>HLS</code>是苹果提出的基于HTTP的流媒体传输协议，优点是HTML5可以直接打开播放，通过社交分享出去，用户也可以直接观看直播，缺点是延迟通常大于10秒。http短连接。</li>\n<li><code>FLV（HTTP-FLV）</code>协议是使用HTTP协议传输流媒体内容的一个协议。直播延迟同样可以做到1–3秒。http长连接。</li>\n</ul>\n<p>三种协议是可以同时使用的，分别用到自己的场景就可以了。</p>\n<h4 id=\"解码和渲染\"><a href=\"#解码和渲染\" class=\"headerlink\" title=\"解码和渲染\"></a>解码和渲染</h4><p>现在一般播放器都是基于<code>ffmepg</code>的，它是一个跨平台的开源视频框架。</p>\n<p>这里有个一<code>硬解码</code>和<code>软解码</code>的概念，硬解码用GPU来解码，减少cpu运算。缺点是兼容不太好。<br>软解码用cpu来解码，容易耗电发热。优点是兼容好。</p>\n<h4 id=\"秒开\"><a href=\"#秒开\" class=\"headerlink\" title=\"秒开\"></a>秒开</h4><p>指点击播放后，一秒内即可看到播放画面。首屏打开越快，说明用户体验越好。技术上指播放器解码第一帧渲染显示画面所花的耗时。</p>\n<p>首帧数据的展示过程，其实是一个下载，解码，渲染的过程。</p>\n<p><code>GOP ( Group of Pictures )</code> 是一组连续的画面，由一张 I 帧和数张 B / P 帧组成，是视频图像编码器和解码器存取的基本单位，它的排列顺序将会一直重复到影像结束。简单地讲，I 帧是一个完整的画面，而 P 帧和 B 帧记录的是相对于 I 帧的变化。<br>如果要秒开，就要减少GOP Cache，也意味着画质下降。</p>\n<blockquote>\n<p>优化策略: 接口机缓存首帧数据，减少 GOP 分片时间，修改播放器逻辑，解析到I帧就开始播放。</p>\n</blockquote>\n<p>我们在这里是使用了B站开源的<a href=\"https://github.com/Bilibili/ijkplayer\">ijkplayer</a>的框架，它针对直播进行了优化。</p>\n<h2 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h2><p>直播是 媒体流 ,而 APP 的交互是 API 信令流，两者的状态不能混为一谈。</p>\n<p>尤其是判断网络状况时，不能基于 APP 的交互的 API 状态来判断直播流的状态。</p>\n<p>要想适配各终端和平台，服务端还需要对流进行转码，如支持RTMP、HLS、FLV等格式拉流，支持一路转多路适配不同网络和分辨率的终端设备。</p>\n<h3 id=\"CDN\"><a href=\"#CDN\" class=\"headerlink\" title=\"CDN\"></a>CDN</h3><p>CDN是Content Delivery Network的缩写，即内容分发网络。将网站内容发布到最接近用户的网络”边缘”，让用户就近取得所需要的内容。</p>\n<h3 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h3><p>多台服务器组成一个服务器的集合，每台服务器具有等价的地位，,都可以单独对外提供服务。</p>\n<p>可以将外部请求均匀分配到服务器上，均衡负载能平均分配客户的请求，解决大量并发访问服务的问题。</p>\n<h3 id=\"QoS\"><a href=\"#QoS\" class=\"headerlink\" title=\"QoS\"></a>QoS</h3><p>带宽管理可以限制每一个组群的带宽，让有限的带宽发挥最大的作用。</p>\n<h1 id=\"产品-and-协作\"><a href=\"#产品-and-协作\" class=\"headerlink\" title=\"产品 and 协作\"></a>产品 and 协作</h1><p>产品对用户的定位主要是国外年轻的学生群体。因而在产品的设计上也是有所针对。色彩活泼，内容有趣。</p>\n<p>中间经历了很多次的改版和思考 : )</p>\n<h2 id=\"关于产品设计\"><a href=\"#关于产品设计\" class=\"headerlink\" title=\"关于产品设计\"></a>关于产品设计</h2><p>从花姐认真的办事态度，小到一个眼色都反复思考和改到，学习到了很多。然后偶尔有的东西由于技术或者其他等因素，也可以放掉。</p>\n<p>关于产品的取舍，不是一两句话可以说清，首先是多用其他人的产品，然后是自己去分析产生自己的看法。</p>\n<p>产品需要很多方面的学习，包括设计知识，心理分析，技术实现等等，都需要一定的了解。</p>\n<h2 id=\"运营\"><a href=\"#运营\" class=\"headerlink\" title=\"运营\"></a>运营</h2><p>产品非常需要运营。这个是我以前没有专门思考过的。就算是真的一匹千里马，也需要伯乐才能发挥它的价值。</p>\n<p>公司是商业的，说直白一点，出于什么样的运营其实都或多或少带点销售性质，无论是什么到最后都是作为变现的工具。</p>\n<p>运营定位的比较宽泛，如果产品需要内容，运营就是编辑，需要推广，运营就是市场。所以一个产品，一定需要好的运营才能发挥价值。</p>\n<p>运营又有:</p>\n<ul>\n<li>内容运营</li>\n<li>用户运营</li>\n<li>市场运营</li>\n</ul>\n<h2 id=\"文档化\"><a href=\"#文档化\" class=\"headerlink\" title=\"文档化\"></a>文档化</h2><p>把一些关键的信息，进行统一存储在服务器上，简化协作沟通的成本。</p>\n<ul>\n<li>每日任务说明</li>\n<li>账号存储</li>\n<li>测试反馈</li>\n<li>api说明</li>\n<li>任务记录</li>\n</ul>\n<h2 id=\"scrum保持沟通\"><a href=\"#scrum保持沟通\" class=\"headerlink\" title=\"scrum保持沟通\"></a>scrum保持沟通</h2><p>每天组织的scrum，了解各个成员的工作计划。需要什么样的资源，确定什么样的目标等。</p>\n<h2 id=\"版本总结。\"><a href=\"#版本总结。\" class=\"headerlink\" title=\"版本总结。\"></a>版本总结。</h2><p>在重大节点完成后，进行一次大的总结。每个成员，通过自己的角度，评价协作中其他人员不足的地方，针对不足的地方进行优化。</p>\n<h1 id=\"个人的进步\"><a href=\"#个人的进步\" class=\"headerlink\" title=\"个人的进步\"></a>个人的进步</h1><h2 id=\"有挑战的工作，驱动进步\"><a href=\"#有挑战的工作，驱动进步\" class=\"headerlink\" title=\"有挑战的工作，驱动进步\"></a>有挑战的工作，驱动进步</h2><p>在接受直播项目的时候，都还没有毕业，经验有限。</p>\n<p>但是一整个流程走下来，学到了很多东西。主要谈学习的方法，具体的技术点更是数不过来了。</p>\n<p>总的来说有：</p>\n<ul>\n<li><code>查看issues</code>。工作中大量使用第三方库，直接去开源的项目下看issues,会得到很多有用的信息。</li>\n<li><code>参与开源</code>，发起pr。对使用到的饿了么网络库/来疯直播推流器/leanCloud的ChatKit，发起pr并被成功合并 : )</li>\n<li><code>自动化流程</code>尝试。由于频繁的打包，尝试用python脚本自动编译打包，上传到fir.im发邮件通知。并进一步了解到 <code>Travis CI</code>，能做初步使用。</li>\n<li><code>热修复技术</code>的使用。因为缺乏足够测试，总有些小问题，但是发版的时间成本太大，就学习了<code>JSPatch</code>的使用。</li>\n<li><code>响应式编程</code>了解。针对繁琐的业务逻辑，相对于面对对象，响应式编程更有优势，同时尝试mvvm的学习。以及了解RAC，和学习rxSwift。</li>\n<li><code>调试技能</code>。学会使用一些<code>lldb命令</code>，进行调试，输出视图层级，查看崩溃调用栈等;学习了解到<code>instruments</code>，学会检测内存泄露，让代码更加优化等。</li>\n</ul>\n<h2 id=\"思想的进步\"><a href=\"#思想的进步\" class=\"headerlink\" title=\"思想的进步\"></a>思想的进步</h2><ul>\n<li>保持成长—交流发现了各个领域的牛人。对照自己，还非常的年轻和不足</li>\n<li>协作的认识—产品不是单靠技术，需要各个角色一起完成</li>\n<li>严谨的思维—做产品，第一还需要理解产品的思维，和逻辑。针对各个情况，代码上进行处理和折中取舍等。</li>\n</ul>\n<blockquote>\n<p>本文参考文章:<br><a href=\"http://www.jianshu.com/p/d391a0069993\">《如何快速搭建一个完整的移动直播系统？》</a><br><a href=\"http://mp.weixin.qq.com/s?__biz=MzAxMzE2Mjc2Ng==&amp;mid=2652155243&amp;idx=1&amp;sn=a4e4178511cd58394058588e66be36c1&amp;scene=0#wechat_redirect\">《如何快速的开发一个完整的iOS直播app》</a></p>\n</blockquote>\n"},{"layout":"post","title":"实习（二）","date":"2015-11-13T16:00:00.000Z","keywords":null,"description":"工作，实习","_content":"算一算，进来实习已经两个月了。简单回顾。\n\n#九月\n\n##技术\n\n刚进公司，主要任务是熟悉公司的应用：Qpython(可以在安卓手机上进行python编程的应用)。\n\n然后尝试对它进行了一些小的功能改进。比如使用外接键盘时，按tab键会失去焦点的问题，增加功能快捷键等。\n\n从这里，我开始培养看文档的习惯，大部分问题，查阅官方文档就可以解决。对英语渣的我来说，看英文文档到现在仍是一个说不上轻松的事情。但不能因为难，就不做。\n\n期间利用一两个星期，学习公司主要的后台语言python。\n\n说到这里，我推荐一个编程网站，叫萌码。用来入门语法还是挺快的：）\n\n再就是开始使用python做东西了。为我们公司内部，做了一个发布app的日志系统。得到了大家很多指导。\n\n我最大的收获，是对python构建应用有了一个大体的了解，以及ajax异步和用python进行跨域访问。\n\n##熟悉\n\n九月最大的收获，还是对公司的熟悉。\n\n记得当时严哥给我们实习生准备了一个欢迎聚餐，很愉快。\n\n九点半上班，下午五点半下班。\n\n每天八个小时的工作时间，也让我渐渐对大家了解起来。\n\n由于都是同龄人，感觉很放松。我的心里不再那么紧张。\n\n之前的构想里，老板可能是苛刻的，同事可能是冷漠的。\n\n不过恰好相反，老板是平易近人的，同事也是热心的。这让我感觉很自在，有钱难买自在。\n\n过中秋节还发了礼盒，一起吃了自助。nice~\n\n#十月\n##转战ios\n十月最大的转折，就是接到了转学ios工作的任务。\n\n其实我对ios学习的想法曾经也有，奈何屌丝根本用不起iphone，每年的开发者账号也是一笔钱。\n\n现在正是好时机。\n\n时间紧，任务急。匆匆学了一个星期不到，收了十一的假就开始拿项目上手了。\n\n还是一个用户数已经不少的社交应用。随便在我们学校搜一搜附近，都有众多的用户。\n\n北京一线创业团队的工作强度，也确实比较强。\n\n由于经验缺乏，我最终无法继续承担任务。非常遗憾。\n\n不过这一个月，也许是以后影响我最大的时间之一。我学习到了非常多的东西。\n\n这也更坚定了我打磨自己技术的决心，吃苦的决心。\n\n\nThat's all","source":"_posts/生活/2015-11-14-study-2.md","raw":"---\nlayout: post\ntitle: 实习（二）\ndate: 2015-11-14\ncategory: 生活\ntags: \nkeywords: \ndescription: 工作，实习\n---\n算一算，进来实习已经两个月了。简单回顾。\n\n#九月\n\n##技术\n\n刚进公司，主要任务是熟悉公司的应用：Qpython(可以在安卓手机上进行python编程的应用)。\n\n然后尝试对它进行了一些小的功能改进。比如使用外接键盘时，按tab键会失去焦点的问题，增加功能快捷键等。\n\n从这里，我开始培养看文档的习惯，大部分问题，查阅官方文档就可以解决。对英语渣的我来说，看英文文档到现在仍是一个说不上轻松的事情。但不能因为难，就不做。\n\n期间利用一两个星期，学习公司主要的后台语言python。\n\n说到这里，我推荐一个编程网站，叫萌码。用来入门语法还是挺快的：）\n\n再就是开始使用python做东西了。为我们公司内部，做了一个发布app的日志系统。得到了大家很多指导。\n\n我最大的收获，是对python构建应用有了一个大体的了解，以及ajax异步和用python进行跨域访问。\n\n##熟悉\n\n九月最大的收获，还是对公司的熟悉。\n\n记得当时严哥给我们实习生准备了一个欢迎聚餐，很愉快。\n\n九点半上班，下午五点半下班。\n\n每天八个小时的工作时间，也让我渐渐对大家了解起来。\n\n由于都是同龄人，感觉很放松。我的心里不再那么紧张。\n\n之前的构想里，老板可能是苛刻的，同事可能是冷漠的。\n\n不过恰好相反，老板是平易近人的，同事也是热心的。这让我感觉很自在，有钱难买自在。\n\n过中秋节还发了礼盒，一起吃了自助。nice~\n\n#十月\n##转战ios\n十月最大的转折，就是接到了转学ios工作的任务。\n\n其实我对ios学习的想法曾经也有，奈何屌丝根本用不起iphone，每年的开发者账号也是一笔钱。\n\n现在正是好时机。\n\n时间紧，任务急。匆匆学了一个星期不到，收了十一的假就开始拿项目上手了。\n\n还是一个用户数已经不少的社交应用。随便在我们学校搜一搜附近，都有众多的用户。\n\n北京一线创业团队的工作强度，也确实比较强。\n\n由于经验缺乏，我最终无法继续承担任务。非常遗憾。\n\n不过这一个月，也许是以后影响我最大的时间之一。我学习到了非常多的东西。\n\n这也更坚定了我打磨自己技术的决心，吃苦的决心。\n\n\nThat's all","slug":"生活/2015-11-14-study-2","published":1,"updated":"2016-04-10T11:48:58.000Z","comments":1,"photos":[],"link":"","_id":"cisw1ptsh001cyrntg8z95gx0","content":"<p>算一算，进来实习已经两个月了。简单回顾。</p>\n<p>#九月</p>\n<p>##技术</p>\n<p>刚进公司，主要任务是熟悉公司的应用：Qpython(可以在安卓手机上进行python编程的应用)。</p>\n<p>然后尝试对它进行了一些小的功能改进。比如使用外接键盘时，按tab键会失去焦点的问题，增加功能快捷键等。</p>\n<p>从这里，我开始培养看文档的习惯，大部分问题，查阅官方文档就可以解决。对英语渣的我来说，看英文文档到现在仍是一个说不上轻松的事情。但不能因为难，就不做。</p>\n<p>期间利用一两个星期，学习公司主要的后台语言python。</p>\n<p>说到这里，我推荐一个编程网站，叫萌码。用来入门语法还是挺快的：）</p>\n<p>再就是开始使用python做东西了。为我们公司内部，做了一个发布app的日志系统。得到了大家很多指导。</p>\n<p>我最大的收获，是对python构建应用有了一个大体的了解，以及ajax异步和用python进行跨域访问。</p>\n<p>##熟悉</p>\n<p>九月最大的收获，还是对公司的熟悉。</p>\n<p>记得当时严哥给我们实习生准备了一个欢迎聚餐，很愉快。</p>\n<p>九点半上班，下午五点半下班。</p>\n<p>每天八个小时的工作时间，也让我渐渐对大家了解起来。</p>\n<p>由于都是同龄人，感觉很放松。我的心里不再那么紧张。</p>\n<p>之前的构想里，老板可能是苛刻的，同事可能是冷漠的。</p>\n<p>不过恰好相反，老板是平易近人的，同事也是热心的。这让我感觉很自在，有钱难买自在。</p>\n<p>过中秋节还发了礼盒，一起吃了自助。nice~</p>\n<p>#十月</p>\n<p>##转战ios<br>十月最大的转折，就是接到了转学ios工作的任务。</p>\n<p>其实我对ios学习的想法曾经也有，奈何屌丝根本用不起iphone，每年的开发者账号也是一笔钱。</p>\n<p>现在正是好时机。</p>\n<p>时间紧，任务急。匆匆学了一个星期不到，收了十一的假就开始拿项目上手了。</p>\n<p>还是一个用户数已经不少的社交应用。随便在我们学校搜一搜附近，都有众多的用户。</p>\n<p>北京一线创业团队的工作强度，也确实比较强。</p>\n<p>由于经验缺乏，我最终无法继续承担任务。非常遗憾。</p>\n<p>不过这一个月，也许是以后影响我最大的时间之一。我学习到了非常多的东西。</p>\n<p>这也更坚定了我打磨自己技术的决心，吃苦的决心。</p>\n<p>That’s all</p>\n","excerpt":"","more":"<p>算一算，进来实习已经两个月了。简单回顾。</p>\n<p>#九月</p>\n<p>##技术</p>\n<p>刚进公司，主要任务是熟悉公司的应用：Qpython(可以在安卓手机上进行python编程的应用)。</p>\n<p>然后尝试对它进行了一些小的功能改进。比如使用外接键盘时，按tab键会失去焦点的问题，增加功能快捷键等。</p>\n<p>从这里，我开始培养看文档的习惯，大部分问题，查阅官方文档就可以解决。对英语渣的我来说，看英文文档到现在仍是一个说不上轻松的事情。但不能因为难，就不做。</p>\n<p>期间利用一两个星期，学习公司主要的后台语言python。</p>\n<p>说到这里，我推荐一个编程网站，叫萌码。用来入门语法还是挺快的：）</p>\n<p>再就是开始使用python做东西了。为我们公司内部，做了一个发布app的日志系统。得到了大家很多指导。</p>\n<p>我最大的收获，是对python构建应用有了一个大体的了解，以及ajax异步和用python进行跨域访问。</p>\n<p>##熟悉</p>\n<p>九月最大的收获，还是对公司的熟悉。</p>\n<p>记得当时严哥给我们实习生准备了一个欢迎聚餐，很愉快。</p>\n<p>九点半上班，下午五点半下班。</p>\n<p>每天八个小时的工作时间，也让我渐渐对大家了解起来。</p>\n<p>由于都是同龄人，感觉很放松。我的心里不再那么紧张。</p>\n<p>之前的构想里，老板可能是苛刻的，同事可能是冷漠的。</p>\n<p>不过恰好相反，老板是平易近人的，同事也是热心的。这让我感觉很自在，有钱难买自在。</p>\n<p>过中秋节还发了礼盒，一起吃了自助。nice~</p>\n<p>#十月</p>\n<p>##转战ios<br>十月最大的转折，就是接到了转学ios工作的任务。</p>\n<p>其实我对ios学习的想法曾经也有，奈何屌丝根本用不起iphone，每年的开发者账号也是一笔钱。</p>\n<p>现在正是好时机。</p>\n<p>时间紧，任务急。匆匆学了一个星期不到，收了十一的假就开始拿项目上手了。</p>\n<p>还是一个用户数已经不少的社交应用。随便在我们学校搜一搜附近，都有众多的用户。</p>\n<p>北京一线创业团队的工作强度，也确实比较强。</p>\n<p>由于经验缺乏，我最终无法继续承担任务。非常遗憾。</p>\n<p>不过这一个月，也许是以后影响我最大的时间之一。我学习到了非常多的东西。</p>\n<p>这也更坚定了我打磨自己技术的决心，吃苦的决心。</p>\n<p>That’s all</p>\n"},{"layout":"post","title":"2016第一天","date":"2015-12-31T16:00:00.000Z","description":"生活","excerpt":"","_content":"\n#关于2016年\n\n简单规划，之后再回顾一下，铭记历史 ：）\n\n\n##生活要求\n\n最大的要求，是我一直有的毛病。我知道很多年轻人都有的一个毛病.\n\n爱说空头话。\n\n空头愿发的多了，自己可能都不当回事了。\n\n碰到羡慕的事情，说类似一句，啊，真好！我也要这样做！\n\n之后就没有下文了。\n\n开始的时候，会去幻想，这样做得到的美好感觉。生活在自己的幻想中。\n\n发一次空头愿，幻想一次。\n\n但是人应该脚踏实地。\n\n##身体要求\n\n具体来说，就是对自己多做减法咯~\n\n第一，少吃点饭。\n\n东西好吃，也应该有节制。何况还能省钱啊，对不对？\n\n主要还是因为我胖了（逃\n\n第二，少熬夜。\n\n之前身体检查有一点点问题。还有前两天，我老妹，外公外婆，我妈，阿姨全都来督促，要我保重身体。\n\n我答应了。理应当做到。\n\n##新年愿望\n\n我今年的愿望都很实际：\n\n1.一台苹果笔记本，macbookpro.\n\n2.一台iphone.\n\n3.拿到一份期望薪资（4k以上）的工作.\n\n4.在AppStore上线两个以上的应用.\n\n这都是基于我作为一个iOS开发者的合理愿望，是吧？\n\n顺利是不可能的，可是，我不想输。\n\n#2015回顾\n\n##上半年\n\n上半年可以说是在紧张地学习过程中度过的。出于对就业的忧虑，我学习了：java,html,css,javascript,php,安卓。\n\n期间感觉非常充实，也得益于极客学院的朋友们，每天一起讨论技术上的事情，有了学习的氛围。所以说，好的技术社区，是能够提高大家学习的热情的。\n\n因为看到大家拥有自己独立的博客网站，我也试着去做。经历了购买域名，和寻找服务器的过程。买服务器对于学生的我来说，只为了放个博客，有点不划算。最后选择了新浪免费的sae,更重要的是上面有一键建站的东东，只为装逼的我就这样用上了wordpress。\n\n然后跟着极客的大伙一起翻译，弄点小钱。\n\n这不是主要的，重要的是我学会了用一样东西--git。大家远程协作，自然就选择了它，在github上进行协作。\n\n我一度以为，github=git(逃\n\n这段经历，对于我实习时迅速融入公司起到了很好的作用。\n\n##踩坑\n\n由于学了一点点的东西，就想着实践一下。主要还是想捞外快，哈哈\n\n试着自己找项目，网上看到学校有学姐需要微信平台的建设，聊了一下，感觉她挺需要编程的人员。感觉自己是个人才了。\n\n然并卵，第二天我还紧张的去等她说的老总。我带了很多样例和资料去和他谈，还想尽量装作接过几次活的样子，让他信任。结果他和我大谈特谈他们的众筹项目。\n\n意思是，你是个人才，我们需要你加入我们。怎么加入?出几千块钱，出技术。\n\n我听到这些，心里就一万匹草泥马奔过。我又不是傻，我是来赚钱的，不是来给你送钱的。我又送钱又送技术，我有病吗？\n\n没有钱，就不要谈情怀。\n\n我之后听说老师可以带项目，又去找老师。老师倒是爽快，资源也多，靠谱！\n\n最后还是然并卵！\n\n对方公司6000块要做后台+安卓+iOS+微信。而且每块需求也不清楚，也没有设计稿。\n\n其实如果不是已经大三快完了，我也接了。但是学习的成本太大了。我每样都要去学。我的计划是大四就直接去找地方实习了。\n\n老师还是很好的。之后有事情也想着我。也很感激。\n\n这中间我女朋友很支持我。她也因为看视频学习东西，没有及时回消息，给我发了很多次脾气。最后还是选择原谅我了，嘿嘿\n\n##下半年\n\n暑假主要是在家，每天陪外公外婆。我从那时候开始就感觉到，我可能会很少有机会再这样长时间的留在家里了。\n\n还报名学了车。过了科目一，教练说科目场地更换了，就没下文了。今年争取抽时间回去考两门试。\n\n我也果然没有预料错，因为加入现在的公司实习，我最后一个寒假也没有了。\n\n他们一直很疼爱我，教我做人的道理。是身体力行的，潜移默化的。而不是嘴上说教的。\n\n从他们身上，我学会了怎么去爱一个人才是好的。更学会了忍耐，包容，谦虚。\n\n最重要的，是感受老一辈能吃苦的精神。可我自己仍然不够吃苦，每天吃好多的饭，还爱睡懒觉（逃\n\n###实习\n\n到了九月份，我就去找了现在实习的公司。\n\n在这里的成长是飞速的。\n\n要不怎么说，光说不练是假把式呢？假如平时的学习，是练兵。工作，就相当于我们上战场冲杀。\n\n说的再多，都是纸上谈兵。\n\n短短三四个月。我觉得自己有了质的提升。\n\n现在我不害怕任何项目，足够的时间下，我有自信通过自己的学习，完成任何挑战。\n\n而不是像以前，还没做东西，就开始想，哎呀这个好难，我能不能做到。给自己不必要的担心。\n\n再就是学习方法的改变。\n\ngithub,google，各种专业的blog都是我最常获取资料的途径。\n\n而真正的提高，在于会看到自己的短板，寻找对应的书籍提升自己的技术深度。而不是只会做一个搬运工。能看到自己的短板，也是由于工作后，见识到很多东西。\n\n要保持学习的热情，以及谦逊。\n\n\n\n","source":"_posts/生活/2016-1-1-life.markdown","raw":"---\nlayout: post\ntitle: 2016第一天\ndate: 2016-1-1\ncategory: 生活\ndescription: 生活\nexcerpt: 回顾2015的一年，规划未来的一年目标\n---\n\n#关于2016年\n\n简单规划，之后再回顾一下，铭记历史 ：）\n\n\n##生活要求\n\n最大的要求，是我一直有的毛病。我知道很多年轻人都有的一个毛病.\n\n爱说空头话。\n\n空头愿发的多了，自己可能都不当回事了。\n\n碰到羡慕的事情，说类似一句，啊，真好！我也要这样做！\n\n之后就没有下文了。\n\n开始的时候，会去幻想，这样做得到的美好感觉。生活在自己的幻想中。\n\n发一次空头愿，幻想一次。\n\n但是人应该脚踏实地。\n\n##身体要求\n\n具体来说，就是对自己多做减法咯~\n\n第一，少吃点饭。\n\n东西好吃，也应该有节制。何况还能省钱啊，对不对？\n\n主要还是因为我胖了（逃\n\n第二，少熬夜。\n\n之前身体检查有一点点问题。还有前两天，我老妹，外公外婆，我妈，阿姨全都来督促，要我保重身体。\n\n我答应了。理应当做到。\n\n##新年愿望\n\n我今年的愿望都很实际：\n\n1.一台苹果笔记本，macbookpro.\n\n2.一台iphone.\n\n3.拿到一份期望薪资（4k以上）的工作.\n\n4.在AppStore上线两个以上的应用.\n\n这都是基于我作为一个iOS开发者的合理愿望，是吧？\n\n顺利是不可能的，可是，我不想输。\n\n#2015回顾\n\n##上半年\n\n上半年可以说是在紧张地学习过程中度过的。出于对就业的忧虑，我学习了：java,html,css,javascript,php,安卓。\n\n期间感觉非常充实，也得益于极客学院的朋友们，每天一起讨论技术上的事情，有了学习的氛围。所以说，好的技术社区，是能够提高大家学习的热情的。\n\n因为看到大家拥有自己独立的博客网站，我也试着去做。经历了购买域名，和寻找服务器的过程。买服务器对于学生的我来说，只为了放个博客，有点不划算。最后选择了新浪免费的sae,更重要的是上面有一键建站的东东，只为装逼的我就这样用上了wordpress。\n\n然后跟着极客的大伙一起翻译，弄点小钱。\n\n这不是主要的，重要的是我学会了用一样东西--git。大家远程协作，自然就选择了它，在github上进行协作。\n\n我一度以为，github=git(逃\n\n这段经历，对于我实习时迅速融入公司起到了很好的作用。\n\n##踩坑\n\n由于学了一点点的东西，就想着实践一下。主要还是想捞外快，哈哈\n\n试着自己找项目，网上看到学校有学姐需要微信平台的建设，聊了一下，感觉她挺需要编程的人员。感觉自己是个人才了。\n\n然并卵，第二天我还紧张的去等她说的老总。我带了很多样例和资料去和他谈，还想尽量装作接过几次活的样子，让他信任。结果他和我大谈特谈他们的众筹项目。\n\n意思是，你是个人才，我们需要你加入我们。怎么加入?出几千块钱，出技术。\n\n我听到这些，心里就一万匹草泥马奔过。我又不是傻，我是来赚钱的，不是来给你送钱的。我又送钱又送技术，我有病吗？\n\n没有钱，就不要谈情怀。\n\n我之后听说老师可以带项目，又去找老师。老师倒是爽快，资源也多，靠谱！\n\n最后还是然并卵！\n\n对方公司6000块要做后台+安卓+iOS+微信。而且每块需求也不清楚，也没有设计稿。\n\n其实如果不是已经大三快完了，我也接了。但是学习的成本太大了。我每样都要去学。我的计划是大四就直接去找地方实习了。\n\n老师还是很好的。之后有事情也想着我。也很感激。\n\n这中间我女朋友很支持我。她也因为看视频学习东西，没有及时回消息，给我发了很多次脾气。最后还是选择原谅我了，嘿嘿\n\n##下半年\n\n暑假主要是在家，每天陪外公外婆。我从那时候开始就感觉到，我可能会很少有机会再这样长时间的留在家里了。\n\n还报名学了车。过了科目一，教练说科目场地更换了，就没下文了。今年争取抽时间回去考两门试。\n\n我也果然没有预料错，因为加入现在的公司实习，我最后一个寒假也没有了。\n\n他们一直很疼爱我，教我做人的道理。是身体力行的，潜移默化的。而不是嘴上说教的。\n\n从他们身上，我学会了怎么去爱一个人才是好的。更学会了忍耐，包容，谦虚。\n\n最重要的，是感受老一辈能吃苦的精神。可我自己仍然不够吃苦，每天吃好多的饭，还爱睡懒觉（逃\n\n###实习\n\n到了九月份，我就去找了现在实习的公司。\n\n在这里的成长是飞速的。\n\n要不怎么说，光说不练是假把式呢？假如平时的学习，是练兵。工作，就相当于我们上战场冲杀。\n\n说的再多，都是纸上谈兵。\n\n短短三四个月。我觉得自己有了质的提升。\n\n现在我不害怕任何项目，足够的时间下，我有自信通过自己的学习，完成任何挑战。\n\n而不是像以前，还没做东西，就开始想，哎呀这个好难，我能不能做到。给自己不必要的担心。\n\n再就是学习方法的改变。\n\ngithub,google，各种专业的blog都是我最常获取资料的途径。\n\n而真正的提高，在于会看到自己的短板，寻找对应的书籍提升自己的技术深度。而不是只会做一个搬运工。能看到自己的短板，也是由于工作后，见识到很多东西。\n\n要保持学习的热情，以及谦逊。\n\n\n\n","slug":"生活/2016-1-1-life","published":1,"updated":"2016-04-10T11:49:45.000Z","comments":1,"photos":[],"link":"","_id":"cisw1ptsj001fyrnt7nkjkrk2","content":"<p>#关于2016年</p>\n<p>简单规划，之后再回顾一下，铭记历史 ：）</p>\n<p>##生活要求</p>\n<p>最大的要求，是我一直有的毛病。我知道很多年轻人都有的一个毛病.</p>\n<p>爱说空头话。</p>\n<p>空头愿发的多了，自己可能都不当回事了。</p>\n<p>碰到羡慕的事情，说类似一句，啊，真好！我也要这样做！</p>\n<p>之后就没有下文了。</p>\n<p>开始的时候，会去幻想，这样做得到的美好感觉。生活在自己的幻想中。</p>\n<p>发一次空头愿，幻想一次。</p>\n<p>但是人应该脚踏实地。</p>\n<p>##身体要求</p>\n<p>具体来说，就是对自己多做减法咯~</p>\n<p>第一，少吃点饭。</p>\n<p>东西好吃，也应该有节制。何况还能省钱啊，对不对？</p>\n<p>主要还是因为我胖了（逃</p>\n<p>第二，少熬夜。</p>\n<p>之前身体检查有一点点问题。还有前两天，我老妹，外公外婆，我妈，阿姨全都来督促，要我保重身体。</p>\n<p>我答应了。理应当做到。</p>\n<p>##新年愿望</p>\n<p>我今年的愿望都很实际：</p>\n<p>1.一台苹果笔记本，macbookpro.</p>\n<p>2.一台iphone.</p>\n<p>3.拿到一份期望薪资（4k以上）的工作.</p>\n<p>4.在AppStore上线两个以上的应用.</p>\n<p>这都是基于我作为一个iOS开发者的合理愿望，是吧？</p>\n<p>顺利是不可能的，可是，我不想输。</p>\n<p>#2015回顾</p>\n<p>##上半年</p>\n<p>上半年可以说是在紧张地学习过程中度过的。出于对就业的忧虑，我学习了：java,html,css,javascript,php,安卓。</p>\n<p>期间感觉非常充实，也得益于极客学院的朋友们，每天一起讨论技术上的事情，有了学习的氛围。所以说，好的技术社区，是能够提高大家学习的热情的。</p>\n<p>因为看到大家拥有自己独立的博客网站，我也试着去做。经历了购买域名，和寻找服务器的过程。买服务器对于学生的我来说，只为了放个博客，有点不划算。最后选择了新浪免费的sae,更重要的是上面有一键建站的东东，只为装逼的我就这样用上了wordpress。</p>\n<p>然后跟着极客的大伙一起翻译，弄点小钱。</p>\n<p>这不是主要的，重要的是我学会了用一样东西–git。大家远程协作，自然就选择了它，在github上进行协作。</p>\n<p>我一度以为，github=git(逃</p>\n<p>这段经历，对于我实习时迅速融入公司起到了很好的作用。</p>\n<p>##踩坑</p>\n<p>由于学了一点点的东西，就想着实践一下。主要还是想捞外快，哈哈</p>\n<p>试着自己找项目，网上看到学校有学姐需要微信平台的建设，聊了一下，感觉她挺需要编程的人员。感觉自己是个人才了。</p>\n<p>然并卵，第二天我还紧张的去等她说的老总。我带了很多样例和资料去和他谈，还想尽量装作接过几次活的样子，让他信任。结果他和我大谈特谈他们的众筹项目。</p>\n<p>意思是，你是个人才，我们需要你加入我们。怎么加入?出几千块钱，出技术。</p>\n<p>我听到这些，心里就一万匹草泥马奔过。我又不是傻，我是来赚钱的，不是来给你送钱的。我又送钱又送技术，我有病吗？</p>\n<p>没有钱，就不要谈情怀。</p>\n<p>我之后听说老师可以带项目，又去找老师。老师倒是爽快，资源也多，靠谱！</p>\n<p>最后还是然并卵！</p>\n<p>对方公司6000块要做后台+安卓+iOS+微信。而且每块需求也不清楚，也没有设计稿。</p>\n<p>其实如果不是已经大三快完了，我也接了。但是学习的成本太大了。我每样都要去学。我的计划是大四就直接去找地方实习了。</p>\n<p>老师还是很好的。之后有事情也想着我。也很感激。</p>\n<p>这中间我女朋友很支持我。她也因为看视频学习东西，没有及时回消息，给我发了很多次脾气。最后还是选择原谅我了，嘿嘿</p>\n<p>##下半年</p>\n<p>暑假主要是在家，每天陪外公外婆。我从那时候开始就感觉到，我可能会很少有机会再这样长时间的留在家里了。</p>\n<p>还报名学了车。过了科目一，教练说科目场地更换了，就没下文了。今年争取抽时间回去考两门试。</p>\n<p>我也果然没有预料错，因为加入现在的公司实习，我最后一个寒假也没有了。</p>\n<p>他们一直很疼爱我，教我做人的道理。是身体力行的，潜移默化的。而不是嘴上说教的。</p>\n<p>从他们身上，我学会了怎么去爱一个人才是好的。更学会了忍耐，包容，谦虚。</p>\n<p>最重要的，是感受老一辈能吃苦的精神。可我自己仍然不够吃苦，每天吃好多的饭，还爱睡懒觉（逃</p>\n<p>###实习</p>\n<p>到了九月份，我就去找了现在实习的公司。</p>\n<p>在这里的成长是飞速的。</p>\n<p>要不怎么说，光说不练是假把式呢？假如平时的学习，是练兵。工作，就相当于我们上战场冲杀。</p>\n<p>说的再多，都是纸上谈兵。</p>\n<p>短短三四个月。我觉得自己有了质的提升。</p>\n<p>现在我不害怕任何项目，足够的时间下，我有自信通过自己的学习，完成任何挑战。</p>\n<p>而不是像以前，还没做东西，就开始想，哎呀这个好难，我能不能做到。给自己不必要的担心。</p>\n<p>再就是学习方法的改变。</p>\n<p>github,google，各种专业的blog都是我最常获取资料的途径。</p>\n<p>而真正的提高，在于会看到自己的短板，寻找对应的书籍提升自己的技术深度。而不是只会做一个搬运工。能看到自己的短板，也是由于工作后，见识到很多东西。</p>\n<p>要保持学习的热情，以及谦逊。</p>\n","more":"<p>#关于2016年</p>\n<p>简单规划，之后再回顾一下，铭记历史 ：）</p>\n<p>##生活要求</p>\n<p>最大的要求，是我一直有的毛病。我知道很多年轻人都有的一个毛病.</p>\n<p>爱说空头话。</p>\n<p>空头愿发的多了，自己可能都不当回事了。</p>\n<p>碰到羡慕的事情，说类似一句，啊，真好！我也要这样做！</p>\n<p>之后就没有下文了。</p>\n<p>开始的时候，会去幻想，这样做得到的美好感觉。生活在自己的幻想中。</p>\n<p>发一次空头愿，幻想一次。</p>\n<p>但是人应该脚踏实地。</p>\n<p>##身体要求</p>\n<p>具体来说，就是对自己多做减法咯~</p>\n<p>第一，少吃点饭。</p>\n<p>东西好吃，也应该有节制。何况还能省钱啊，对不对？</p>\n<p>主要还是因为我胖了（逃</p>\n<p>第二，少熬夜。</p>\n<p>之前身体检查有一点点问题。还有前两天，我老妹，外公外婆，我妈，阿姨全都来督促，要我保重身体。</p>\n<p>我答应了。理应当做到。</p>\n<p>##新年愿望</p>\n<p>我今年的愿望都很实际：</p>\n<p>1.一台苹果笔记本，macbookpro.</p>\n<p>2.一台iphone.</p>\n<p>3.拿到一份期望薪资（4k以上）的工作.</p>\n<p>4.在AppStore上线两个以上的应用.</p>\n<p>这都是基于我作为一个iOS开发者的合理愿望，是吧？</p>\n<p>顺利是不可能的，可是，我不想输。</p>\n<p>#2015回顾</p>\n<p>##上半年</p>\n<p>上半年可以说是在紧张地学习过程中度过的。出于对就业的忧虑，我学习了：java,html,css,javascript,php,安卓。</p>\n<p>期间感觉非常充实，也得益于极客学院的朋友们，每天一起讨论技术上的事情，有了学习的氛围。所以说，好的技术社区，是能够提高大家学习的热情的。</p>\n<p>因为看到大家拥有自己独立的博客网站，我也试着去做。经历了购买域名，和寻找服务器的过程。买服务器对于学生的我来说，只为了放个博客，有点不划算。最后选择了新浪免费的sae,更重要的是上面有一键建站的东东，只为装逼的我就这样用上了wordpress。</p>\n<p>然后跟着极客的大伙一起翻译，弄点小钱。</p>\n<p>这不是主要的，重要的是我学会了用一样东西–git。大家远程协作，自然就选择了它，在github上进行协作。</p>\n<p>我一度以为，github=git(逃</p>\n<p>这段经历，对于我实习时迅速融入公司起到了很好的作用。</p>\n<p>##踩坑</p>\n<p>由于学了一点点的东西，就想着实践一下。主要还是想捞外快，哈哈</p>\n<p>试着自己找项目，网上看到学校有学姐需要微信平台的建设，聊了一下，感觉她挺需要编程的人员。感觉自己是个人才了。</p>\n<p>然并卵，第二天我还紧张的去等她说的老总。我带了很多样例和资料去和他谈，还想尽量装作接过几次活的样子，让他信任。结果他和我大谈特谈他们的众筹项目。</p>\n<p>意思是，你是个人才，我们需要你加入我们。怎么加入?出几千块钱，出技术。</p>\n<p>我听到这些，心里就一万匹草泥马奔过。我又不是傻，我是来赚钱的，不是来给你送钱的。我又送钱又送技术，我有病吗？</p>\n<p>没有钱，就不要谈情怀。</p>\n<p>我之后听说老师可以带项目，又去找老师。老师倒是爽快，资源也多，靠谱！</p>\n<p>最后还是然并卵！</p>\n<p>对方公司6000块要做后台+安卓+iOS+微信。而且每块需求也不清楚，也没有设计稿。</p>\n<p>其实如果不是已经大三快完了，我也接了。但是学习的成本太大了。我每样都要去学。我的计划是大四就直接去找地方实习了。</p>\n<p>老师还是很好的。之后有事情也想着我。也很感激。</p>\n<p>这中间我女朋友很支持我。她也因为看视频学习东西，没有及时回消息，给我发了很多次脾气。最后还是选择原谅我了，嘿嘿</p>\n<p>##下半年</p>\n<p>暑假主要是在家，每天陪外公外婆。我从那时候开始就感觉到，我可能会很少有机会再这样长时间的留在家里了。</p>\n<p>还报名学了车。过了科目一，教练说科目场地更换了，就没下文了。今年争取抽时间回去考两门试。</p>\n<p>我也果然没有预料错，因为加入现在的公司实习，我最后一个寒假也没有了。</p>\n<p>他们一直很疼爱我，教我做人的道理。是身体力行的，潜移默化的。而不是嘴上说教的。</p>\n<p>从他们身上，我学会了怎么去爱一个人才是好的。更学会了忍耐，包容，谦虚。</p>\n<p>最重要的，是感受老一辈能吃苦的精神。可我自己仍然不够吃苦，每天吃好多的饭，还爱睡懒觉（逃</p>\n<p>###实习</p>\n<p>到了九月份，我就去找了现在实习的公司。</p>\n<p>在这里的成长是飞速的。</p>\n<p>要不怎么说，光说不练是假把式呢？假如平时的学习，是练兵。工作，就相当于我们上战场冲杀。</p>\n<p>说的再多，都是纸上谈兵。</p>\n<p>短短三四个月。我觉得自己有了质的提升。</p>\n<p>现在我不害怕任何项目，足够的时间下，我有自信通过自己的学习，完成任何挑战。</p>\n<p>而不是像以前，还没做东西，就开始想，哎呀这个好难，我能不能做到。给自己不必要的担心。</p>\n<p>再就是学习方法的改变。</p>\n<p>github,google，各种专业的blog都是我最常获取资料的途径。</p>\n<p>而真正的提高，在于会看到自己的短板，寻找对应的书籍提升自己的技术深度。而不是只会做一个搬运工。能看到自己的短板，也是由于工作后，见识到很多东西。</p>\n<p>要保持学习的热情，以及谦逊。</p>\n"},{"layout":"post","title":"一个人的磨练","date":"2016-01-21T16:00:00.000Z","description":"生活","excerpt":"","_content":"\n#之前的生活\n之前的生活，每天都是一样，上班或者在宿舍刷刷社交信息，看一下论坛帖子和前辈的文章。\n\n和女朋友吃饭。\n\n过得还算好。\n\n对技术或者生活的很多信息也都跟得上。但是总感觉好像少了点什么。\n\n可能是一种充实感?\n\n或者说，我没有能好好地利用起它们来。\n\n##遇到的问题\n\n首先大学英语四级，我到现在都没有过，已经出了三次成绩了，考了第四次。\n\n不过我还是不抱什么希望了。\n\n第一次，358.\n\n第二次，大三上期，由于女朋友的监督，400。\n\n第三次，忘记先填听力，354。\n\n但是怎么看，我也就四百左右的战斗值了。\n\n我骨子里不是一个勤快的人，我也试图寻找所谓的捷径。无一例外的，都是听说读写的练。\n\n这无法偷懒。\n\n所以我没过四级，也变相得说明了，我没有花时间在上面。\n\n我也并不相信学习壁垒有多大 :  )\n\n事实上，我也的确没有花时间在上面。\n\n##自我分析\n\n我的时间上哪去了？上网。\n\n微博，微信，空间，博客，QQ，知乎。\n\n这几样东西带来的信息，每天不断的冲击着我。\n\n我以为，关注前辈，可以快速的获取他的经验，关注前沿的信息的分享，可以让自己更有极客的范。\n\n我的微博收藏里，有很多这样的信息。最后不知道看过一遍没有？\n\n同样类似的，还有github库的收藏，我收藏很多流行或者有用的库，却并没有真正去读过它们的代码。\n\n我还收藏那些问题的网页，这本来是个好事。但是我只做收藏，意图只是下次不必重新搜索，但是后来也没有再翻过。也没有专门写日志，深入去研究碰到的问题。\n\n归根结底到，我怕麻烦。\n\n#之后的生活\n\n最大期望，别怕麻烦。\n\n只问自己应该不应该做，而不想麻烦不麻烦，舒服不舒服。\n\n希望自己能跳不断地跳出安全区： ）","source":"_posts/生活/2016-1-22-plan.markdown","raw":"---\nlayout: post\ntitle: 一个人的磨练\ndate: 2016-1-22\ncategory: 生活 \ndescription: 生活\nexcerpt: 今天小猪头走了，我也思考了一下该如何真正发挥业余的时间\n---\n\n#之前的生活\n之前的生活，每天都是一样，上班或者在宿舍刷刷社交信息，看一下论坛帖子和前辈的文章。\n\n和女朋友吃饭。\n\n过得还算好。\n\n对技术或者生活的很多信息也都跟得上。但是总感觉好像少了点什么。\n\n可能是一种充实感?\n\n或者说，我没有能好好地利用起它们来。\n\n##遇到的问题\n\n首先大学英语四级，我到现在都没有过，已经出了三次成绩了，考了第四次。\n\n不过我还是不抱什么希望了。\n\n第一次，358.\n\n第二次，大三上期，由于女朋友的监督，400。\n\n第三次，忘记先填听力，354。\n\n但是怎么看，我也就四百左右的战斗值了。\n\n我骨子里不是一个勤快的人，我也试图寻找所谓的捷径。无一例外的，都是听说读写的练。\n\n这无法偷懒。\n\n所以我没过四级，也变相得说明了，我没有花时间在上面。\n\n我也并不相信学习壁垒有多大 :  )\n\n事实上，我也的确没有花时间在上面。\n\n##自我分析\n\n我的时间上哪去了？上网。\n\n微博，微信，空间，博客，QQ，知乎。\n\n这几样东西带来的信息，每天不断的冲击着我。\n\n我以为，关注前辈，可以快速的获取他的经验，关注前沿的信息的分享，可以让自己更有极客的范。\n\n我的微博收藏里，有很多这样的信息。最后不知道看过一遍没有？\n\n同样类似的，还有github库的收藏，我收藏很多流行或者有用的库，却并没有真正去读过它们的代码。\n\n我还收藏那些问题的网页，这本来是个好事。但是我只做收藏，意图只是下次不必重新搜索，但是后来也没有再翻过。也没有专门写日志，深入去研究碰到的问题。\n\n归根结底到，我怕麻烦。\n\n#之后的生活\n\n最大期望，别怕麻烦。\n\n只问自己应该不应该做，而不想麻烦不麻烦，舒服不舒服。\n\n希望自己能跳不断地跳出安全区： ）","slug":"生活/2016-1-22-plan","published":1,"updated":"2016-04-10T11:55:16.000Z","comments":1,"photos":[],"link":"","_id":"cisw1ptsk001iyrntgf3f5s9o","content":"<p>#之前的生活<br>之前的生活，每天都是一样，上班或者在宿舍刷刷社交信息，看一下论坛帖子和前辈的文章。</p>\n<p>和女朋友吃饭。</p>\n<p>过得还算好。</p>\n<p>对技术或者生活的很多信息也都跟得上。但是总感觉好像少了点什么。</p>\n<p>可能是一种充实感?</p>\n<p>或者说，我没有能好好地利用起它们来。</p>\n<p>##遇到的问题</p>\n<p>首先大学英语四级，我到现在都没有过，已经出了三次成绩了，考了第四次。</p>\n<p>不过我还是不抱什么希望了。</p>\n<p>第一次，358.</p>\n<p>第二次，大三上期，由于女朋友的监督，400。</p>\n<p>第三次，忘记先填听力，354。</p>\n<p>但是怎么看，我也就四百左右的战斗值了。</p>\n<p>我骨子里不是一个勤快的人，我也试图寻找所谓的捷径。无一例外的，都是听说读写的练。</p>\n<p>这无法偷懒。</p>\n<p>所以我没过四级，也变相得说明了，我没有花时间在上面。</p>\n<p>我也并不相信学习壁垒有多大 :  )</p>\n<p>事实上，我也的确没有花时间在上面。</p>\n<p>##自我分析</p>\n<p>我的时间上哪去了？上网。</p>\n<p>微博，微信，空间，博客，QQ，知乎。</p>\n<p>这几样东西带来的信息，每天不断的冲击着我。</p>\n<p>我以为，关注前辈，可以快速的获取他的经验，关注前沿的信息的分享，可以让自己更有极客的范。</p>\n<p>我的微博收藏里，有很多这样的信息。最后不知道看过一遍没有？</p>\n<p>同样类似的，还有github库的收藏，我收藏很多流行或者有用的库，却并没有真正去读过它们的代码。</p>\n<p>我还收藏那些问题的网页，这本来是个好事。但是我只做收藏，意图只是下次不必重新搜索，但是后来也没有再翻过。也没有专门写日志，深入去研究碰到的问题。</p>\n<p>归根结底到，我怕麻烦。</p>\n<p>#之后的生活</p>\n<p>最大期望，别怕麻烦。</p>\n<p>只问自己应该不应该做，而不想麻烦不麻烦，舒服不舒服。</p>\n<p>希望自己能跳不断地跳出安全区： ）</p>\n","more":"<p>#之前的生活<br>之前的生活，每天都是一样，上班或者在宿舍刷刷社交信息，看一下论坛帖子和前辈的文章。</p>\n<p>和女朋友吃饭。</p>\n<p>过得还算好。</p>\n<p>对技术或者生活的很多信息也都跟得上。但是总感觉好像少了点什么。</p>\n<p>可能是一种充实感?</p>\n<p>或者说，我没有能好好地利用起它们来。</p>\n<p>##遇到的问题</p>\n<p>首先大学英语四级，我到现在都没有过，已经出了三次成绩了，考了第四次。</p>\n<p>不过我还是不抱什么希望了。</p>\n<p>第一次，358.</p>\n<p>第二次，大三上期，由于女朋友的监督，400。</p>\n<p>第三次，忘记先填听力，354。</p>\n<p>但是怎么看，我也就四百左右的战斗值了。</p>\n<p>我骨子里不是一个勤快的人，我也试图寻找所谓的捷径。无一例外的，都是听说读写的练。</p>\n<p>这无法偷懒。</p>\n<p>所以我没过四级，也变相得说明了，我没有花时间在上面。</p>\n<p>我也并不相信学习壁垒有多大 :  )</p>\n<p>事实上，我也的确没有花时间在上面。</p>\n<p>##自我分析</p>\n<p>我的时间上哪去了？上网。</p>\n<p>微博，微信，空间，博客，QQ，知乎。</p>\n<p>这几样东西带来的信息，每天不断的冲击着我。</p>\n<p>我以为，关注前辈，可以快速的获取他的经验，关注前沿的信息的分享，可以让自己更有极客的范。</p>\n<p>我的微博收藏里，有很多这样的信息。最后不知道看过一遍没有？</p>\n<p>同样类似的，还有github库的收藏，我收藏很多流行或者有用的库，却并没有真正去读过它们的代码。</p>\n<p>我还收藏那些问题的网页，这本来是个好事。但是我只做收藏，意图只是下次不必重新搜索，但是后来也没有再翻过。也没有专门写日志，深入去研究碰到的问题。</p>\n<p>归根结底到，我怕麻烦。</p>\n<p>#之后的生活</p>\n<p>最大期望，别怕麻烦。</p>\n<p>只问自己应该不应该做，而不想麻烦不麻烦，舒服不舒服。</p>\n<p>希望自己能跳不断地跳出安全区： ）</p>\n"},{"layout":"post","title":"iOS技能图谱","date":"2016-01-31T16:00:00.000Z","description":"生活","excerpt":"","_content":"\n## 前言\n之前受 StuQ 之托，整理了iOS 技能图谱，分享给大家。大家如果觉得有什么推荐的，也可以留言回复。\n\n我对技能图谱的价值持谨慎的态度，因为本身技术更新就比较快，图谱很难做到面面俱到和与时俱进，比如说最近有一个集成平台 https://buddybuild.com/ 就很火，我很难保证快速更新这些内容。\n\n但是话说回来，有一个图谱，或许对一些人来说也是一个知识的查漏补缺的工具，看看也不会怀孕不是？\n\n以下是图谱正文内容。\n\n# 编程语言\n\n\n\n- Swift\n- Objective-C\n- C++/C\n- JavaScript\n\n# 操作系统\n\n\n\n- Mac OSX\n- iOS\n- watchOS\n- tvOS\n- Linux 常用命令\n\n# 开发基础\n\n\n- UI 控件\n- Storyboard & Xib\n- Core Data & Sqlite\n- Core Graphics\n- Animation\n- Block & GCD\n- Test Case 编写\n- Framework\n- Autolayout\n- 手势识别，重力感应\n\n# 开发进阶\n\n\n- 引用计数\n- Runtime\n- Runloop\n- 对象模型\n- Hybrid\n- 沙盒机制\n- AVFoundation\n- Core Text\n-逆向与安全\n - class dump\n - IDA Pro\n - Hopper\n - iOS Class Guard\n\n# 设计模式\n\n\n- MVC\n- MVVM\n- 通知\n- 代理\n- KVO\n- 工厂模式\n- 命令模式\n\n# 函数式编程\n\n\n\n- ReactiveCocoa\n- RxSwift\n\n# 开发工具\n\n\n- IDE\n - Xcode\n - AppCode\n- 调试工具\n - Charles、Wireshark\n - Reveal\n - Instruments\n- 插件\n - Alcatraz\n - VVDocument\n - XVim\n - FuzzyAutocompletePlugin\n - KSImageNamed-Xcode\n- 辅助工具\n - xScope\n - ImageOptim\n - 马克鳗\n - Dash\n - Deploymate\n - FauxPas\n - PaintCode\n- 命令行工具\n - xcodebuild、xcode-select\n - nomad\n - xctool\n - fastlane\n- 持续集成\n - Jenkins\n - Travis CI\n - Bot\n\n# 开源项目\n\n\n\n- AFNetworking & Alamofire\n- Masonry\n- SDWebImage\n- SwiftyJSON\n- JSPatch\n- React Native\n\n# 包管理\n\n\n- CocoaPods\n- Carthage\n- Swift Package Manager\n\n# App打包上传与审核\n\n\n- Apple Developer 网站\n- iTunes Connect 网站\n- IAP\n- 加急审核申请\n- 打包脚本\n\n# 第三方服务\n\n\n\n- 崩溃收集\n - Bugly\n - Crashlytics\n - BugHD\n- 数据统计\n - Google Analytics\n - 友盟\n - MTA\n - Flurry\n - App Annie\n- 应用分发\n - TestFlight\n - 蒲公英\n - FIR\n \n>以上均来自[iOS 技能图谱](http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=451444627&idx=1&sn=2966dc944518dd88798217b9e340f0b2&scene=0#wechat_redirect)","source":"_posts/生活/2016-2-1-PlanOfiOS.markdown","raw":"---\nlayout: post\ntitle: iOS技能图谱\ndate: 2016-2-1\ncategory: 生活 \ndescription: 生活\nexcerpt: 来自唐巧大大整理的iOS技能图谱，生活空闲时，看一看怎么点技能树 \n---\n\n## 前言\n之前受 StuQ 之托，整理了iOS 技能图谱，分享给大家。大家如果觉得有什么推荐的，也可以留言回复。\n\n我对技能图谱的价值持谨慎的态度，因为本身技术更新就比较快，图谱很难做到面面俱到和与时俱进，比如说最近有一个集成平台 https://buddybuild.com/ 就很火，我很难保证快速更新这些内容。\n\n但是话说回来，有一个图谱，或许对一些人来说也是一个知识的查漏补缺的工具，看看也不会怀孕不是？\n\n以下是图谱正文内容。\n\n# 编程语言\n\n\n\n- Swift\n- Objective-C\n- C++/C\n- JavaScript\n\n# 操作系统\n\n\n\n- Mac OSX\n- iOS\n- watchOS\n- tvOS\n- Linux 常用命令\n\n# 开发基础\n\n\n- UI 控件\n- Storyboard & Xib\n- Core Data & Sqlite\n- Core Graphics\n- Animation\n- Block & GCD\n- Test Case 编写\n- Framework\n- Autolayout\n- 手势识别，重力感应\n\n# 开发进阶\n\n\n- 引用计数\n- Runtime\n- Runloop\n- 对象模型\n- Hybrid\n- 沙盒机制\n- AVFoundation\n- Core Text\n-逆向与安全\n - class dump\n - IDA Pro\n - Hopper\n - iOS Class Guard\n\n# 设计模式\n\n\n- MVC\n- MVVM\n- 通知\n- 代理\n- KVO\n- 工厂模式\n- 命令模式\n\n# 函数式编程\n\n\n\n- ReactiveCocoa\n- RxSwift\n\n# 开发工具\n\n\n- IDE\n - Xcode\n - AppCode\n- 调试工具\n - Charles、Wireshark\n - Reveal\n - Instruments\n- 插件\n - Alcatraz\n - VVDocument\n - XVim\n - FuzzyAutocompletePlugin\n - KSImageNamed-Xcode\n- 辅助工具\n - xScope\n - ImageOptim\n - 马克鳗\n - Dash\n - Deploymate\n - FauxPas\n - PaintCode\n- 命令行工具\n - xcodebuild、xcode-select\n - nomad\n - xctool\n - fastlane\n- 持续集成\n - Jenkins\n - Travis CI\n - Bot\n\n# 开源项目\n\n\n\n- AFNetworking & Alamofire\n- Masonry\n- SDWebImage\n- SwiftyJSON\n- JSPatch\n- React Native\n\n# 包管理\n\n\n- CocoaPods\n- Carthage\n- Swift Package Manager\n\n# App打包上传与审核\n\n\n- Apple Developer 网站\n- iTunes Connect 网站\n- IAP\n- 加急审核申请\n- 打包脚本\n\n# 第三方服务\n\n\n\n- 崩溃收集\n - Bugly\n - Crashlytics\n - BugHD\n- 数据统计\n - Google Analytics\n - 友盟\n - MTA\n - Flurry\n - App Annie\n- 应用分发\n - TestFlight\n - 蒲公英\n - FIR\n \n>以上均来自[iOS 技能图谱](http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=451444627&idx=1&sn=2966dc944518dd88798217b9e340f0b2&scene=0#wechat_redirect)","slug":"生活/2016-2-1-PlanOfiOS","published":1,"updated":"2016-04-10T11:50:57.000Z","comments":1,"photos":[],"link":"","_id":"cisw1ptsm001kyrntlj20wkkg","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>之前受 StuQ 之托，整理了iOS 技能图谱，分享给大家。大家如果觉得有什么推荐的，也可以留言回复。</p>\n<p>我对技能图谱的价值持谨慎的态度，因为本身技术更新就比较快，图谱很难做到面面俱到和与时俱进，比如说最近有一个集成平台 <a href=\"https://buddybuild.com/\" target=\"_blank\" rel=\"external\">https://buddybuild.com/</a> 就很火，我很难保证快速更新这些内容。</p>\n<p>但是话说回来，有一个图谱，或许对一些人来说也是一个知识的查漏补缺的工具，看看也不会怀孕不是？</p>\n<p>以下是图谱正文内容。</p>\n<h1 id=\"编程语言\"><a href=\"#编程语言\" class=\"headerlink\" title=\"编程语言\"></a>编程语言</h1><ul>\n<li>Swift</li>\n<li>Objective-C</li>\n<li>C++/C</li>\n<li>JavaScript</li>\n</ul>\n<h1 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h1><ul>\n<li>Mac OSX</li>\n<li>iOS</li>\n<li>watchOS</li>\n<li>tvOS</li>\n<li>Linux 常用命令</li>\n</ul>\n<h1 id=\"开发基础\"><a href=\"#开发基础\" class=\"headerlink\" title=\"开发基础\"></a>开发基础</h1><ul>\n<li>UI 控件</li>\n<li>Storyboard &amp; Xib</li>\n<li>Core Data &amp; Sqlite</li>\n<li>Core Graphics</li>\n<li>Animation</li>\n<li>Block &amp; GCD</li>\n<li>Test Case 编写</li>\n<li>Framework</li>\n<li>Autolayout</li>\n<li>手势识别，重力感应</li>\n</ul>\n<h1 id=\"开发进阶\"><a href=\"#开发进阶\" class=\"headerlink\" title=\"开发进阶\"></a>开发进阶</h1><ul>\n<li>引用计数</li>\n<li>Runtime</li>\n<li>Runloop</li>\n<li>对象模型</li>\n<li>Hybrid</li>\n<li>沙盒机制</li>\n<li>AVFoundation</li>\n<li>Core Text<br>-逆向与安全<ul>\n<li>class dump</li>\n<li>IDA Pro</li>\n<li>Hopper</li>\n<li>iOS Class Guard</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><ul>\n<li>MVC</li>\n<li>MVVM</li>\n<li>通知</li>\n<li>代理</li>\n<li>KVO</li>\n<li>工厂模式</li>\n<li>命令模式</li>\n</ul>\n<h1 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h1><ul>\n<li>ReactiveCocoa</li>\n<li>RxSwift</li>\n</ul>\n<h1 id=\"开发工具\"><a href=\"#开发工具\" class=\"headerlink\" title=\"开发工具\"></a>开发工具</h1><ul>\n<li>IDE<ul>\n<li>Xcode</li>\n<li>AppCode</li>\n</ul>\n</li>\n<li>调试工具<ul>\n<li>Charles、Wireshark</li>\n<li>Reveal</li>\n<li>Instruments</li>\n</ul>\n</li>\n<li>插件<ul>\n<li>Alcatraz</li>\n<li>VVDocument</li>\n<li>XVim</li>\n<li>FuzzyAutocompletePlugin</li>\n<li>KSImageNamed-Xcode</li>\n</ul>\n</li>\n<li>辅助工具<ul>\n<li>xScope</li>\n<li>ImageOptim</li>\n<li>马克鳗</li>\n<li>Dash</li>\n<li>Deploymate</li>\n<li>FauxPas</li>\n<li>PaintCode</li>\n</ul>\n</li>\n<li>命令行工具<ul>\n<li>xcodebuild、xcode-select</li>\n<li>nomad</li>\n<li>xctool</li>\n<li>fastlane</li>\n</ul>\n</li>\n<li>持续集成<ul>\n<li>Jenkins</li>\n<li>Travis CI</li>\n<li>Bot</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"开源项目\"><a href=\"#开源项目\" class=\"headerlink\" title=\"开源项目\"></a>开源项目</h1><ul>\n<li>AFNetworking &amp; Alamofire</li>\n<li>Masonry</li>\n<li>SDWebImage</li>\n<li>SwiftyJSON</li>\n<li>JSPatch</li>\n<li>React Native</li>\n</ul>\n<h1 id=\"包管理\"><a href=\"#包管理\" class=\"headerlink\" title=\"包管理\"></a>包管理</h1><ul>\n<li>CocoaPods</li>\n<li>Carthage</li>\n<li>Swift Package Manager</li>\n</ul>\n<h1 id=\"App打包上传与审核\"><a href=\"#App打包上传与审核\" class=\"headerlink\" title=\"App打包上传与审核\"></a>App打包上传与审核</h1><ul>\n<li>Apple Developer 网站</li>\n<li>iTunes Connect 网站</li>\n<li>IAP</li>\n<li>加急审核申请</li>\n<li>打包脚本</li>\n</ul>\n<h1 id=\"第三方服务\"><a href=\"#第三方服务\" class=\"headerlink\" title=\"第三方服务\"></a>第三方服务</h1><ul>\n<li>崩溃收集<ul>\n<li>Bugly</li>\n<li>Crashlytics</li>\n<li>BugHD</li>\n</ul>\n</li>\n<li>数据统计<ul>\n<li>Google Analytics</li>\n<li>友盟</li>\n<li>MTA</li>\n<li>Flurry</li>\n<li>App Annie</li>\n</ul>\n</li>\n<li>应用分发<ul>\n<li>TestFlight</li>\n<li>蒲公英</li>\n<li>FIR</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>以上均来自<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=451444627&amp;idx=1&amp;sn=2966dc944518dd88798217b9e340f0b2&amp;scene=0#wechat_redirect\" target=\"_blank\" rel=\"external\">iOS 技能图谱</a></p>\n</blockquote>\n","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>之前受 StuQ 之托，整理了iOS 技能图谱，分享给大家。大家如果觉得有什么推荐的，也可以留言回复。</p>\n<p>我对技能图谱的价值持谨慎的态度，因为本身技术更新就比较快，图谱很难做到面面俱到和与时俱进，比如说最近有一个集成平台 <a href=\"https://buddybuild.com/\">https://buddybuild.com/</a> 就很火，我很难保证快速更新这些内容。</p>\n<p>但是话说回来，有一个图谱，或许对一些人来说也是一个知识的查漏补缺的工具，看看也不会怀孕不是？</p>\n<p>以下是图谱正文内容。</p>\n<h1 id=\"编程语言\"><a href=\"#编程语言\" class=\"headerlink\" title=\"编程语言\"></a>编程语言</h1><ul>\n<li>Swift</li>\n<li>Objective-C</li>\n<li>C++/C</li>\n<li>JavaScript</li>\n</ul>\n<h1 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h1><ul>\n<li>Mac OSX</li>\n<li>iOS</li>\n<li>watchOS</li>\n<li>tvOS</li>\n<li>Linux 常用命令</li>\n</ul>\n<h1 id=\"开发基础\"><a href=\"#开发基础\" class=\"headerlink\" title=\"开发基础\"></a>开发基础</h1><ul>\n<li>UI 控件</li>\n<li>Storyboard &amp; Xib</li>\n<li>Core Data &amp; Sqlite</li>\n<li>Core Graphics</li>\n<li>Animation</li>\n<li>Block &amp; GCD</li>\n<li>Test Case 编写</li>\n<li>Framework</li>\n<li>Autolayout</li>\n<li>手势识别，重力感应</li>\n</ul>\n<h1 id=\"开发进阶\"><a href=\"#开发进阶\" class=\"headerlink\" title=\"开发进阶\"></a>开发进阶</h1><ul>\n<li>引用计数</li>\n<li>Runtime</li>\n<li>Runloop</li>\n<li>对象模型</li>\n<li>Hybrid</li>\n<li>沙盒机制</li>\n<li>AVFoundation</li>\n<li>Core Text<br>-逆向与安全<ul>\n<li>class dump</li>\n<li>IDA Pro</li>\n<li>Hopper</li>\n<li>iOS Class Guard</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><ul>\n<li>MVC</li>\n<li>MVVM</li>\n<li>通知</li>\n<li>代理</li>\n<li>KVO</li>\n<li>工厂模式</li>\n<li>命令模式</li>\n</ul>\n<h1 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h1><ul>\n<li>ReactiveCocoa</li>\n<li>RxSwift</li>\n</ul>\n<h1 id=\"开发工具\"><a href=\"#开发工具\" class=\"headerlink\" title=\"开发工具\"></a>开发工具</h1><ul>\n<li>IDE<ul>\n<li>Xcode</li>\n<li>AppCode</li>\n</ul>\n</li>\n<li>调试工具<ul>\n<li>Charles、Wireshark</li>\n<li>Reveal</li>\n<li>Instruments</li>\n</ul>\n</li>\n<li>插件<ul>\n<li>Alcatraz</li>\n<li>VVDocument</li>\n<li>XVim</li>\n<li>FuzzyAutocompletePlugin</li>\n<li>KSImageNamed-Xcode</li>\n</ul>\n</li>\n<li>辅助工具<ul>\n<li>xScope</li>\n<li>ImageOptim</li>\n<li>马克鳗</li>\n<li>Dash</li>\n<li>Deploymate</li>\n<li>FauxPas</li>\n<li>PaintCode</li>\n</ul>\n</li>\n<li>命令行工具<ul>\n<li>xcodebuild、xcode-select</li>\n<li>nomad</li>\n<li>xctool</li>\n<li>fastlane</li>\n</ul>\n</li>\n<li>持续集成<ul>\n<li>Jenkins</li>\n<li>Travis CI</li>\n<li>Bot</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"开源项目\"><a href=\"#开源项目\" class=\"headerlink\" title=\"开源项目\"></a>开源项目</h1><ul>\n<li>AFNetworking &amp; Alamofire</li>\n<li>Masonry</li>\n<li>SDWebImage</li>\n<li>SwiftyJSON</li>\n<li>JSPatch</li>\n<li>React Native</li>\n</ul>\n<h1 id=\"包管理\"><a href=\"#包管理\" class=\"headerlink\" title=\"包管理\"></a>包管理</h1><ul>\n<li>CocoaPods</li>\n<li>Carthage</li>\n<li>Swift Package Manager</li>\n</ul>\n<h1 id=\"App打包上传与审核\"><a href=\"#App打包上传与审核\" class=\"headerlink\" title=\"App打包上传与审核\"></a>App打包上传与审核</h1><ul>\n<li>Apple Developer 网站</li>\n<li>iTunes Connect 网站</li>\n<li>IAP</li>\n<li>加急审核申请</li>\n<li>打包脚本</li>\n</ul>\n<h1 id=\"第三方服务\"><a href=\"#第三方服务\" class=\"headerlink\" title=\"第三方服务\"></a>第三方服务</h1><ul>\n<li>崩溃收集<ul>\n<li>Bugly</li>\n<li>Crashlytics</li>\n<li>BugHD</li>\n</ul>\n</li>\n<li>数据统计<ul>\n<li>Google Analytics</li>\n<li>友盟</li>\n<li>MTA</li>\n<li>Flurry</li>\n<li>App Annie</li>\n</ul>\n</li>\n<li>应用分发<ul>\n<li>TestFlight</li>\n<li>蒲公英</li>\n<li>FIR</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>以上均来自<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=451444627&amp;idx=1&amp;sn=2966dc944518dd88798217b9e340f0b2&amp;scene=0#wechat_redirect\">iOS 技能图谱</a></p>\n</blockquote>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cisw1ptr20008yrnt1jx5hg5y","category_id":"cisw1ptqy0006yrnt46k1vtt8","_id":"cisw1ptrh000fyrntwxexkuqh"},{"post_id":"cisw1ptqj0003yrntd96p3ut6","category_id":"cisw1ptqy0006yrnt46k1vtt8","_id":"cisw1ptrq000kyrntoh5q136u"},{"post_id":"cisw1ptr4000ayrntdy2lujs4","category_id":"cisw1ptqy0006yrnt46k1vtt8","_id":"cisw1ptrt000nyrnt3vd5zhlv"},{"post_id":"cisw1ptrc000dyrntoapx4pxv","category_id":"cisw1ptqy0006yrnt46k1vtt8","_id":"cisw1ptrw000ryrntsl1u1wub"},{"post_id":"cisw1ptqr0004yrnt60sqrxdy","category_id":"cisw1ptqy0006yrnt46k1vtt8","_id":"cisw1ptry000uyrntstriz6sd"},{"post_id":"cisw1ptrk000hyrntui3jrka6","category_id":"cisw1ptqy0006yrnt46k1vtt8","_id":"cisw1pts1000yyrnty9vl5t81"},{"post_id":"cisw1ptrq000lyrntjfcvm3pp","category_id":"cisw1ptqy0006yrnt46k1vtt8","_id":"cisw1pts50011yrnt7vdai7h6"},{"post_id":"cisw1ptqz0007yrntd5bvw8gn","category_id":"cisw1ptqy0006yrnt46k1vtt8","_id":"cisw1pts90014yrnte73806s0"},{"post_id":"cisw1ptrt000oyrntg0o9225u","category_id":"cisw1ptqy0006yrnt46k1vtt8","_id":"cisw1ptsc0018yrnt6c73hlll"},{"post_id":"cisw1ptrw000syrntt268cr42","category_id":"cisw1ptqy0006yrnt46k1vtt8","_id":"cisw1ptsg001byrntje3yy11n"},{"post_id":"cisw1ptry000vyrnt4dlp7wwg","category_id":"cisw1ptqy0006yrnt46k1vtt8","_id":"cisw1ptsj001eyrntne4dlhky"},{"post_id":"cisw1pts2000zyrntxy4gcxdi","category_id":"cisw1ptqy0006yrnt46k1vtt8","_id":"cisw1ptsk001hyrnt6v7jexzx"},{"post_id":"cisw1pts90015yrntgu5rid6z","category_id":"cisw1ptqy0006yrnt46k1vtt8","_id":"cisw1ptsl001jyrntf5u4v13i"},{"post_id":"cisw1ptsd0019yrntabbkbzj5","category_id":"cisw1ptqy0006yrnt46k1vtt8","_id":"cisw1ptso001lyrntqxq5xr10"},{"post_id":"cisw1ptsh001cyrntg8z95gx0","category_id":"cisw1ptsc0017yrntpwvyi4so","_id":"cisw1ptso001myrntfaq4861e"},{"post_id":"cisw1pts50012yrntyfh2zerx","category_id":"cisw1ptsc0017yrntpwvyi4so","_id":"cisw1ptso001nyrnto6b4tljv"},{"post_id":"cisw1ptsj001fyrnt7nkjkrk2","category_id":"cisw1ptsc0017yrntpwvyi4so","_id":"cisw1ptso001oyrntrv6oeloy"},{"post_id":"cisw1ptsk001iyrntgf3f5s9o","category_id":"cisw1ptsc0017yrntpwvyi4so","_id":"cisw1ptsp001pyrnt6umabpob"},{"post_id":"cisw1ptsm001kyrntlj20wkkg","category_id":"cisw1ptsc0017yrntpwvyi4so","_id":"cisw1ptsp001qyrntewmr966v"}],"PostTag":[{"post_id":"cisw1ptr20008yrnt1jx5hg5y","tag_id":"cisw1ptqt0005yrntg8w7pkw7","_id":"cisw1ptrb000cyrnta762p3z6"},{"post_id":"cisw1ptqj0003yrntd96p3ut6","tag_id":"cisw1ptqt0005yrntg8w7pkw7","_id":"cisw1ptrf000eyrnt4djm5azo"},{"post_id":"cisw1ptr4000ayrntdy2lujs4","tag_id":"cisw1ptqt0005yrntg8w7pkw7","_id":"cisw1ptrp000jyrntnq6mpfqx"},{"post_id":"cisw1ptrc000dyrntoapx4pxv","tag_id":"cisw1ptqt0005yrntg8w7pkw7","_id":"cisw1ptrt000myrnt6otfeqdk"},{"post_id":"cisw1ptqr0004yrnt60sqrxdy","tag_id":"cisw1ptqt0005yrntg8w7pkw7","_id":"cisw1ptrw000qyrnt1b2umm28"},{"post_id":"cisw1ptrk000hyrntui3jrka6","tag_id":"cisw1ptqt0005yrntg8w7pkw7","_id":"cisw1ptry000tyrntedxlhu4r"},{"post_id":"cisw1ptqz0007yrntd5bvw8gn","tag_id":"cisw1ptqt0005yrntg8w7pkw7","_id":"cisw1pts0000wyrntrqcu7d8h"},{"post_id":"cisw1ptry000vyrnt4dlp7wwg","tag_id":"cisw1ptrw000pyrntpoq73j61","_id":"cisw1pts40010yrnttoqwutwu"},{"post_id":"cisw1ptrq000lyrntjfcvm3pp","tag_id":"cisw1ptrw000pyrntpoq73j61","_id":"cisw1pts70013yrntt5jnaj6b"},{"post_id":"cisw1pts2000zyrntxy4gcxdi","tag_id":"cisw1ptrw000pyrntpoq73j61","_id":"cisw1ptsb0016yrntlt9jyicm"},{"post_id":"cisw1ptrw000syrntt268cr42","tag_id":"cisw1ptrw000pyrntpoq73j61","_id":"cisw1ptsg001ayrntamjxnt89"},{"post_id":"cisw1pts90015yrntgu5rid6z","tag_id":"cisw1ptrw000pyrntpoq73j61","_id":"cisw1ptsj001dyrntdhygkwu0"},{"post_id":"cisw1ptsd0019yrntabbkbzj5","tag_id":"cisw1ptrw000pyrntpoq73j61","_id":"cisw1ptsk001gyrnt5phlf3n8"}],"Tag":[{"name":"实习工作","_id":"cisw1ptqt0005yrntg8w7pkw7"},{"name":"资料","_id":"cisw1ptrw000pyrntpoq73j61"}]}}